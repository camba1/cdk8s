{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview \u00b6 CDK8s is a software development framework for defining Kubernetes applications and reusable abstractions using familiar programming languages and rich object-oriented APIs. CDK8s generates pure Kubernetes YAML - you can use CDK8s to define applications for any Kubernetes cluster running anywhere. Read our blog or watch our CNCF webinar to learn more and see a live demo of CDK8s in action. How does it work \u00b6 CDK8s apps are programs written in one of the supported programming languages. They are structured as a tree of constructs . The root of the tree is an App construct. Within an app, users define any number of charts (classes that extend the Chart class). Each chart is synthesized into a separate Kubernetes manifest file. Charts are, in turn, composed of any number of constructs, and eventually from resources, which represent any Kubernetes resource, such as Pod , Service , Deployment , ReplicaSet , etc. CDK8s apps only define Kubernetes applications, they don\u2019t actually apply them to the cluster. When an app is executed, it synthesizes all the charts defined within the app into the dist directory, and then those charts can be applied to any Kubernetes cluster using kubectl apply -f dist/chart.k8s.yaml or a GitOps tool like Flux . CDK8s is based on the design concepts and technologies behind the AWS Cloud Development Kit , and can interoperate with AWS CDK constructs to define cloud-native applications that include both Kubernetes resources and other CDK constructs as first class citizens.","title":"Overview"},{"location":"#overview","text":"CDK8s is a software development framework for defining Kubernetes applications and reusable abstractions using familiar programming languages and rich object-oriented APIs. CDK8s generates pure Kubernetes YAML - you can use CDK8s to define applications for any Kubernetes cluster running anywhere. Read our blog or watch our CNCF webinar to learn more and see a live demo of CDK8s in action.","title":"Overview"},{"location":"#how-does-it-work","text":"CDK8s apps are programs written in one of the supported programming languages. They are structured as a tree of constructs . The root of the tree is an App construct. Within an app, users define any number of charts (classes that extend the Chart class). Each chart is synthesized into a separate Kubernetes manifest file. Charts are, in turn, composed of any number of constructs, and eventually from resources, which represent any Kubernetes resource, such as Pod , Service , Deployment , ReplicaSet , etc. CDK8s apps only define Kubernetes applications, they don\u2019t actually apply them to the cluster. When an app is executed, it synthesizes all the charts defined within the app into the dist directory, and then those charts can be applied to any Kubernetes cluster using kubectl apply -f dist/chart.k8s.yaml or a GitOps tool like Flux . CDK8s is based on the design concepts and technologies behind the AWS Cloud Development Kit , and can interoperate with AWS CDK constructs to define cloud-native applications that include both Kubernetes resources and other CDK constructs as first class citizens.","title":"How does it work"},{"location":"getting-started/","text":"Getting Started \u00b6 This guide will walk you through the following steps: Installing the CDK8s CLI. Creating a new CDK8s project in one of the supported programming languages. Define & deploy your first CDK8s application. Define a custom CDK8s construct. Install the CLI \u00b6 CDK8s has a cute little CLI that has a few useful commands. Let\u2019s start by installing the CDK8s CLI globally. We have two options for this. npm npm install -g cdk8s-cli yarn yarn global add cdk8s-cli Prerequisites \u00b6 TypeScript Node.js >= 12.13.0 Your favorite editor/IDE yarn (optional) Python Python >= 3.7.7 pipenv version 2018.11.26 or above. Your favorite editor/IDE Java Maven >= 3.6.3 Your favorite editor/IDE Go Go >= 1.16 Your favorite editor/IDE Info This Getting Started guide will help you create a Kubernetes manifest using your preferred programming language. You do not need access to a Kubernetes cluster in order to produce a manifests using CDK8s. New Project \u00b6 Now, we\u2019ll use the cdk8s init command to create a new CDK8s app: TypeScript $ mkdir hello $ cd hello $ cdk8s init typescript-app Initializing a project from the typescript-app template ... Python $ mkdir hello $ cd hello $ cdk8s init python-app Initializing a project from the python-app template ... Java $ mkdir hello $ cd hello $ cdk8s init java-app Initializing a project from the java-app template ... Go $ mkdir hello $ cd hello $ cdk8s init go-app Initializing a project from the go-app template This will perform the following: Create a new project directory Install CDK8s as a dependency Import all Kubernetes API objects Apps & Charts \u00b6 Apps are structured as a tree of constructs , which are composable units of abstraction. We will learn more about constructs soon. This initial code created by cdk8s init defines an app with a single, empty, chart. When you synthesize the app, a Kubernetes manifest YAML will be produced for each Chart in your app and will write it to the dist directory. At this point, the YAML file should be empty since we haven\u2019t defined any resources yet. Let have a look at the code: TypeScript main.ts import { Construct } from 'constructs' ; import { App , Chart , ChartProps } from 'cdk8s' ; export class MyChart extends Chart { constructor ( scope : Construct , id : string , props : ChartProps = { }) { super ( scope , id , props ); // define resources here } } const app = new App (); new MyChart ( app , 'hello' ); app . synth (); To produce and inspect the generated manifest, you can run: npm run compile && cdk8s synth dist/hello.k8s.yaml cat dist/hello.k8s.yaml <EMPTY> Note that since TypeScript is a compiled language, we will need to compile .ts files to .js in order to execute our CDK8s app. To avoid explicitly compiling every time, you can run a watch process in the background by running: npm run watch Python main.py #!/usr/bin/env python from constructs import Construct from cdk8s import App , Chart class MyChart ( Chart ): def __init__ ( self , scope : Construct , id : str ): super () . __init__ ( scope , id ) # define resources here app = App () MyChart ( app , \"hello\" ) app . synth () To produce and inspect the generated manifest, you can run: cdk8s synth dist/hello.k8s.yaml cat dist/hello.k8s.yaml <EMPTY> Java src/main/java/com/mycompany/app/Main.java package com.mycompany.app ; import software.constructs.Construct ; import org.cdk8s.App ; import org.cdk8s.Chart ; import org.cdk8s.ChartProps ; public class Main extends Chart { public Main ( final Construct scope , final String id ) { this ( scope , id , null ); } public Main ( final Construct scope , final String id , final ChartProps options ) { super ( scope , id , options ); // define resources here } public static void main ( String [] args ) { final App app = new App (); new Main ( app , \"hello\" ); app . synth (); } } To produce and inspect the generated manifest, you can run: cdk8s synth dist/hello.k8s.yaml cat dist/hello.k8s.yaml <EMPTY> Go main.go package main import ( \"github.com/aws/constructs-go/constructs/v3\" \"github.com/aws/jsii-runtime-go\" \"github.com/cdk8s-team/cdk8s-core-go/cdk8s\" ) type MyChartProps struct { cdk8s . ChartProps } func NewMyChart ( scope constructs . Construct , id string , props * MyChartProps ) cdk8s . Chart { var cprops cdk8s . ChartProps if props != nil { cprops = props . ChartProps } chart := cdk8s . NewChart ( scope , jsii . String ( id ), & cprops ) // define resources here return chart } func main () { app := cdk8s . NewApp ( nil ) NewMyChart ( app , \"hello\" , nil ) app . Synth () } To produce and inspect the generated manifest, you can run: cdk8s synth dist/hello.k8s.yaml cat dist/hello.k8s.yaml <EMPTY> Importing Constructs for the Kubernetes API \u00b6 OK, now let\u2019s define some Kubernetes API objects inside our chart. Similarly to charts and apps , Kubernetes API Objects are also represented in CDK8s as constructs . These constructs are imported to your project using the cdk8s import command which will add source files to your project that include constructs that represent the Kubernetes API. Info When cdk8s init created your project it already executed cdk8s import for you, so you should see an imports directory already there. You can either commit this directory to source-control or generate it as part of your build process. Now, let\u2019s use these constructs to define a simple Kubernetes application which contains Service and a Deployment resources inspired by paulbouwer \u2018s hello-kubernetes project. TypeScript import { Construct } from 'constructs' ; import { App , Chart , ChartProps } from 'cdk8s' ; // imported constructs import { KubeDeployment , KubeService , IntOrString } from './imports/k8s' ; export class MyChart extends Chart { constructor ( scope : Construct , id : string , props : ChartProps = { }) { super ( scope , id , props ); const label = { app : 'hello-k8s' }; // notice that there is no assigment necessary when creating resources. // simply instantiating the resource is enough because it adds it to the construct tree via // the first argument, which is always the parent construct. // its a little confusing at first glance, but this is an inherent aspect of the constructs // programming model, and you will encounter it many times. // you can still perform an assignment of course, if you need to access // atrtibutes of the resource in other parts of the code. new KubeService ( this , 'service' , { spec : { type : 'LoadBalancer' , ports : [ { port : 80 , targetPort : IntOrString.fromNumber ( 8080 ) } ], selector : label } }); new KubeDeployment ( this , 'deployment' , { spec : { replicas : 2 , selector : { matchLabels : label }, template : { metadata : { labels : label }, spec : { containers : [ { name : 'hello-kubernetes' , image : 'paulbouwer/hello-kubernetes:1.7' , ports : [ { containerPort : 8080 } ] } ] } } } }); } } const app = new App (); new MyChart ( app , 'hello' ); app . synth (); Now, to synthesize the app, run: npm run compile && cdk8s synth Python #!/usr/bin/env python from constructs import Construct from cdk8s import App , Chart from imports import k8s class MyChart ( Chart ): def __init__ ( self , scope : Construct , id : str ): super () . __init__ ( scope , id ) # define resources here label = { \"app\" : \"hello-k8s\" } # notice that there is no assigment necessary when creating resources. # simply instantiating the resource is enough because it adds it to the construct tree via # the first argument, which is always the parent construct. # its a little confusing at first glance, but this is an inherent aspect of the constructs # programming model, and you will encounter it many times. # you can still perform an assignment of course, if you need to access # atrtibutes of the resource in other parts of the code. k8s . KubeService ( self , 'service' , spec = k8s . ServiceSpec ( type = 'LoadBalancer' , ports = [ k8s . ServicePort ( port = 80 , target_port = k8s . IntOrString . from_number ( 8080 ))], selector = label )) k8s . KubeDeployment ( self , 'deployment' , spec = k8s . DeploymentSpec ( replicas = 2 , selector = k8s . LabelSelector ( match_labels = label ), template = k8s . PodTemplateSpec ( metadata = k8s . ObjectMeta ( labels = label ), spec = k8s . PodSpec ( containers = [ k8s . Container ( name = 'hello-kubernetes' , image = 'paulbouwer/hello-kubernetes:1.7' , ports = [ k8s . ContainerPort ( container_port = 8080 )])])))) app = App () MyChart ( app , \"hello\" ) app . synth () Now, to synthesize the app, run: cdk8s synth Java package com.mycompany.app ; import software.constructs.Construct ; import java.util.ArrayList ; import java.util.List ; import java.util.HashMap ; import java.util.Map ; import org.cdk8s.App ; import org.cdk8s.Chart ; import org.cdk8s.ChartProps ; import imports.k8s.IntOrString ; import imports.k8s.LabelSelector ; import imports.k8s.ObjectMeta ; import imports.k8s.PodTemplateSpec ; import imports.k8s.KubeService ; import imports.k8s.KubeServiceProps ; import imports.k8s.ServicePort ; import imports.k8s.ServiceSpec ; import imports.k8s.DeploymentSpec ; import imports.k8s.PodSpec ; import imports.k8s.Container ; import imports.k8s.ContainerPort ; import imports.k8s.KubeDeployment ; import imports.k8s.KubeDeploymentProps ; public class Main extends Chart { public Main ( final Construct scope , final String id ) { this ( scope , id , null ); } public Main ( final Construct scope , final String id , final ChartProps options ) { super ( scope , id , options ); // Defining a LoadBalancer Service final String serviceType = \"LoadBalancer\" ; final Map < String , String > selector = new HashMap <> (); selector . put ( \"app\" , \"hello-k8s\" ); final List < ServicePort > servicePorts = new ArrayList <> (); final ServicePort servicePort = new ServicePort . Builder () . port ( 80 ) . targetPort ( IntOrString . fromNumber ( 8080 )) . build (); servicePorts . add ( servicePort ); final ServiceSpec serviceSpec = new ServiceSpec . Builder () . type ( serviceType ) . selector ( selector ) . ports ( servicePorts ) . build (); final KubeServiceProps serviceProps = new KubeServiceProps . Builder () . spec ( serviceSpec ) . build (); // notice that there is no assigment neccesary when creating resources. // simply instantiating the resource is enough because it adds it to the construct tree via // the first argument, which is always the parent construct. // its a little confusing at first glance, but this is an inherent aspect of the constructs // programming model, and you will encounter it many times. // you can still perform an assignment of course, if you need to access // atrtibutes of the resource in other parts of the code. new KubeService ( this , \"service\" , serviceProps ); // Defining a Deployment final LabelSelector labelSelector = new LabelSelector . Builder (). matchLabels ( selector ). build (); final ObjectMeta objectMeta = new ObjectMeta . Builder (). labels ( selector ). build (); final List < ContainerPort > containerPorts = new ArrayList <> (); final ContainerPort containerPort = new ContainerPort . Builder () . containerPort ( 8080 ) . build (); containerPorts . add ( containerPort ); final List < Container > containers = new ArrayList <> (); final Container container = new Container . Builder () . name ( \"hello-kubernetes\" ) . image ( \"paulbouwer/hello-kubernetes:1.7\" ) . ports ( containerPorts ) . build (); containers . add ( container ); final PodSpec podSpec = new PodSpec . Builder () . containers ( containers ) . build (); final PodTemplateSpec podTemplateSpec = new PodTemplateSpec . Builder () . metadata ( objectMeta ) . spec ( podSpec ) . build (); final DeploymentSpec deploymentSpec = new DeploymentSpec . Builder () . replicas ( 1 ) . selector ( labelSelector ) . template ( podTemplateSpec ) . build (); final KubeDeploymentProps deploymentProps = new KubeDeploymentProps . Builder () . spec ( deploymentSpec ) . build (); new KubeDeployment ( this , \"deployment\" , deploymentProps ); } public static void main ( String [] args ) { final App app = new App (); new Main ( app , \"hello\" ); app . synth (); } } Now, to synthesize the app, run: cdk8s synth Go package main import ( \"example.com/hello-k8s/imports/k8s\" \"github.com/aws/constructs-go/constructs/v3\" \"github.com/aws/jsii-runtime-go\" \"github.com/cdk8s-team/cdk8s-core-go/cdk8s\" ) type MyChartProps struct { cdk8s . ChartProps } func NewMyChart ( scope constructs . Construct , id string , props * MyChartProps ) cdk8s . Chart { var cprops cdk8s . ChartProps if props != nil { cprops = props . ChartProps } chart := cdk8s . NewChart ( scope , jsii . String ( id ), & cprops ) label := map [ string ] * string { \"app\" : jsii . String ( \"hello-k8s\" )} k8s . NewKubeService ( chart , jsii . String ( \"service\" ), & k8s . KubeServiceProps { Spec : & k8s . ServiceSpec { Type : jsii . String ( \"LoadBalancer\" ), Ports : & [] * k8s . ServicePort {{ Port : jsii . Number ( 80 ), TargetPort : k8s . IntOrString_FromNumber ( jsii . Number ( 8000 )), }}, Selector : & label , }, }) // notice that there is no assigment neccesary when creating resources. // simply instantiating the resource is enough because it adds it to the construct tree via // the first argument, which is always the parent construct. // its a little confusing at first glance, but this is an inherent aspect of the constructs // programming model, and you will encounter it many times. // you can still perform an assignment of course, if you need to access // atrtibutes of the resource in other parts of the code. k8s . NewKubeDeployment ( chart , jsii . String ( \"deployment\" ), & k8s . KubeDeploymentProps { Spec : & k8s . DeploymentSpec { Replicas : jsii . Number ( 2 ), Selector : & k8s . LabelSelector { MatchLabels : & label , }, Template : & k8s . PodTemplateSpec { Metadata : & k8s . ObjectMeta { Labels : & label , }, Spec : & k8s . PodSpec { Containers : & [] * k8s . Container {{ Name : jsii . String ( \"hello-kubernetes\" ), Image : jsii . String ( \"paulbouwer/hello-kubernetes:1.7\" ), Ports : & [] * k8s . ContainerPort {{ ContainerPort : jsii . Number ( 8080 )}}, }}, }, }, }, }) return chart } func main () { app := cdk8s . NewApp ( nil ) NewMyChart ( app , \"hello\" , nil ) app . Synth () } Now, to synthesize the app, run: cdk8s synth This will be contents of hello.k8s.yaml : apiVersion : \"v1\" kind : \"Service\" metadata : name : \"hello-service-c8c17160\" spec : ports : - port : 80 targetPort : 8080 selector : app : \"hello-k8s\" type : \"LoadBalancer\" --- apiVersion : \"apps/v1\" kind : \"Deployment\" metadata : name : \"hello-deployment-c8c7fda7\" spec : replicas : 2 selector : matchLabels : app : \"hello-k8s\" template : metadata : labels : app : \"hello-k8s\" spec : containers : - image : \"paulbouwer/hello-kubernetes:1.7\" name : \"hello-kubernetes\" ports : - containerPort : 8080 The manifest synthesized by your app is ready to be applied to any Kubernetes cluster using standard tools like kubectl apply : kubectl apply -f dist/hello.k8s.yaml Abstraction through Constructs \u00b6 Constructs are the basic building block of CDK8s . They are the instrument that enables composition and creation of higher-level abstractions through normal object-oriented classes. If you come from the Kubernetes world, you can think of constructs as programmatically defined Helm Charts. The nice thing about constructs being \u201cprogrammatically defined\u201d is that we can use them to leverage the full power of object-oriented programming. For example: You can express the abstraction\u2019s API using strong-typed data types You can express rich interactions with methods and properties You can create polymorphic programming models through interfaces and base classes Share them through regular package managers Test them using our familiar testing tools and techniques Version them \u2026and do all that stuff that we\u2019ve been doing with software in the past 20 years. So let\u2019s create our first Kubernetes construct. We\u2019ll call it WebService and it will basically be a generalization of the hello world program. It\u2019s actually quite useful. For example, this one line will add a hello world service to our chart: TypeScript new WebService ( this , 'hello-k8s' , { image : 'paulbouwer/hello-kubernetes:1.7' }); It can also be customized through an API: new WebService ( this , 'hello-k8s' , { image : 'paulbouwer/hello-kubernetes:1.7' , containerPort : 8080 , replicas : 10 }); Python WebService ( self , 'hello' , image = 'paulbouwer/hello-kubernetes:1.7' ) It can also be customized through an API: WebService ( self , 'hello-k8s' , image = 'paulbouwer/hello-kubernetes:1.7' , container_port = 8080 , replicas = 10 ) Java new WebService ( this , \"hello-k8s\" , new WebServiceProps . Builder () . image ( \"paulbouwer/hello-kubernetes:1.7\" ) . build ()); It can also be customized through an API: new WebService ( this , \"hello-k8s\" , new WebServiceProps . Builder () . image ( \"paulbouwer/hello-kubernetes:1.7\" ) . replicas ( 2 ) . build ()); Go NewWebService ( chart , jsii . String ( \"hello\" ), & WebServiceProps { Image : jsii . String ( \"paulbouwer/hello-kubernetes:1.7\" ), }) It can also be customized through an API: NewWebService ( chart , jsii . String ( \"hello\" ), & WebServiceProps { Image : jsii . String ( \"paulbouwer/hello-kubernetes:1.7\" ), ContainerPort : jsii . Number ( 8080 ), Replicas : jsii . Number ( 10 ), }) Here\u2019s how to implement WebService : TypeScript Create a file lib/web-service.ts (the convention is to use lib for reusable components): import { Construct } from 'constructs' ; import { Names } from 'cdk8s' ; import { KubeDeployment , KubeService , IntOrString } from '../imports/k8s' ; export interface WebServiceProps { /** * The Docker image to use for this service. */ readonly image : string ; /** * Number of replicas. * * @default 1 */ readonly replicas? : number ; /** * External port. * * @default 80 */ readonly port? : number ; /** * Internal port. * * @default 8080 */ readonly containerPort? : number ; } export class WebService extends Construct { constructor ( scope : Construct , id : string , props : WebServiceProps ) { super ( scope , id ); const port = props . port || 80 ; const containerPort = props . containerPort || 8080 ; const label = { app : Names.toDnsLabel ( this ) }; const replicas = props . replicas ?? 1 ; new KubeService ( this , 'service' , { spec : { type : 'LoadBalancer' , ports : [ { port , targetPort : IntOrString.fromNumber ( containerPort ) } ], selector : label } }); new KubeDeployment ( this , 'deployment' , { spec : { replicas , selector : { matchLabels : label }, template : { metadata : { labels : label }, spec : { containers : [ { name : 'app' , image : props.image , ports : [ { containerPort } ] } ] } } } }); } } Now, let\u2019s edit main.ts and use our new construct: import { Construct } from 'constructs' ; import { App , Chart , ChartProps } from 'cdk8s' ; import { WebService } from './lib/web-service' ; export class MyChart extends Chart { constructor ( scope : Construct , id : string , props : ChartProps = { }) { super ( scope , id , props ); new WebService ( this , 'hello' , { image : 'paulbouwer/hello-kubernetes:1.7' , replicas : 2 }); new WebService ( this , 'ghost' , { image : 'ghost' , containerPort : 2368 }); } } const app = new App (); new MyChart ( app , 'hello' ); app . synth (); Python Create a file webservice.py with the following content: from constructs import Construct , Node from imports import k8s class WebService ( Construct ): def __init__ ( self , scope : Construct , id : str , * , image : str , replicas : int = 1 , port : int = 80 , container_port : int = 8080 ): super () . __init__ ( scope , id ) label = { 'app' : Node . of ( self ) . unique_id } k8s . KubeService ( self , 'service' , spec = k8s . ServiceSpec ( type = 'LoadBalancer' , ports = [ k8s . ServicePort ( port = port , target_port = k8s . IntOrString . from_number ( container_port ))], selector = label )) k8s . KubeDeployment ( self , 'deployment' , spec = k8s . DeploymentSpec ( replicas = replicas , selector = k8s . LabelSelector ( match_labels = label ), template = k8s . PodTemplateSpec ( metadata = k8s . ObjectMeta ( labels = label ), spec = k8s . PodSpec ( containers = [ k8s . Container ( name = 'app' , image = image , ports = [ k8s . ContainerPort ( container_port = container_port )])])))) Now, let\u2019s edit main.py and use our new construct: #!/usr/bin/env python from constructs import Construct from cdk8s import App , Chart from webservice import WebService class MyChart ( Chart ): def __init__ ( self , scope : Construct , id : str ): super () . __init__ ( scope , id ) WebService ( self , 'hello' , image = 'paulbouwer/hello-kubernetes:1.7' , replicas = 2 ) WebService ( self , 'ghost' , image = 'ghost' , container_port = 2368 ) app = App () MyChart ( app , \"hello\" ) app . synth () Java src/main/java/com/mycompany/app/WebService.java package com.mycompany.app ; import software.constructs.Construct ; import java.util.ArrayList ; import java.util.List ; import java.util.HashMap ; import java.util.Map ; import java.util.Optional ; import imports.k8s.IntOrString ; import imports.k8s.LabelSelector ; import imports.k8s.ObjectMeta ; import imports.k8s.PodTemplateSpec ; import imports.k8s.KubeService ; import imports.k8s.KubeServiceProps ; import imports.k8s.ServicePort ; import imports.k8s.ServiceSpec ; import imports.k8s.DeploymentSpec ; import imports.k8s.PodSpec ; import imports.k8s.Container ; import imports.k8s.ContainerPort ; import imports.k8s.KubeDeployment ; import imports.k8s.KubeDeploymentProps ; public class WebService extends Construct { public WebService ( final Construct scope , final String id ) { this ( scope , id , null ); } public WebService ( final Construct scope , final String id , final WebServiceProps options ) { super ( scope , id ); final int portNumber = Optional . of ( options . getPort ()). orElse ( 80 ); final int containerPortNumber = Optional . of ( options . getContainerPort ()). orElse ( 8080 ); final int replicas = Optional . of ( options . getReplicas ()). orElse ( 1 ); final String image = options . getImage (); // Defining a LoadBalancer Service final String serviceType = \"LoadBalancer\" ; final Map < String , String > selector = new HashMap <> (); selector . put ( \"app\" , \"hello-k8s\" ); final List < ServicePort > servicePorts = new ArrayList <> (); final ServicePort servicePort = new ServicePort . Builder () . port ( portNumber ) . targetPort ( IntOrString . fromNumber ( containerPortNumber )) . build (); servicePorts . add ( servicePort ); final ServiceSpec serviceSpec = new ServiceSpec . Builder () . type ( serviceType ) . selector ( selector ) . ports ( servicePorts ) . build (); final KubeServiceProps serviceProps = new KubeServiceProps . Builder () . spec ( serviceSpec ) . build (); new KubeService ( this , \"service\" , serviceProps ); // Defining a Deployment final LabelSelector labelSelector = new LabelSelector . Builder (). matchLabels ( selector ). build (); final ObjectMeta objectMeta = new ObjectMeta . Builder (). labels ( selector ). build (); final List < ContainerPort > containerPorts = new ArrayList <> (); final ContainerPort containerPort = new ContainerPort . Builder () . containerPort ( containerPortNumber ) . build (); containerPorts . add ( containerPort ); final List < Container > containers = new ArrayList <> (); final Container container = new Container . Builder () . name ( \"web\" ) . image ( image ) . ports ( containerPorts ) . build (); containers . add ( container ); final PodSpec podSpec = new PodSpec . Builder () . containers ( containers ) . build (); final PodTemplateSpec podTemplateSpec = new PodTemplateSpec . Builder () . metadata ( objectMeta ) . spec ( podSpec ) . build (); final DeploymentSpec deploymentSpec = new DeploymentSpec . Builder () . replicas ( replicas ) . selector ( labelSelector ) . template ( podTemplateSpec ) . build (); final KubeDeploymentProps deploymentProps = new KubeDeploymentProps . Builder () . spec ( deploymentSpec ) . build (); new KubeDeployment ( this , \"deployment\" , deploymentProps ); } } src/main/java/com/mycompany/app/WebServiceProps.java package com.mycompany.app ; public class WebServiceProps { private String image ; private int replicas ; private int port ; private int containerPort ; public WebServiceProps ( final String image , final int replicas , final int port , final int containerPort ) { this . image = image ; this . replicas = replicas ; this . port = port ; this . containerPort = containerPort ; } public String getImage () { return this . image ; } public int getReplicas () { return this . replicas ; } public int getPort () { return this . port ; } public int getContainerPort () { return this . containerPort ; } public static final class Builder { private String image ; private int replicas = 1 ; private int port = 80 ; private int containerPort = 8080 ; public Builder image ( String image ) { this . image = image ; return this ; } public Builder replicas ( int replicas ) { this . replicas = replicas ; return this ; } public Builder port ( int port ) { this . port = port ; return this ; } public Builder containerPort ( int containerPort ) { this . containerPort = containerPort ; return this ; } public WebServiceProps build () { return new WebServiceProps ( image , replicas , port , containerPort ); } } } src/main/java/com/mycompany/app/Main.java package com.mycompany.app ; import software.constructs.Construct ; import org.cdk8s.App ; import org.cdk8s.Chart ; import org.cdk8s.ChartProps ; public class Main extends Chart { public Main ( final Construct scope , final String id ) { this ( scope , id , null ); } public Main ( final Construct scope , final String id , final ChartProps options ) { super ( scope , id , options ); new WebService ( this , \"hello\" , new WebServiceProps . Builder () . image ( \"paulbouwer/hello-kubernetes:1.7\" ) . replicas ( 2 ) . build ()); new WebService ( this , \"ghost\" , new WebServiceProps . Builder () . image ( \"ghost\" ) . containerPort ( 2368 ) . build ()); } public static void main ( String [] args ) { final App app = new App (); new Main ( app , \"web-service-java\" ); app . synth (); } } Go Create a file webservice.go with the following content: package main import ( \"example.com/hello/imports/k8s\" \"github.com/aws/constructs-go/constructs/v3\" \"github.com/aws/jsii-runtime-go\" ) type WebServiceProps struct { constructs . ConstructOptions Image * string Replicas * float64 Port * float64 ContainerPort * float64 } func NewWebService ( scope constructs . Construct , id * string , props * WebServiceProps ) constructs . Construct { var cprops constructs . ConstructOptions if props != nil { cprops = props . ConstructOptions } construct := constructs . NewConstruct ( scope , id , & cprops ) replicas := props . Replicas if replicas == nil { replicas = jsii . Number ( 1 ) } port := props . Port if port == nil { port = jsii . Number ( 80 ) } containerPort := props . ContainerPort if containerPort == nil { containerPort = jsii . Number ( 8080 ) } label := map [ string ] * string { \"app\" : constructs . Node_Of ( construct ). Id (), } k8s . NewKubeService ( construct , jsii . String ( \"service\" ), & k8s . KubeServiceProps { Spec : & k8s . ServiceSpec { Type : jsii . String ( \"LoadBalancer\" ), Ports : & [] * k8s . ServicePort {{ Port : port , TargetPort : k8s . IntOrString_FromNumber ( containerPort ), }}, Selector : & label , }, }) k8s . NewKubeDeployment ( construct , jsii . String ( \"deployment\" ), & k8s . KubeDeploymentProps { Spec : & k8s . DeploymentSpec { Replicas : replicas , Selector : & k8s . LabelSelector { MatchLabels : & label }, Template : & k8s . PodTemplateSpec { Metadata : & k8s . ObjectMeta { Labels : & label }, Spec : & k8s . PodSpec { Containers : & [] * k8s . Container {{ Name : jsii . String ( \"web\" ), Image : props . Image , Ports : & [] * k8s . ContainerPort {{ ContainerPort : containerPort }}, }}, }, }, }, }) return construct } Now, let\u2019s edit main.go and use our new construct: package main import ( \"github.com/aws/constructs-go/constructs/v3\" \"github.com/aws/jsii-runtime-go\" \"github.com/cdk8s-team/cdk8s-core-go/cdk8s\" ) type MyChartProps struct { cdk8s . ChartProps } func NewMyChart ( scope constructs . Construct , id string , props * MyChartProps ) cdk8s . Chart { var cprops cdk8s . ChartProps if props != nil { cprops = props . ChartProps } chart := cdk8s . NewChart ( scope , jsii . String ( id ), & cprops ) NewWebService ( chart , jsii . String ( \"hello\" ), & WebServiceProps { Image : jsii . String ( \"paulbouwer/hello-kubernetes:1.7\" ), Replicas : jsii . Number ( 2 ), }) NewWebService ( chart , jsii . String ( \"ghost\" ), & WebServiceProps { Image : jsii . String ( \"ghost\" ), ContainerPort : jsii . Number ( 2368 ), }) return chart } func main () { app := cdk8s . NewApp ( nil ) NewMyChart ( app , \"hello\" , nil ) app . Synth () } As you can see, we now add WebService constructs inside our chart: one that runs the paulbouwer/hello-kubernetes image and one with an installation of ghost .","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"This guide will walk you through the following steps: Installing the CDK8s CLI. Creating a new CDK8s project in one of the supported programming languages. Define & deploy your first CDK8s application. Define a custom CDK8s construct.","title":"Getting Started"},{"location":"getting-started/#install-the-cli","text":"CDK8s has a cute little CLI that has a few useful commands. Let\u2019s start by installing the CDK8s CLI globally. We have two options for this. npm npm install -g cdk8s-cli yarn yarn global add cdk8s-cli","title":"Install the CLI"},{"location":"getting-started/#prerequisites","text":"TypeScript Node.js >= 12.13.0 Your favorite editor/IDE yarn (optional) Python Python >= 3.7.7 pipenv version 2018.11.26 or above. Your favorite editor/IDE Java Maven >= 3.6.3 Your favorite editor/IDE Go Go >= 1.16 Your favorite editor/IDE Info This Getting Started guide will help you create a Kubernetes manifest using your preferred programming language. You do not need access to a Kubernetes cluster in order to produce a manifests using CDK8s.","title":"Prerequisites"},{"location":"getting-started/#new-project","text":"Now, we\u2019ll use the cdk8s init command to create a new CDK8s app: TypeScript $ mkdir hello $ cd hello $ cdk8s init typescript-app Initializing a project from the typescript-app template ... Python $ mkdir hello $ cd hello $ cdk8s init python-app Initializing a project from the python-app template ... Java $ mkdir hello $ cd hello $ cdk8s init java-app Initializing a project from the java-app template ... Go $ mkdir hello $ cd hello $ cdk8s init go-app Initializing a project from the go-app template This will perform the following: Create a new project directory Install CDK8s as a dependency Import all Kubernetes API objects","title":"New Project"},{"location":"getting-started/#apps-charts","text":"Apps are structured as a tree of constructs , which are composable units of abstraction. We will learn more about constructs soon. This initial code created by cdk8s init defines an app with a single, empty, chart. When you synthesize the app, a Kubernetes manifest YAML will be produced for each Chart in your app and will write it to the dist directory. At this point, the YAML file should be empty since we haven\u2019t defined any resources yet. Let have a look at the code: TypeScript main.ts import { Construct } from 'constructs' ; import { App , Chart , ChartProps } from 'cdk8s' ; export class MyChart extends Chart { constructor ( scope : Construct , id : string , props : ChartProps = { }) { super ( scope , id , props ); // define resources here } } const app = new App (); new MyChart ( app , 'hello' ); app . synth (); To produce and inspect the generated manifest, you can run: npm run compile && cdk8s synth dist/hello.k8s.yaml cat dist/hello.k8s.yaml <EMPTY> Note that since TypeScript is a compiled language, we will need to compile .ts files to .js in order to execute our CDK8s app. To avoid explicitly compiling every time, you can run a watch process in the background by running: npm run watch Python main.py #!/usr/bin/env python from constructs import Construct from cdk8s import App , Chart class MyChart ( Chart ): def __init__ ( self , scope : Construct , id : str ): super () . __init__ ( scope , id ) # define resources here app = App () MyChart ( app , \"hello\" ) app . synth () To produce and inspect the generated manifest, you can run: cdk8s synth dist/hello.k8s.yaml cat dist/hello.k8s.yaml <EMPTY> Java src/main/java/com/mycompany/app/Main.java package com.mycompany.app ; import software.constructs.Construct ; import org.cdk8s.App ; import org.cdk8s.Chart ; import org.cdk8s.ChartProps ; public class Main extends Chart { public Main ( final Construct scope , final String id ) { this ( scope , id , null ); } public Main ( final Construct scope , final String id , final ChartProps options ) { super ( scope , id , options ); // define resources here } public static void main ( String [] args ) { final App app = new App (); new Main ( app , \"hello\" ); app . synth (); } } To produce and inspect the generated manifest, you can run: cdk8s synth dist/hello.k8s.yaml cat dist/hello.k8s.yaml <EMPTY> Go main.go package main import ( \"github.com/aws/constructs-go/constructs/v3\" \"github.com/aws/jsii-runtime-go\" \"github.com/cdk8s-team/cdk8s-core-go/cdk8s\" ) type MyChartProps struct { cdk8s . ChartProps } func NewMyChart ( scope constructs . Construct , id string , props * MyChartProps ) cdk8s . Chart { var cprops cdk8s . ChartProps if props != nil { cprops = props . ChartProps } chart := cdk8s . NewChart ( scope , jsii . String ( id ), & cprops ) // define resources here return chart } func main () { app := cdk8s . NewApp ( nil ) NewMyChart ( app , \"hello\" , nil ) app . Synth () } To produce and inspect the generated manifest, you can run: cdk8s synth dist/hello.k8s.yaml cat dist/hello.k8s.yaml <EMPTY>","title":"Apps &amp; Charts"},{"location":"getting-started/#importing-constructs-for-the-kubernetes-api","text":"OK, now let\u2019s define some Kubernetes API objects inside our chart. Similarly to charts and apps , Kubernetes API Objects are also represented in CDK8s as constructs . These constructs are imported to your project using the cdk8s import command which will add source files to your project that include constructs that represent the Kubernetes API. Info When cdk8s init created your project it already executed cdk8s import for you, so you should see an imports directory already there. You can either commit this directory to source-control or generate it as part of your build process. Now, let\u2019s use these constructs to define a simple Kubernetes application which contains Service and a Deployment resources inspired by paulbouwer \u2018s hello-kubernetes project. TypeScript import { Construct } from 'constructs' ; import { App , Chart , ChartProps } from 'cdk8s' ; // imported constructs import { KubeDeployment , KubeService , IntOrString } from './imports/k8s' ; export class MyChart extends Chart { constructor ( scope : Construct , id : string , props : ChartProps = { }) { super ( scope , id , props ); const label = { app : 'hello-k8s' }; // notice that there is no assigment necessary when creating resources. // simply instantiating the resource is enough because it adds it to the construct tree via // the first argument, which is always the parent construct. // its a little confusing at first glance, but this is an inherent aspect of the constructs // programming model, and you will encounter it many times. // you can still perform an assignment of course, if you need to access // atrtibutes of the resource in other parts of the code. new KubeService ( this , 'service' , { spec : { type : 'LoadBalancer' , ports : [ { port : 80 , targetPort : IntOrString.fromNumber ( 8080 ) } ], selector : label } }); new KubeDeployment ( this , 'deployment' , { spec : { replicas : 2 , selector : { matchLabels : label }, template : { metadata : { labels : label }, spec : { containers : [ { name : 'hello-kubernetes' , image : 'paulbouwer/hello-kubernetes:1.7' , ports : [ { containerPort : 8080 } ] } ] } } } }); } } const app = new App (); new MyChart ( app , 'hello' ); app . synth (); Now, to synthesize the app, run: npm run compile && cdk8s synth Python #!/usr/bin/env python from constructs import Construct from cdk8s import App , Chart from imports import k8s class MyChart ( Chart ): def __init__ ( self , scope : Construct , id : str ): super () . __init__ ( scope , id ) # define resources here label = { \"app\" : \"hello-k8s\" } # notice that there is no assigment necessary when creating resources. # simply instantiating the resource is enough because it adds it to the construct tree via # the first argument, which is always the parent construct. # its a little confusing at first glance, but this is an inherent aspect of the constructs # programming model, and you will encounter it many times. # you can still perform an assignment of course, if you need to access # atrtibutes of the resource in other parts of the code. k8s . KubeService ( self , 'service' , spec = k8s . ServiceSpec ( type = 'LoadBalancer' , ports = [ k8s . ServicePort ( port = 80 , target_port = k8s . IntOrString . from_number ( 8080 ))], selector = label )) k8s . KubeDeployment ( self , 'deployment' , spec = k8s . DeploymentSpec ( replicas = 2 , selector = k8s . LabelSelector ( match_labels = label ), template = k8s . PodTemplateSpec ( metadata = k8s . ObjectMeta ( labels = label ), spec = k8s . PodSpec ( containers = [ k8s . Container ( name = 'hello-kubernetes' , image = 'paulbouwer/hello-kubernetes:1.7' , ports = [ k8s . ContainerPort ( container_port = 8080 )])])))) app = App () MyChart ( app , \"hello\" ) app . synth () Now, to synthesize the app, run: cdk8s synth Java package com.mycompany.app ; import software.constructs.Construct ; import java.util.ArrayList ; import java.util.List ; import java.util.HashMap ; import java.util.Map ; import org.cdk8s.App ; import org.cdk8s.Chart ; import org.cdk8s.ChartProps ; import imports.k8s.IntOrString ; import imports.k8s.LabelSelector ; import imports.k8s.ObjectMeta ; import imports.k8s.PodTemplateSpec ; import imports.k8s.KubeService ; import imports.k8s.KubeServiceProps ; import imports.k8s.ServicePort ; import imports.k8s.ServiceSpec ; import imports.k8s.DeploymentSpec ; import imports.k8s.PodSpec ; import imports.k8s.Container ; import imports.k8s.ContainerPort ; import imports.k8s.KubeDeployment ; import imports.k8s.KubeDeploymentProps ; public class Main extends Chart { public Main ( final Construct scope , final String id ) { this ( scope , id , null ); } public Main ( final Construct scope , final String id , final ChartProps options ) { super ( scope , id , options ); // Defining a LoadBalancer Service final String serviceType = \"LoadBalancer\" ; final Map < String , String > selector = new HashMap <> (); selector . put ( \"app\" , \"hello-k8s\" ); final List < ServicePort > servicePorts = new ArrayList <> (); final ServicePort servicePort = new ServicePort . Builder () . port ( 80 ) . targetPort ( IntOrString . fromNumber ( 8080 )) . build (); servicePorts . add ( servicePort ); final ServiceSpec serviceSpec = new ServiceSpec . Builder () . type ( serviceType ) . selector ( selector ) . ports ( servicePorts ) . build (); final KubeServiceProps serviceProps = new KubeServiceProps . Builder () . spec ( serviceSpec ) . build (); // notice that there is no assigment neccesary when creating resources. // simply instantiating the resource is enough because it adds it to the construct tree via // the first argument, which is always the parent construct. // its a little confusing at first glance, but this is an inherent aspect of the constructs // programming model, and you will encounter it many times. // you can still perform an assignment of course, if you need to access // atrtibutes of the resource in other parts of the code. new KubeService ( this , \"service\" , serviceProps ); // Defining a Deployment final LabelSelector labelSelector = new LabelSelector . Builder (). matchLabels ( selector ). build (); final ObjectMeta objectMeta = new ObjectMeta . Builder (). labels ( selector ). build (); final List < ContainerPort > containerPorts = new ArrayList <> (); final ContainerPort containerPort = new ContainerPort . Builder () . containerPort ( 8080 ) . build (); containerPorts . add ( containerPort ); final List < Container > containers = new ArrayList <> (); final Container container = new Container . Builder () . name ( \"hello-kubernetes\" ) . image ( \"paulbouwer/hello-kubernetes:1.7\" ) . ports ( containerPorts ) . build (); containers . add ( container ); final PodSpec podSpec = new PodSpec . Builder () . containers ( containers ) . build (); final PodTemplateSpec podTemplateSpec = new PodTemplateSpec . Builder () . metadata ( objectMeta ) . spec ( podSpec ) . build (); final DeploymentSpec deploymentSpec = new DeploymentSpec . Builder () . replicas ( 1 ) . selector ( labelSelector ) . template ( podTemplateSpec ) . build (); final KubeDeploymentProps deploymentProps = new KubeDeploymentProps . Builder () . spec ( deploymentSpec ) . build (); new KubeDeployment ( this , \"deployment\" , deploymentProps ); } public static void main ( String [] args ) { final App app = new App (); new Main ( app , \"hello\" ); app . synth (); } } Now, to synthesize the app, run: cdk8s synth Go package main import ( \"example.com/hello-k8s/imports/k8s\" \"github.com/aws/constructs-go/constructs/v3\" \"github.com/aws/jsii-runtime-go\" \"github.com/cdk8s-team/cdk8s-core-go/cdk8s\" ) type MyChartProps struct { cdk8s . ChartProps } func NewMyChart ( scope constructs . Construct , id string , props * MyChartProps ) cdk8s . Chart { var cprops cdk8s . ChartProps if props != nil { cprops = props . ChartProps } chart := cdk8s . NewChart ( scope , jsii . String ( id ), & cprops ) label := map [ string ] * string { \"app\" : jsii . String ( \"hello-k8s\" )} k8s . NewKubeService ( chart , jsii . String ( \"service\" ), & k8s . KubeServiceProps { Spec : & k8s . ServiceSpec { Type : jsii . String ( \"LoadBalancer\" ), Ports : & [] * k8s . ServicePort {{ Port : jsii . Number ( 80 ), TargetPort : k8s . IntOrString_FromNumber ( jsii . Number ( 8000 )), }}, Selector : & label , }, }) // notice that there is no assigment neccesary when creating resources. // simply instantiating the resource is enough because it adds it to the construct tree via // the first argument, which is always the parent construct. // its a little confusing at first glance, but this is an inherent aspect of the constructs // programming model, and you will encounter it many times. // you can still perform an assignment of course, if you need to access // atrtibutes of the resource in other parts of the code. k8s . NewKubeDeployment ( chart , jsii . String ( \"deployment\" ), & k8s . KubeDeploymentProps { Spec : & k8s . DeploymentSpec { Replicas : jsii . Number ( 2 ), Selector : & k8s . LabelSelector { MatchLabels : & label , }, Template : & k8s . PodTemplateSpec { Metadata : & k8s . ObjectMeta { Labels : & label , }, Spec : & k8s . PodSpec { Containers : & [] * k8s . Container {{ Name : jsii . String ( \"hello-kubernetes\" ), Image : jsii . String ( \"paulbouwer/hello-kubernetes:1.7\" ), Ports : & [] * k8s . ContainerPort {{ ContainerPort : jsii . Number ( 8080 )}}, }}, }, }, }, }) return chart } func main () { app := cdk8s . NewApp ( nil ) NewMyChart ( app , \"hello\" , nil ) app . Synth () } Now, to synthesize the app, run: cdk8s synth This will be contents of hello.k8s.yaml : apiVersion : \"v1\" kind : \"Service\" metadata : name : \"hello-service-c8c17160\" spec : ports : - port : 80 targetPort : 8080 selector : app : \"hello-k8s\" type : \"LoadBalancer\" --- apiVersion : \"apps/v1\" kind : \"Deployment\" metadata : name : \"hello-deployment-c8c7fda7\" spec : replicas : 2 selector : matchLabels : app : \"hello-k8s\" template : metadata : labels : app : \"hello-k8s\" spec : containers : - image : \"paulbouwer/hello-kubernetes:1.7\" name : \"hello-kubernetes\" ports : - containerPort : 8080 The manifest synthesized by your app is ready to be applied to any Kubernetes cluster using standard tools like kubectl apply : kubectl apply -f dist/hello.k8s.yaml","title":"Importing Constructs for the Kubernetes API"},{"location":"getting-started/#abstraction-through-constructs","text":"Constructs are the basic building block of CDK8s . They are the instrument that enables composition and creation of higher-level abstractions through normal object-oriented classes. If you come from the Kubernetes world, you can think of constructs as programmatically defined Helm Charts. The nice thing about constructs being \u201cprogrammatically defined\u201d is that we can use them to leverage the full power of object-oriented programming. For example: You can express the abstraction\u2019s API using strong-typed data types You can express rich interactions with methods and properties You can create polymorphic programming models through interfaces and base classes Share them through regular package managers Test them using our familiar testing tools and techniques Version them \u2026and do all that stuff that we\u2019ve been doing with software in the past 20 years. So let\u2019s create our first Kubernetes construct. We\u2019ll call it WebService and it will basically be a generalization of the hello world program. It\u2019s actually quite useful. For example, this one line will add a hello world service to our chart: TypeScript new WebService ( this , 'hello-k8s' , { image : 'paulbouwer/hello-kubernetes:1.7' }); It can also be customized through an API: new WebService ( this , 'hello-k8s' , { image : 'paulbouwer/hello-kubernetes:1.7' , containerPort : 8080 , replicas : 10 }); Python WebService ( self , 'hello' , image = 'paulbouwer/hello-kubernetes:1.7' ) It can also be customized through an API: WebService ( self , 'hello-k8s' , image = 'paulbouwer/hello-kubernetes:1.7' , container_port = 8080 , replicas = 10 ) Java new WebService ( this , \"hello-k8s\" , new WebServiceProps . Builder () . image ( \"paulbouwer/hello-kubernetes:1.7\" ) . build ()); It can also be customized through an API: new WebService ( this , \"hello-k8s\" , new WebServiceProps . Builder () . image ( \"paulbouwer/hello-kubernetes:1.7\" ) . replicas ( 2 ) . build ()); Go NewWebService ( chart , jsii . String ( \"hello\" ), & WebServiceProps { Image : jsii . String ( \"paulbouwer/hello-kubernetes:1.7\" ), }) It can also be customized through an API: NewWebService ( chart , jsii . String ( \"hello\" ), & WebServiceProps { Image : jsii . String ( \"paulbouwer/hello-kubernetes:1.7\" ), ContainerPort : jsii . Number ( 8080 ), Replicas : jsii . Number ( 10 ), }) Here\u2019s how to implement WebService : TypeScript Create a file lib/web-service.ts (the convention is to use lib for reusable components): import { Construct } from 'constructs' ; import { Names } from 'cdk8s' ; import { KubeDeployment , KubeService , IntOrString } from '../imports/k8s' ; export interface WebServiceProps { /** * The Docker image to use for this service. */ readonly image : string ; /** * Number of replicas. * * @default 1 */ readonly replicas? : number ; /** * External port. * * @default 80 */ readonly port? : number ; /** * Internal port. * * @default 8080 */ readonly containerPort? : number ; } export class WebService extends Construct { constructor ( scope : Construct , id : string , props : WebServiceProps ) { super ( scope , id ); const port = props . port || 80 ; const containerPort = props . containerPort || 8080 ; const label = { app : Names.toDnsLabel ( this ) }; const replicas = props . replicas ?? 1 ; new KubeService ( this , 'service' , { spec : { type : 'LoadBalancer' , ports : [ { port , targetPort : IntOrString.fromNumber ( containerPort ) } ], selector : label } }); new KubeDeployment ( this , 'deployment' , { spec : { replicas , selector : { matchLabels : label }, template : { metadata : { labels : label }, spec : { containers : [ { name : 'app' , image : props.image , ports : [ { containerPort } ] } ] } } } }); } } Now, let\u2019s edit main.ts and use our new construct: import { Construct } from 'constructs' ; import { App , Chart , ChartProps } from 'cdk8s' ; import { WebService } from './lib/web-service' ; export class MyChart extends Chart { constructor ( scope : Construct , id : string , props : ChartProps = { }) { super ( scope , id , props ); new WebService ( this , 'hello' , { image : 'paulbouwer/hello-kubernetes:1.7' , replicas : 2 }); new WebService ( this , 'ghost' , { image : 'ghost' , containerPort : 2368 }); } } const app = new App (); new MyChart ( app , 'hello' ); app . synth (); Python Create a file webservice.py with the following content: from constructs import Construct , Node from imports import k8s class WebService ( Construct ): def __init__ ( self , scope : Construct , id : str , * , image : str , replicas : int = 1 , port : int = 80 , container_port : int = 8080 ): super () . __init__ ( scope , id ) label = { 'app' : Node . of ( self ) . unique_id } k8s . KubeService ( self , 'service' , spec = k8s . ServiceSpec ( type = 'LoadBalancer' , ports = [ k8s . ServicePort ( port = port , target_port = k8s . IntOrString . from_number ( container_port ))], selector = label )) k8s . KubeDeployment ( self , 'deployment' , spec = k8s . DeploymentSpec ( replicas = replicas , selector = k8s . LabelSelector ( match_labels = label ), template = k8s . PodTemplateSpec ( metadata = k8s . ObjectMeta ( labels = label ), spec = k8s . PodSpec ( containers = [ k8s . Container ( name = 'app' , image = image , ports = [ k8s . ContainerPort ( container_port = container_port )])])))) Now, let\u2019s edit main.py and use our new construct: #!/usr/bin/env python from constructs import Construct from cdk8s import App , Chart from webservice import WebService class MyChart ( Chart ): def __init__ ( self , scope : Construct , id : str ): super () . __init__ ( scope , id ) WebService ( self , 'hello' , image = 'paulbouwer/hello-kubernetes:1.7' , replicas = 2 ) WebService ( self , 'ghost' , image = 'ghost' , container_port = 2368 ) app = App () MyChart ( app , \"hello\" ) app . synth () Java src/main/java/com/mycompany/app/WebService.java package com.mycompany.app ; import software.constructs.Construct ; import java.util.ArrayList ; import java.util.List ; import java.util.HashMap ; import java.util.Map ; import java.util.Optional ; import imports.k8s.IntOrString ; import imports.k8s.LabelSelector ; import imports.k8s.ObjectMeta ; import imports.k8s.PodTemplateSpec ; import imports.k8s.KubeService ; import imports.k8s.KubeServiceProps ; import imports.k8s.ServicePort ; import imports.k8s.ServiceSpec ; import imports.k8s.DeploymentSpec ; import imports.k8s.PodSpec ; import imports.k8s.Container ; import imports.k8s.ContainerPort ; import imports.k8s.KubeDeployment ; import imports.k8s.KubeDeploymentProps ; public class WebService extends Construct { public WebService ( final Construct scope , final String id ) { this ( scope , id , null ); } public WebService ( final Construct scope , final String id , final WebServiceProps options ) { super ( scope , id ); final int portNumber = Optional . of ( options . getPort ()). orElse ( 80 ); final int containerPortNumber = Optional . of ( options . getContainerPort ()). orElse ( 8080 ); final int replicas = Optional . of ( options . getReplicas ()). orElse ( 1 ); final String image = options . getImage (); // Defining a LoadBalancer Service final String serviceType = \"LoadBalancer\" ; final Map < String , String > selector = new HashMap <> (); selector . put ( \"app\" , \"hello-k8s\" ); final List < ServicePort > servicePorts = new ArrayList <> (); final ServicePort servicePort = new ServicePort . Builder () . port ( portNumber ) . targetPort ( IntOrString . fromNumber ( containerPortNumber )) . build (); servicePorts . add ( servicePort ); final ServiceSpec serviceSpec = new ServiceSpec . Builder () . type ( serviceType ) . selector ( selector ) . ports ( servicePorts ) . build (); final KubeServiceProps serviceProps = new KubeServiceProps . Builder () . spec ( serviceSpec ) . build (); new KubeService ( this , \"service\" , serviceProps ); // Defining a Deployment final LabelSelector labelSelector = new LabelSelector . Builder (). matchLabels ( selector ). build (); final ObjectMeta objectMeta = new ObjectMeta . Builder (). labels ( selector ). build (); final List < ContainerPort > containerPorts = new ArrayList <> (); final ContainerPort containerPort = new ContainerPort . Builder () . containerPort ( containerPortNumber ) . build (); containerPorts . add ( containerPort ); final List < Container > containers = new ArrayList <> (); final Container container = new Container . Builder () . name ( \"web\" ) . image ( image ) . ports ( containerPorts ) . build (); containers . add ( container ); final PodSpec podSpec = new PodSpec . Builder () . containers ( containers ) . build (); final PodTemplateSpec podTemplateSpec = new PodTemplateSpec . Builder () . metadata ( objectMeta ) . spec ( podSpec ) . build (); final DeploymentSpec deploymentSpec = new DeploymentSpec . Builder () . replicas ( replicas ) . selector ( labelSelector ) . template ( podTemplateSpec ) . build (); final KubeDeploymentProps deploymentProps = new KubeDeploymentProps . Builder () . spec ( deploymentSpec ) . build (); new KubeDeployment ( this , \"deployment\" , deploymentProps ); } } src/main/java/com/mycompany/app/WebServiceProps.java package com.mycompany.app ; public class WebServiceProps { private String image ; private int replicas ; private int port ; private int containerPort ; public WebServiceProps ( final String image , final int replicas , final int port , final int containerPort ) { this . image = image ; this . replicas = replicas ; this . port = port ; this . containerPort = containerPort ; } public String getImage () { return this . image ; } public int getReplicas () { return this . replicas ; } public int getPort () { return this . port ; } public int getContainerPort () { return this . containerPort ; } public static final class Builder { private String image ; private int replicas = 1 ; private int port = 80 ; private int containerPort = 8080 ; public Builder image ( String image ) { this . image = image ; return this ; } public Builder replicas ( int replicas ) { this . replicas = replicas ; return this ; } public Builder port ( int port ) { this . port = port ; return this ; } public Builder containerPort ( int containerPort ) { this . containerPort = containerPort ; return this ; } public WebServiceProps build () { return new WebServiceProps ( image , replicas , port , containerPort ); } } } src/main/java/com/mycompany/app/Main.java package com.mycompany.app ; import software.constructs.Construct ; import org.cdk8s.App ; import org.cdk8s.Chart ; import org.cdk8s.ChartProps ; public class Main extends Chart { public Main ( final Construct scope , final String id ) { this ( scope , id , null ); } public Main ( final Construct scope , final String id , final ChartProps options ) { super ( scope , id , options ); new WebService ( this , \"hello\" , new WebServiceProps . Builder () . image ( \"paulbouwer/hello-kubernetes:1.7\" ) . replicas ( 2 ) . build ()); new WebService ( this , \"ghost\" , new WebServiceProps . Builder () . image ( \"ghost\" ) . containerPort ( 2368 ) . build ()); } public static void main ( String [] args ) { final App app = new App (); new Main ( app , \"web-service-java\" ); app . synth (); } } Go Create a file webservice.go with the following content: package main import ( \"example.com/hello/imports/k8s\" \"github.com/aws/constructs-go/constructs/v3\" \"github.com/aws/jsii-runtime-go\" ) type WebServiceProps struct { constructs . ConstructOptions Image * string Replicas * float64 Port * float64 ContainerPort * float64 } func NewWebService ( scope constructs . Construct , id * string , props * WebServiceProps ) constructs . Construct { var cprops constructs . ConstructOptions if props != nil { cprops = props . ConstructOptions } construct := constructs . NewConstruct ( scope , id , & cprops ) replicas := props . Replicas if replicas == nil { replicas = jsii . Number ( 1 ) } port := props . Port if port == nil { port = jsii . Number ( 80 ) } containerPort := props . ContainerPort if containerPort == nil { containerPort = jsii . Number ( 8080 ) } label := map [ string ] * string { \"app\" : constructs . Node_Of ( construct ). Id (), } k8s . NewKubeService ( construct , jsii . String ( \"service\" ), & k8s . KubeServiceProps { Spec : & k8s . ServiceSpec { Type : jsii . String ( \"LoadBalancer\" ), Ports : & [] * k8s . ServicePort {{ Port : port , TargetPort : k8s . IntOrString_FromNumber ( containerPort ), }}, Selector : & label , }, }) k8s . NewKubeDeployment ( construct , jsii . String ( \"deployment\" ), & k8s . KubeDeploymentProps { Spec : & k8s . DeploymentSpec { Replicas : replicas , Selector : & k8s . LabelSelector { MatchLabels : & label }, Template : & k8s . PodTemplateSpec { Metadata : & k8s . ObjectMeta { Labels : & label }, Spec : & k8s . PodSpec { Containers : & [] * k8s . Container {{ Name : jsii . String ( \"web\" ), Image : props . Image , Ports : & [] * k8s . ContainerPort {{ ContainerPort : containerPort }}, }}, }, }, }, }) return construct } Now, let\u2019s edit main.go and use our new construct: package main import ( \"github.com/aws/constructs-go/constructs/v3\" \"github.com/aws/jsii-runtime-go\" \"github.com/cdk8s-team/cdk8s-core-go/cdk8s\" ) type MyChartProps struct { cdk8s . ChartProps } func NewMyChart ( scope constructs . Construct , id string , props * MyChartProps ) cdk8s . Chart { var cprops cdk8s . ChartProps if props != nil { cprops = props . ChartProps } chart := cdk8s . NewChart ( scope , jsii . String ( id ), & cprops ) NewWebService ( chart , jsii . String ( \"hello\" ), & WebServiceProps { Image : jsii . String ( \"paulbouwer/hello-kubernetes:1.7\" ), Replicas : jsii . Number ( 2 ), }) NewWebService ( chart , jsii . String ( \"ghost\" ), & WebServiceProps { Image : jsii . String ( \"ghost\" ), ContainerPort : jsii . Number ( 2368 ), }) return chart } func main () { app := cdk8s . NewApp ( nil ) NewMyChart ( app , \"hello\" , nil ) app . Synth () } As you can see, we now add WebService constructs inside our chart: one that runs the paulbouwer/hello-kubernetes image and one with an installation of ghost .","title":"Abstraction through Constructs"},{"location":"support/","text":"Support \u00b6 Interacting with the community and the development team is a great way to contribute to the project. Please consider the following venues (in order): Search open issues Stack Overflow: cdk8s File a new issue Mailing list: cdk8s Slack: #cdk8s channel in cdk.dev","title":"Support"},{"location":"support/#support","text":"Interacting with the community and the development team is a great way to contribute to the project. Please consider the following venues (in order): Search open issues Stack Overflow: cdk8s File a new issue Mailing list: cdk8s Slack: #cdk8s channel in cdk.dev","title":"Support"},{"location":"assets/logos/readme/","text":"CDK8s Logos \u00b6 PNG SVG horizontal stacked icon horizontal stacked icon color black white","title":"CDK8s Logos"},{"location":"assets/logos/readme/#cdk8s-logos","text":"PNG SVG horizontal stacked icon horizontal stacked icon color black white","title":"CDK8s Logos"},{"location":"cli/","text":"Overview \u00b6 CDK8s is shipped with a command-line interface called cdk8s which can be used to work with CDK8s apps. The CLI is not required to use CDK8s but it includes some useful utilities.","title":"Overview"},{"location":"cli/#overview","text":"CDK8s is shipped with a command-line interface called cdk8s which can be used to work with CDK8s apps. The CLI is not required to use CDK8s but it includes some useful utilities.","title":"Overview"},{"location":"cli/import/","text":"import \u00b6 The import command generates low-level (L1) constructs for Kubernetes API objects and Custom Resources (CRDs). General Options \u00b6 Target programming language ( --language ) \u00b6 You can specify your desired language with the --language flag. For example: CLI: cdk8s import --language typescript cdk8s.yaml : language : typescript Output directory ( --output ) \u00b6 The --output (or -o ) option can be used to specify the output directory for your imports. Class name prefix ( --class-prefix ) \u00b6 For k8s imports, all imported classes will have a Kube prefix to denote that those are core Kubernetes APIs. For CRD imports, the class name will match the resource kind. You can use the --class-prefix option to specify an alternative prefix or --no-class-prefix to disable this behavior for k8s imports. Module name \u00b6 You can also override the default behavior for cdk8s importing. This will be helpful to you if you would like to name your CRD imports differently from their kind. Here is how you do it: CLI: cdk8s import example: = my_crd.yaml cdk8s.yaml : imports : - example:=my_crd.yaml If your CRD contained two kinds, Cluster and Autoscaler , you would have two imports. You could use them in this fashion: Typescript import { Cluster } from './imports/example-cluster' ; import { Autoscaler } from './imports/example-autoscaler' ; Python not yet supported Import Types \u00b6 The import command supports two types of imports: k8s : generates constructs from the core Kubernetes API CRDs: generates constructs from custom resource definitions This section describes specific behavior related to each type of import. Kubernetes APIs \u00b6 To generate constructs for all Kubernetes API objects of a certain version, use: cdk8s import k8s The import command will generate files under an \u201cimports\u201d directory inside your project with constructs for each API object in the Kubernetes spec. Note It is recommended to commit these generated files into your source control. By default, generated class names will be named KubeXyz where Xyz is the API object kind (e.g. KubeDeployment ). Kubernetes Versions \u00b6 Use the @version notation to import a specific Kubernetes version: cdk8s import k8s@1.16.0 Alternatively, you can specify your k8s import in the cdk8s.yaml config file: imports : - k8s@1.17.0 API Object Versions \u00b6 When importing the core Kubernetes API objects, cdk8s import will generate constructs both for stable APIs (e.g. v1 ) and pre-stable APIs ( v1beta1 ). To ensure compatibility across Kubernetes versions, construct classes generated for non-stable resources will include a postfix with the API level. For example, the import for k8s@1.18 includes KubeIngressV1Beta1 as the only Ingress resource. This is because Ingress has not been stabilized yet. The import for k8s@1.19 will also include an Ingress construct which represents the v1 resource. CRDs \u00b6 You can import CRDs from local files or URLs: cdk8s import my_crd.yaml Or from cdk8s.yaml : imports : - my_crd.yaml A CRD with group mygroup.io and kind Foo will be imported to the following locations: TypeScript: imports/mygroup.io.ts Python: imports/mygroup/io Importing CRDs from a cluster \u00b6 If the imported YAML is a List of CRDs, all these CRDs will be imported. This is useful, for example, to import all the CRDs from a running cluster: kubectl get crds -o json | cdk8s import /dev/stdin Yes, this works!","title":"import"},{"location":"cli/import/#import","text":"The import command generates low-level (L1) constructs for Kubernetes API objects and Custom Resources (CRDs).","title":"import"},{"location":"cli/import/#general-options","text":"","title":"General Options"},{"location":"cli/import/#target-programming-language-language","text":"You can specify your desired language with the --language flag. For example: CLI: cdk8s import --language typescript cdk8s.yaml : language : typescript","title":"Target programming language (--language)"},{"location":"cli/import/#output-directory-output","text":"The --output (or -o ) option can be used to specify the output directory for your imports.","title":"Output directory (--output)"},{"location":"cli/import/#class-name-prefix-class-prefix","text":"For k8s imports, all imported classes will have a Kube prefix to denote that those are core Kubernetes APIs. For CRD imports, the class name will match the resource kind. You can use the --class-prefix option to specify an alternative prefix or --no-class-prefix to disable this behavior for k8s imports.","title":"Class name prefix (--class-prefix)"},{"location":"cli/import/#module-name","text":"You can also override the default behavior for cdk8s importing. This will be helpful to you if you would like to name your CRD imports differently from their kind. Here is how you do it: CLI: cdk8s import example: = my_crd.yaml cdk8s.yaml : imports : - example:=my_crd.yaml If your CRD contained two kinds, Cluster and Autoscaler , you would have two imports. You could use them in this fashion: Typescript import { Cluster } from './imports/example-cluster' ; import { Autoscaler } from './imports/example-autoscaler' ; Python not yet supported","title":"Module name"},{"location":"cli/import/#import-types","text":"The import command supports two types of imports: k8s : generates constructs from the core Kubernetes API CRDs: generates constructs from custom resource definitions This section describes specific behavior related to each type of import.","title":"Import Types"},{"location":"cli/import/#kubernetes-apis","text":"To generate constructs for all Kubernetes API objects of a certain version, use: cdk8s import k8s The import command will generate files under an \u201cimports\u201d directory inside your project with constructs for each API object in the Kubernetes spec. Note It is recommended to commit these generated files into your source control. By default, generated class names will be named KubeXyz where Xyz is the API object kind (e.g. KubeDeployment ).","title":"Kubernetes APIs"},{"location":"cli/import/#crds","text":"You can import CRDs from local files or URLs: cdk8s import my_crd.yaml Or from cdk8s.yaml : imports : - my_crd.yaml A CRD with group mygroup.io and kind Foo will be imported to the following locations: TypeScript: imports/mygroup.io.ts Python: imports/mygroup/io","title":"CRDs"},{"location":"cli/init/","text":"init \u00b6 This command creates new cdk8s projects from built-in templates: cdk8s init TEMPLATE The following example will create a new TypeScript app project: mkdir my-fun-little-project cd my-fun-little-project cdk8s init typescript-app","title":"init"},{"location":"cli/init/#init","text":"This command creates new cdk8s projects from built-in templates: cdk8s init TEMPLATE The following example will create a new TypeScript app project: mkdir my-fun-little-project cd my-fun-little-project cdk8s init typescript-app","title":"init"},{"location":"cli/installation/","text":"Installation \u00b6 To install the CLI use one of the following methods: npm npm i -g cdk8s-cli yarn yarn global add cdk8s-cli Homebrew brew install cdk8s Note: the latest version of the cdk8s cli available via Homebrew is 0.33.0 because Homebrew does not accept beta versions. Once a stable 1.0.0 version is released it will be available on Homebrew as well. In the meantime, please use npm or yarn to install the latest cli.","title":"Installation"},{"location":"cli/installation/#installation","text":"To install the CLI use one of the following methods: npm npm i -g cdk8s-cli yarn yarn global add cdk8s-cli Homebrew brew install cdk8s Note: the latest version of the cdk8s cli available via Homebrew is 0.33.0 because Homebrew does not accept beta versions. Once a stable 1.0.0 version is released it will be available on Homebrew as well. In the meantime, please use npm or yarn to install the latest cli.","title":"Installation"},{"location":"cli/synth/","text":"synth \u00b6 The cdk8s synth command is a convenience command which will simply execute the application defined in cdk8s.yaml under app . For example, if your cdk8s.yaml file looks like this: app : node app.js Then, cdk8s synth will execute node app.js .","title":"synth"},{"location":"cli/synth/#synth","text":"The cdk8s synth command is a convenience command which will simply execute the application defined in cdk8s.yaml under app . For example, if your cdk8s.yaml file looks like this: app : node app.js Then, cdk8s synth will execute node app.js .","title":"synth"},{"location":"concepts/","text":"Overview \u00b6 This section discusses core concepts in CDK8s.","title":"Overview"},{"location":"concepts/#overview","text":"This section discusses core concepts in CDK8s.","title":"Overview"},{"location":"concepts/api-object/","text":"ApiObject \u00b6 An ApiObject is a construct that represents an entry in a Kubernetes manifest (level 0). In most cases, you won\u2019t use ApiObject directly but rather use classes that are imported through cdk8s import and which extend this base class. By default, when you import API objects from k8s, all class names will all be prefixed with Kube to differentiate them from the high-level APIs in CDK8s+. It is possible to customize the prefix by providing a string value to the --class-prefix flag, or by passing --no-class-prefix . (Note: if no prefix is used for k8s resources, this may lead to conflicts - see https://github.com/cdk8s-team/cdk8s/issues/140).","title":"ApiObject"},{"location":"concepts/api-object/#apiobject","text":"An ApiObject is a construct that represents an entry in a Kubernetes manifest (level 0). In most cases, you won\u2019t use ApiObject directly but rather use classes that are imported through cdk8s import and which extend this base class. By default, when you import API objects from k8s, all class names will all be prefixed with Kube to differentiate them from the high-level APIs in CDK8s+. It is possible to customize the prefix by providing a string value to the --class-prefix flag, or by passing --no-class-prefix . (Note: if no prefix is used for k8s resources, this may lead to conflicts - see https://github.com/cdk8s-team/cdk8s/issues/140).","title":"ApiObject"},{"location":"concepts/chart/","text":"Chart \u00b6 The Chart is a container that synthesizes a single Kubernetes manifest. class MyChart extends Chart { constructor ( scope : Construct , ns : string ) { super ( scope , ns ); // add contents here } } During synthesis, charts collect all the ApiObject nodes (recursively) and emit a single YAML manifest that includes all these objects. When a chart is defined, you can specify chart-level namespace and labels . Those will be applied to all API objects defined within the chart (recursively): class MyChart extends Chart { constructor ( scope : Construct , ns : string ) { super ( scope , ns , { namespace : 'my-namespace' , labels : { app : 'my-app' , }, }); new ApiObject ( this , 'my-object' , { apiVersion : 'v1' , kind : 'Foo' }); } } Will synthesize into: apiVersion : v1 kind : Foo metadata : namespace : my-namespace labels : app : my-app","title":"Chart"},{"location":"concepts/chart/#chart","text":"The Chart is a container that synthesizes a single Kubernetes manifest. class MyChart extends Chart { constructor ( scope : Construct , ns : string ) { super ( scope , ns ); // add contents here } } During synthesis, charts collect all the ApiObject nodes (recursively) and emit a single YAML manifest that includes all these objects. When a chart is defined, you can specify chart-level namespace and labels . Those will be applied to all API objects defined within the chart (recursively): class MyChart extends Chart { constructor ( scope : Construct , ns : string ) { super ( scope , ns , { namespace : 'my-namespace' , labels : { app : 'my-app' , }, }); new ApiObject ( this , 'my-object' , { apiVersion : 'v1' , kind : 'Foo' }); } } Will synthesize into: apiVersion : v1 kind : Foo metadata : namespace : my-namespace labels : app : my-app","title":"Chart"},{"location":"concepts/constructs/","text":"Constructs \u00b6 Constructs are the basic building block of CDK8s . They are the instrument that enables composition and creation of higher-level abstractions through normal object-oriented classes. If you come from the Kubernetes world, you can think of constructs as programmatically defined Helm Charts. The nice thing about constructs being \u201cprogrammatically defined\u201d is that we can use them to leverage the full power of object-oriented programming. For example: You can express the abstraction\u2019s API using strong-typed data types You can express rich interactions with methods and properties You can create polymorphic programming models through interfaces and base classes Share them through regular package managers Test them using our familiar testing tools and techniques Version them \u2026and do all that stuff that we\u2019ve been doing with software in the past 20 years.","title":"Constructs"},{"location":"concepts/constructs/#constructs","text":"Constructs are the basic building block of CDK8s . They are the instrument that enables composition and creation of higher-level abstractions through normal object-oriented classes. If you come from the Kubernetes world, you can think of constructs as programmatically defined Helm Charts. The nice thing about constructs being \u201cprogrammatically defined\u201d is that we can use them to leverage the full power of object-oriented programming. For example: You can express the abstraction\u2019s API using strong-typed data types You can express rich interactions with methods and properties You can create polymorphic programming models through interfaces and base classes Share them through regular package managers Test them using our familiar testing tools and techniques Version them \u2026and do all that stuff that we\u2019ve been doing with software in the past 20 years.","title":"Constructs"},{"location":"concepts/deps/","text":"Dependencies \u00b6 You can declare dependencies between any two cdk8s constructs using the addDependency() method. ApiObjects \u00b6 For example, you can force kubernetes to first apply a Namespace before applying the Service in the scope of that namespace: const namespace = new k8s . KubeNamespace ( chart , 'backend' ); const service = new k8s . KubeService ( chart , 'Service' , { metadata : { namespace : namespace.name }}); // declare the dependency. this is just a syntactic sugar for Node.of(service).addDependency(namespace) service . addDependency ( namespace ); cdk8s will ensure that the Namespace object is placed before the Service object in the resulting manifest: apiVersion : v1 kind : Namespace metadata : name : chart-backend-a59d2e47 --- apiVersion : v1 kind : Service metadata : name : chart-service-93d02be7 namespace : chart-backend-a59d2e47 Charts \u00b6 You can also specify dependencies between charts, in exactly the same manner. For example, if we have a chart that provisions our namespace , we need that chart to be applied first: const namespaceChart = new Chart ( app , 'namespace' ); const applicationChart = new Chart ( app , 'application' ); // declare the dependency. this is just a syntactic sugar for Node.of(applicationChart).addDependency(namespaceChart) applicationChart . addDependency ( namespaceChart ); Running cdk8s synth will produce the following dist directory: > cdk8s synth dist/0000-namespace.k8s.yaml dist/0001-application.k8s.yaml Notice that the namespace chart appears first with the 0000 prefix. This will ensure that a subsequent execution of kubectl apply -f dist/ will apply the namespace first, and the application second. Custom Constructs \u00b6 The behavior above applies in the same way to custom constructs that you create or use. class Database extends Construct { constructor ( scope : Construct , name : string ) { super ( scope , name ); new k8s . KubeStatefulSet ( this , 'StatefulSet' ); new k8s . KubeConfigMap ( this , 'ConfigMap' ); } } const app = new App (); const chart = new Chart ( app , 'Chart' ); const service = new k8s . KubeService ( chart , 'Service' ) const database = new Database ( chart , 'Database' ); service . addDependency ( database ); Declaring such a dependency will cause each ApiObject in the source construct, to depend on every ApiObject in the target construct. Note that in the example above, the source construct is actually an ApiObject , which is also ok since it is essentially a construct with a single ApiObject . Note that if the source of your dependency is a custom construct, it won\u2019t have the addDependency syntactic sugar by default, so you\u2019ll have to use Node.of() . The resulting manifest will be: apiVersion : apps/v1 kind : StatefulSet metadata : name : chart-database-statefulset-4627f8e2 --- apiVersion : v1 kind : ConfigMap metadata : name : chart-database-configmap-676f8640 --- apiVersion : v1 kind : Service metadata : name : chart-service-93d02be7 You can see that all ApiObject s of the Database construct, appear before the Service object. Things just got cool \u00b6 If you simply declare a dependency between two ApiObject s (or Constructs ), that belong to two different Chart s, cdk8s will create the chart dependency automatically for you. const namespaceChart = new Chart ( app , 'namespace' ); const applicationChart = new Chart ( app , 'application' ); const namespace = new k8s . KubeNamespace ( namespaceChart , 'namespace' ); const deployment = new k8s . KubeDeployment ( applicationChart , 'Deployment' ); // dependency between ApiObjects, not Charts! deployment . addDependency ( namespace ); Running cdk8s synth will produce the same result as if explicit chart dependencies were declared: > cdk8s synth dist/0000-namespace.k8s.yaml dist/0001-application.k8s.yaml This means you need not be bothered with managing chart dependencies, simply work with the ApiObject s you create, and let cdk8s infer the chart dependencies.","title":"Dependencies"},{"location":"concepts/deps/#dependencies","text":"You can declare dependencies between any two cdk8s constructs using the addDependency() method.","title":"Dependencies"},{"location":"concepts/deps/#apiobjects","text":"For example, you can force kubernetes to first apply a Namespace before applying the Service in the scope of that namespace: const namespace = new k8s . KubeNamespace ( chart , 'backend' ); const service = new k8s . KubeService ( chart , 'Service' , { metadata : { namespace : namespace.name }}); // declare the dependency. this is just a syntactic sugar for Node.of(service).addDependency(namespace) service . addDependency ( namespace ); cdk8s will ensure that the Namespace object is placed before the Service object in the resulting manifest: apiVersion : v1 kind : Namespace metadata : name : chart-backend-a59d2e47 --- apiVersion : v1 kind : Service metadata : name : chart-service-93d02be7 namespace : chart-backend-a59d2e47","title":"ApiObjects"},{"location":"concepts/deps/#charts","text":"You can also specify dependencies between charts, in exactly the same manner. For example, if we have a chart that provisions our namespace , we need that chart to be applied first: const namespaceChart = new Chart ( app , 'namespace' ); const applicationChart = new Chart ( app , 'application' ); // declare the dependency. this is just a syntactic sugar for Node.of(applicationChart).addDependency(namespaceChart) applicationChart . addDependency ( namespaceChart ); Running cdk8s synth will produce the following dist directory: > cdk8s synth dist/0000-namespace.k8s.yaml dist/0001-application.k8s.yaml Notice that the namespace chart appears first with the 0000 prefix. This will ensure that a subsequent execution of kubectl apply -f dist/ will apply the namespace first, and the application second.","title":"Charts"},{"location":"concepts/deps/#custom-constructs","text":"The behavior above applies in the same way to custom constructs that you create or use. class Database extends Construct { constructor ( scope : Construct , name : string ) { super ( scope , name ); new k8s . KubeStatefulSet ( this , 'StatefulSet' ); new k8s . KubeConfigMap ( this , 'ConfigMap' ); } } const app = new App (); const chart = new Chart ( app , 'Chart' ); const service = new k8s . KubeService ( chart , 'Service' ) const database = new Database ( chart , 'Database' ); service . addDependency ( database ); Declaring such a dependency will cause each ApiObject in the source construct, to depend on every ApiObject in the target construct. Note that in the example above, the source construct is actually an ApiObject , which is also ok since it is essentially a construct with a single ApiObject . Note that if the source of your dependency is a custom construct, it won\u2019t have the addDependency syntactic sugar by default, so you\u2019ll have to use Node.of() . The resulting manifest will be: apiVersion : apps/v1 kind : StatefulSet metadata : name : chart-database-statefulset-4627f8e2 --- apiVersion : v1 kind : ConfigMap metadata : name : chart-database-configmap-676f8640 --- apiVersion : v1 kind : Service metadata : name : chart-service-93d02be7 You can see that all ApiObject s of the Database construct, appear before the Service object.","title":"Custom Constructs"},{"location":"concepts/deps/#things-just-got-cool","text":"If you simply declare a dependency between two ApiObject s (or Constructs ), that belong to two different Chart s, cdk8s will create the chart dependency automatically for you. const namespaceChart = new Chart ( app , 'namespace' ); const applicationChart = new Chart ( app , 'application' ); const namespace = new k8s . KubeNamespace ( namespaceChart , 'namespace' ); const deployment = new k8s . KubeDeployment ( applicationChart , 'Deployment' ); // dependency between ApiObjects, not Charts! deployment . addDependency ( namespace ); Running cdk8s synth will produce the same result as if explicit chart dependencies were declared: > cdk8s synth dist/0000-namespace.k8s.yaml dist/0001-application.k8s.yaml This means you need not be bothered with managing chart dependencies, simply work with the ApiObject s you create, and let cdk8s infer the chart dependencies.","title":"Things just got cool"},{"location":"concepts/escape-hatches/","text":"Escape Hatches \u00b6 An \u201cescape hatch\u201d is an intentional leak in the abstraction layer. It allows users to \u201cescape the abstraction\u201d and reach out to a lower layer. Similarly, in CDKs, escape hatches are mechanisms that allow users to tweak the synthesized output when the abstraction they use does not \u201chold water\u201d. You may need to use an escape hatch in the following cases: You are using an imported API object (e.g. KubeDeployment ) and there is an issue with the schema or a bug in \u201cimport\u201d which results in an invalid manifest or missing fields (as an example see issue #140 ). You are using a high-level API (e.g. CDK8s+) which does not expose some functionality which exists in the lower-level resources. Patching API objects directly \u00b6 The ApiObject class, which is the base of all objects synthesized into a Kubernetes manifest offers an API for patching the synthesized output at the wire level using JSON Patch ( RFC-6902 ): import { JsonPatch } from 'cdk8s' ; apiObject . addJsonPatch ( JsonPatch . replace ( '/foo' , 'bar' )); apiObject . addJsonPatch ( JsonPatch . add ( '/foo/bar/0' , { bar : 123 })); During synthesis, patches are applied in-order after the API object synthesized itself. All classes generated using the CLI import command extend ApiObject , and therefore include the addJsonPatch() method. Patching API objects behind higher-level APIs \u00b6 The second use case for using escape hatches is when you are working against a higher-level construct which, for some reason, does not allow you to achieve what you need. For example, let\u2019s say you are using the Pod class from CDK8s+ and you wish to set [ enableServiceLinks ] to true . This feature is currently not supported in the CDK8s+ Pod API, so you\u2019ll want to patch the underlying KubePod and set this value. To do that, you will need to \u201cpeak\u201d into the construct tree and find the underlying API object, so you can apply the patch to it: import { Pod } from 'cdk8s-plus-22' ; import { ApiObject } from 'cdk8s' ; const pod = new Pod (...); const kubePod = ApiObject . of ( pod ); kubePod . addJsonPatch (...); The ApiObject.of() method uses capabilities of the constructs programming model to find the \u201cdefault child\u201d of a construct ( Node.of(c).defaultChild ). When a construct is initialized, it can either explicitly assign the value of Node.of(this).defaultChild = xxx or it can use the identity Default for one of its child constructs. This will automatically identify it as the default child. Tip The ApiObject.of() method recursively searches down the construct tree through child constructs called Default until it finds a child of type ApiObject . This means, for example, that ApiObject.of(apiObject) returns the same object. There could be situations where a default child is not recorded by a high-level construct. This still does not mean you are blocked from patching the underlying API objects. You can still use Node.of(x) to traverse the construct tree to obtain the child. For example, you can use Node.of(x).findChild(id) to retrieve any child by its ID.","title":"Escape Hatches"},{"location":"concepts/escape-hatches/#escape-hatches","text":"An \u201cescape hatch\u201d is an intentional leak in the abstraction layer. It allows users to \u201cescape the abstraction\u201d and reach out to a lower layer. Similarly, in CDKs, escape hatches are mechanisms that allow users to tweak the synthesized output when the abstraction they use does not \u201chold water\u201d. You may need to use an escape hatch in the following cases: You are using an imported API object (e.g. KubeDeployment ) and there is an issue with the schema or a bug in \u201cimport\u201d which results in an invalid manifest or missing fields (as an example see issue #140 ). You are using a high-level API (e.g. CDK8s+) which does not expose some functionality which exists in the lower-level resources.","title":"Escape Hatches"},{"location":"concepts/escape-hatches/#patching-api-objects-directly","text":"The ApiObject class, which is the base of all objects synthesized into a Kubernetes manifest offers an API for patching the synthesized output at the wire level using JSON Patch ( RFC-6902 ): import { JsonPatch } from 'cdk8s' ; apiObject . addJsonPatch ( JsonPatch . replace ( '/foo' , 'bar' )); apiObject . addJsonPatch ( JsonPatch . add ( '/foo/bar/0' , { bar : 123 })); During synthesis, patches are applied in-order after the API object synthesized itself. All classes generated using the CLI import command extend ApiObject , and therefore include the addJsonPatch() method.","title":"Patching API objects directly"},{"location":"concepts/escape-hatches/#patching-api-objects-behind-higher-level-apis","text":"The second use case for using escape hatches is when you are working against a higher-level construct which, for some reason, does not allow you to achieve what you need. For example, let\u2019s say you are using the Pod class from CDK8s+ and you wish to set [ enableServiceLinks ] to true . This feature is currently not supported in the CDK8s+ Pod API, so you\u2019ll want to patch the underlying KubePod and set this value. To do that, you will need to \u201cpeak\u201d into the construct tree and find the underlying API object, so you can apply the patch to it: import { Pod } from 'cdk8s-plus-22' ; import { ApiObject } from 'cdk8s' ; const pod = new Pod (...); const kubePod = ApiObject . of ( pod ); kubePod . addJsonPatch (...); The ApiObject.of() method uses capabilities of the constructs programming model to find the \u201cdefault child\u201d of a construct ( Node.of(c).defaultChild ). When a construct is initialized, it can either explicitly assign the value of Node.of(this).defaultChild = xxx or it can use the identity Default for one of its child constructs. This will automatically identify it as the default child. Tip The ApiObject.of() method recursively searches down the construct tree through child constructs called Default until it finds a child of type ApiObject . This means, for example, that ApiObject.of(apiObject) returns the same object. There could be situations where a default child is not recorded by a high-level construct. This still does not mean you are blocked from patching the underlying API objects. You can still use Node.of(x) to traverse the construct tree to obtain the child. For example, you can use Node.of(x).findChild(id) to retrieve any child by its ID.","title":"Patching API objects behind higher-level APIs"},{"location":"concepts/helm/","text":"Helm Support \u00b6 You can use the Helm construct in order to include Helm charts. In order to use this construct, you must have helm installed on your system. See Installing Helm in the Helm documentation for details. The following example adds the bitnami/redis Helm chart with sentinel containers enabled: The Bitnami helm repo needs to be added through: helm repo add bitnami https://charts.bitnami.com/bitnami class MyChart extends cdk8s . Chart { constructor ( scope : Construct , id : string ) { super ( scope , id ); const redis = new Helm ( this , 'redis' , { chart : 'bitnami/redis' , values : { sentinel : { enabled : true } } }); } } The Helm construct will render the manifest from the specified chart by executing helm template . If values is specified, these values will override the default values included with the chart. The name option can be used to specify the chart\u2019s release name . If not specified, a valid and unique release name will be allocated based on the construct path. The Helm construct extends Include and inherits it\u2019s API. For example, you can use the apiObjects property to find and interact with included API objects. The following example shows how to add an annotation to the Redis master deployment: const master = redis . apiObjects . find ( o => o . name === 'foo-redis-master' ); master . metadata . addAnnotation ( 'my.annotation' , 'hey-there' );","title":"Helm Support"},{"location":"concepts/helm/#helm-support","text":"You can use the Helm construct in order to include Helm charts. In order to use this construct, you must have helm installed on your system. See Installing Helm in the Helm documentation for details. The following example adds the bitnami/redis Helm chart with sentinel containers enabled: The Bitnami helm repo needs to be added through: helm repo add bitnami https://charts.bitnami.com/bitnami class MyChart extends cdk8s . Chart { constructor ( scope : Construct , id : string ) { super ( scope , id ); const redis = new Helm ( this , 'redis' , { chart : 'bitnami/redis' , values : { sentinel : { enabled : true } } }); } } The Helm construct will render the manifest from the specified chart by executing helm template . If values is specified, these values will override the default values included with the chart. The name option can be used to specify the chart\u2019s release name . If not specified, a valid and unique release name will be allocated based on the construct path. The Helm construct extends Include and inherits it\u2019s API. For example, you can use the apiObjects property to find and interact with included API objects. The following example shows how to add an annotation to the Redis master deployment: const master = redis . apiObjects . find ( o => o . name === 'foo-redis-master' ); master . metadata . addAnnotation ( 'my.annotation' , 'hey-there' );","title":"Helm Support"},{"location":"concepts/include/","text":"Include \u00b6 The Include construct can be used to include an existing manifest in a chart. The following example will include the Kubernetes Dashboard in MyChart : import { Include } from 'cdk8s' ; class MyChart extends Chart { constructor ( scope : Construct , id : string ) { super ( scope , id ); const dashboard = new Include ( this , 'dashboard' , { url : 'https://raw.githubusercontent.com/kubernetes/dashboard/v2.4.0/aio/deploy/recommended.yaml' , // or url : 'dashboard.yaml' }); // ...other resources } } All API objects defined in the included manifest will be added as children ApiObject s under the Include construct\u2019s scope and can be accessed through the apiObject property: The following example queries for all the Deployment resources in the dashboard: const deploymentApiObject = dashboard . apiObjects . find ( c => c . kind === ' Deployment ); NOTE: names of included objects ( metadata.name ) are preserved. This means that if you try to include the same manifest twice into the same chart, your manifest will have duplicate definitions of the same objects.","title":"Include"},{"location":"concepts/include/#include","text":"The Include construct can be used to include an existing manifest in a chart. The following example will include the Kubernetes Dashboard in MyChart : import { Include } from 'cdk8s' ; class MyChart extends Chart { constructor ( scope : Construct , id : string ) { super ( scope , id ); const dashboard = new Include ( this , 'dashboard' , { url : 'https://raw.githubusercontent.com/kubernetes/dashboard/v2.4.0/aio/deploy/recommended.yaml' , // or url : 'dashboard.yaml' }); // ...other resources } } All API objects defined in the included manifest will be added as children ApiObject s under the Include construct\u2019s scope and can be accessed through the apiObject property: The following example queries for all the Deployment resources in the dashboard: const deploymentApiObject = dashboard . apiObjects . find ( c => c . kind === ' Deployment ); NOTE: names of included objects ( metadata.name ) are preserved. This means that if you try to include the same manifest twice into the same chart, your manifest will have duplicate definitions of the same objects.","title":"Include"},{"location":"concepts/testing/","text":"Testing \u00b6 cdk8s bundles a set of test utilities under the Testing class: Testing.app() returns an App object bound to a temporary output directory. Testing.chart() returns a Chart object bound to a testing app. Testing.synth(chart) returns the Kubernetes manifest synthesized from a chart.","title":"Testing"},{"location":"concepts/testing/#testing","text":"cdk8s bundles a set of test utilities under the Testing class: Testing.app() returns an App object bound to a temporary output directory. Testing.chart() returns a Chart object bound to a testing app. Testing.synth(chart) returns the Kubernetes manifest synthesized from a chart.","title":"Testing"},{"location":"examples/","text":"CDK8s Examples Directory \u00b6 This section includes references for CDK8s and CDK8s+ examples that we have in our GitHub repository. Navigate to the example you like from the left side navigation panel.","title":"Overview"},{"location":"examples/#cdk8s-examples-directory","text":"This section includes references for CDK8s and CDK8s+ examples that we have in our GitHub repository. Navigate to the example you like from the left side navigation panel.","title":"CDK8s Examples Directory"},{"location":"examples/crd/","text":"CRDs \u00b6 Shows how to import and use Custom Resource Definitions TypeScript Python Java Go Note We try to maintain the same set of examples in all supported languages. Help us!","title":"CRDs"},{"location":"examples/crd/#crds","text":"Shows how to import and use Custom Resource Definitions TypeScript Python Java Go Note We try to maintain the same set of examples in all supported languages. Help us!","title":"CRDs"},{"location":"examples/hello/","text":"Hello, Kubernetes! \u00b6 Deploys hello-kubernetes as a Service behind a LoadBalancer. TypeScript Python Java Go Note We try to maintain the same set of examples in all supported languages. Help us!","title":"Hello, Kubernetes!"},{"location":"examples/hello/#hello-kubernetes","text":"Deploys hello-kubernetes as a Service behind a LoadBalancer. TypeScript Python Java Go Note We try to maintain the same set of examples in all supported languages. Help us!","title":"Hello, Kubernetes!"},{"location":"examples/plus-elasticsearch/","text":"Elasticsearch (CDK8s+) \u00b6 Creating a query service on top of Elasticsearch with CDK8s+ TypeScript Note We try to maintain the same set of examples in all supported languages. Help us!","title":"Elasticsearch (CDK8s+)"},{"location":"examples/plus-elasticsearch/#elasticsearch-cdk8s","text":"Creating a query service on top of Elasticsearch with CDK8s+ TypeScript Note We try to maintain the same set of examples in all supported languages. Help us!","title":"Elasticsearch (CDK8s+)"},{"location":"examples/plus-ingress/","text":"Ingress (CDK8s+) \u00b6 Example of using CDK8s+ Ingress resource. TypeScript Note We try to maintain the same set of examples in all supported languages. Help us!","title":"Ingress (CDK8s+)"},{"location":"examples/plus-ingress/#ingress-cdk8s","text":"Example of using CDK8s+ Ingress resource. TypeScript Note We try to maintain the same set of examples in all supported languages. Help us!","title":"Ingress (CDK8s+)"},{"location":"examples/podinfo/","text":"Podinfo \u00b6 Exploration of high-level APIs for Deployment , Service , AutoScaler and Ingress based on the podinfo project . TypeScript Note We try to maintain the same set of examples in all supported languages. Help us!","title":"Podinfo"},{"location":"examples/podinfo/#podinfo","text":"Exploration of high-level APIs for Deployment , Service , AutoScaler and Ingress based on the podinfo project . TypeScript Note We try to maintain the same set of examples in all supported languages. Help us!","title":"Podinfo"},{"location":"examples/web-service/","text":"WebService Abstraction \u00b6 Demonstrates how to make your first high-level construct which represents a web service which abstracts the hello example from earlier into a reusable piece of infrastructure. TypeScript Python Java Go Note We try to maintain the same set of examples in all supported languages. Help us!","title":"WebService Abstraction"},{"location":"examples/web-service/#webservice-abstraction","text":"Demonstrates how to make your first high-level construct which represents a web service which abstracts the hello example from earlier into a reusable piece of infrastructure. TypeScript Python Java Go Note We try to maintain the same set of examples in all supported languages. Help us!","title":"WebService Abstraction"},{"location":"plus/","text":"Overview \u00b6 cdk8s+ is a library with high level abstractions for authoring Kubernetes applications. Built on top of the auto-generated building blocks provided by CDK8s, this library includes a hand crafted construct for each native kubernetes object, exposing richer API\u2019s with reduced complexity. Here is an example of how we would deploy a simple nginx container, once with the low-level API (on the left), and once with the high level abstraction (on the right). cdk8s+ is vended as a separate library for each kubernetes spec version. The documentation presented here represents version 1.22.0 and is vended as the cdk8s-plus-22 library. Naming conventions \u00b6 Stable resources are represented by a construct of the same kind . For example, the io.k8s.api.core.v1.Pod resource maps to the Pod construct . Non stable resources are suffixed with their api version . For example, the io.k8s.api.networking.v1beta1.Ingress maps to the IngressV1Beta1 construct . Spec compatibility \u00b6 Per kubernetes compatibility guarantees , stable resources in this library are compatible with any spec version higher or equal to 1.22.0 . Non-stable resources are not guaranteed to be compatible, as they may be removed in future spec versions. Notice If you are deploying manifests produced by cdk8s-plus-22 onto clusters of a lower version, you might encounter some unsupported spec properties or invalid manifests. FAQ \u00b6 What\u2019s the difference between cdk8s-plus-20 , cdk8s-plus-21 , and cdk8s-plus-22 ? \u00b6 These are separately vended libraries that each target a different kubernetes version, marked by the -XX suffix. For example, cdk8s-plus-22 targets kubernetes version 1.22.0 . We offer a dedicated package per Kubernetes version to allow users to match their manifests to the Kubernetes version they are operating. This way, users are only exposed to a set of capabilities offered by their specific cluster, preventing deployment errors caused by version mismatches. I operate Kubernetes version 1.XX - which cdk8s+ library should I be using? \u00b6 If there is a cdk8s-plus-XX library that matches your target Kubernetes version, we recommend using it since all Kubernetes manifests generated using it will be compatible. If there is not a matching cdk8s-plus-XX library, we recommend using the closest matching version. The manifests generated by cdk8s-plus-XX may also work for older versions of Kubernetes, but you might encounter some unsupported spec properties or invalid manifests. I\u2019m using cdk8s-plus-XX - which kubernetes versions will my manifest work on? \u00b6 If you are using stable APIs (those that are not in alpha or beta), manifests generated in cdk8s-plus-XX will work in Kubernetes versions 1.XX.0 and above. Unstable APIs (which are always labeled in cdk8s+ using a suffix, e.g. IngressV1Beta1 ) may work in newer versions of Kubernetes, but it is also possible they have been removed. The manifests generated by cdk8s-plus-XX may also work for older versions of Kubernetes, but you might encounter some unsupported spec properties or invalid manifests. At a glance \u00b6 import * as kplus from 'cdk8s-plus-22' ; import * as cdk8s from 'cdk8s' ; import * as path from 'path' ; // our cdk app const app = new cdk8s . App (); // our kubernetes chart const chart = new cdk8s . Chart ( app , 'my-chart' ); // lets create a volume that contains our app. // we use a trick with a config map! const appData = new kplus . ConfigMap ( chart , 'AppData' ); appData . addDirectory ( path . join ( __dirname , 'app' )); const appVolume = kplus . Volume . fromConfigMap ( appData ); // lets create a deployment to run a few instances of a pod const deployment = new kplus . Deployment ( chart , 'Deployment' , { replicas : 3 , }); // now we create a container that runs our app const appPath = '/var/lib/app' ; const port = 80 ; const container = deployment . addContainer ({ image : 'node:14.4.0-alpine3.12' , command : [ 'node' , 'index.js' , ` ${ port } ` ], port : port , workingDir : appPath , }); // make the app accessible to the container container . mount ( appPath , appVolume ); // finally, we expose the deployment as a load balancer service and make it run deployment . expose ( 8080 , { serviceType : kplus.ServiceType.LOAD_BALANCER }) // we are done, synth app . synth (); dist/my-chart.yaml apiVersion : v1 data : index.js : |- var http = require('http'); var port = process.argv[2]; //create a server object: http.createServer(function (req, res) { res.write('Hello World!'); //write a response to the client res.end(); //end the response }).listen(port); //the server object listens on port 80 kind : ConfigMap metadata : annotations : {} labels : {} name : chart-appdata-configmap-da4c63ab --- apiVersion : apps/v1 kind : Deployment metadata : annotations : {} labels : {} name : chart-deployment-pod-d4285cc9 spec : replicas : 3 selector : matchLabels : cdk8s.deployment : ChartDeploymentCFC2E30C template : metadata : annotations : {} labels : cdk8s.deployment : ChartDeploymentCFC2E30C spec : containers : - command : - node - index.js - \"80\" env : [] image : node:14.4.0-alpine3.12 name : main ports : - containerPort : 80 volumeMounts : - mountPath : /var/lib/app name : configmap-chart-appdata-configmap-da4c63ab workingDir : /var/lib/app volumes : - configMap : name : chart-appdata-configmap-da4c63ab name : configmap-chart-appdata-configmap-da4c63ab --- apiVersion : v1 kind : Service metadata : annotations : {} labels : {} name : chart-deployment-service-pod-42f50c26 spec : externalIPs : [] ports : - port : 8080 targetPort : 80 selector : cdk8s.deployment : ChartDeploymentCFC2E30C type : LoadBalancer Getting Started \u00b6 TypeScript/JavaScript \u276f npm install cdk8s-plus-22 cdk8s import * as kplus from 'cdk8s-plus-22' ; import * as cdk8s from 'cdk8s' ; const app = new cdk8s . App (); const chart = new cdk8s . Chart ( app , 'Chart' ); new kplus . Deployment ( chart , 'Deployment' , { replicas : 3 , containers : [{ image : 'ubuntu' , }], }); app . synth (); Python \u276f pip install --pre cdk8s-plus-22 cdk8s import cdk8s_plus_22 as kplus import cdk8s app = cdk8s . App () chart = cdk8s . Chart ( app , 'Chart' ) kplus . Deployment ( chart , 'Deployment' , replicas = 1 , containers = [ kplus . ContainerProps ( image = 'ubuntu' )] ) app . synth () Java <dependency> <groupId> org.cdk8s </groupId> <artifactId> cdk8s </artifactId> <version> 1.0.0-beta.46 </version> </dependency> <dependency> <groupId> org.cdk8s </groupId> <artifactId> cdk8s-plus-22 </artifactId> <version> 1.0.0-beta.1 </version> </dependency> import org.cdk8s.App ; import org.cdk8s.Chart ; import org.cdk8s.plus22.Deployment ; import org.cdk8s.plus22.ContainerProps ; App app = new App (); Chart chart = new Chart ( app , \"Chart\" ); Deployment . Builder . create ( this , \"Deployment\" ) . replicas ( 3 ) . containers ( Arrays . asList ( ContainerProps . builder () . image ( \"ubuntu\" ) . build ())) . build (); app . synth (); Go import ( \"github.com/aws/constructs-go/constructs/v3\" \"github.com/aws/jsii-runtime-go\" \"github.com/cdk8s-team/cdk8s-core-go/cdk8s\" \"github.com/cdk8s-team/cdk8s-plus-go/cdk8splus22\" ) app := cdk8s . NewApp ( nil ) chart := cdk8s . NewChart ( app , jsii . String ( \"ubuntu\" ), nil ) cdk8splus22 . NewDeployment ( chart , jsii . String ( \"Deployment\" ), & cdk8splus22 . DeploymentProps { Replicas : jsii . Number ( 3 ), Containers : & [] * cdk8splus22 . ContainerProps {{ Image : jsii . String ( \"ubuntu\" ), }}, }) app . Synth ()","title":"Overview"},{"location":"plus/#overview","text":"cdk8s+ is a library with high level abstractions for authoring Kubernetes applications. Built on top of the auto-generated building blocks provided by CDK8s, this library includes a hand crafted construct for each native kubernetes object, exposing richer API\u2019s with reduced complexity. Here is an example of how we would deploy a simple nginx container, once with the low-level API (on the left), and once with the high level abstraction (on the right). cdk8s+ is vended as a separate library for each kubernetes spec version. The documentation presented here represents version 1.22.0 and is vended as the cdk8s-plus-22 library.","title":"Overview"},{"location":"plus/#naming-conventions","text":"Stable resources are represented by a construct of the same kind . For example, the io.k8s.api.core.v1.Pod resource maps to the Pod construct . Non stable resources are suffixed with their api version . For example, the io.k8s.api.networking.v1beta1.Ingress maps to the IngressV1Beta1 construct .","title":"Naming conventions"},{"location":"plus/#spec-compatibility","text":"Per kubernetes compatibility guarantees , stable resources in this library are compatible with any spec version higher or equal to 1.22.0 . Non-stable resources are not guaranteed to be compatible, as they may be removed in future spec versions. Notice If you are deploying manifests produced by cdk8s-plus-22 onto clusters of a lower version, you might encounter some unsupported spec properties or invalid manifests.","title":"Spec compatibility"},{"location":"plus/#faq","text":"","title":"FAQ"},{"location":"plus/#whats-the-difference-between-cdk8s-plus-20-cdk8s-plus-21-and-cdk8s-plus-22","text":"These are separately vended libraries that each target a different kubernetes version, marked by the -XX suffix. For example, cdk8s-plus-22 targets kubernetes version 1.22.0 . We offer a dedicated package per Kubernetes version to allow users to match their manifests to the Kubernetes version they are operating. This way, users are only exposed to a set of capabilities offered by their specific cluster, preventing deployment errors caused by version mismatches.","title":"What's the difference between cdk8s-plus-20, cdk8s-plus-21, and cdk8s-plus-22?"},{"location":"plus/#i-operate-kubernetes-version-1xx-which-cdk8s-library-should-i-be-using","text":"If there is a cdk8s-plus-XX library that matches your target Kubernetes version, we recommend using it since all Kubernetes manifests generated using it will be compatible. If there is not a matching cdk8s-plus-XX library, we recommend using the closest matching version. The manifests generated by cdk8s-plus-XX may also work for older versions of Kubernetes, but you might encounter some unsupported spec properties or invalid manifests.","title":"I operate Kubernetes version 1.XX - which cdk8s+ library should I be using?"},{"location":"plus/#im-using-cdk8s-plus-xx-which-kubernetes-versions-will-my-manifest-work-on","text":"If you are using stable APIs (those that are not in alpha or beta), manifests generated in cdk8s-plus-XX will work in Kubernetes versions 1.XX.0 and above. Unstable APIs (which are always labeled in cdk8s+ using a suffix, e.g. IngressV1Beta1 ) may work in newer versions of Kubernetes, but it is also possible they have been removed. The manifests generated by cdk8s-plus-XX may also work for older versions of Kubernetes, but you might encounter some unsupported spec properties or invalid manifests.","title":"I'm using cdk8s-plus-XX - which kubernetes versions will my manifest work on?"},{"location":"plus/#at-a-glance","text":"import * as kplus from 'cdk8s-plus-22' ; import * as cdk8s from 'cdk8s' ; import * as path from 'path' ; // our cdk app const app = new cdk8s . App (); // our kubernetes chart const chart = new cdk8s . Chart ( app , 'my-chart' ); // lets create a volume that contains our app. // we use a trick with a config map! const appData = new kplus . ConfigMap ( chart , 'AppData' ); appData . addDirectory ( path . join ( __dirname , 'app' )); const appVolume = kplus . Volume . fromConfigMap ( appData ); // lets create a deployment to run a few instances of a pod const deployment = new kplus . Deployment ( chart , 'Deployment' , { replicas : 3 , }); // now we create a container that runs our app const appPath = '/var/lib/app' ; const port = 80 ; const container = deployment . addContainer ({ image : 'node:14.4.0-alpine3.12' , command : [ 'node' , 'index.js' , ` ${ port } ` ], port : port , workingDir : appPath , }); // make the app accessible to the container container . mount ( appPath , appVolume ); // finally, we expose the deployment as a load balancer service and make it run deployment . expose ( 8080 , { serviceType : kplus.ServiceType.LOAD_BALANCER }) // we are done, synth app . synth (); dist/my-chart.yaml apiVersion : v1 data : index.js : |- var http = require('http'); var port = process.argv[2]; //create a server object: http.createServer(function (req, res) { res.write('Hello World!'); //write a response to the client res.end(); //end the response }).listen(port); //the server object listens on port 80 kind : ConfigMap metadata : annotations : {} labels : {} name : chart-appdata-configmap-da4c63ab --- apiVersion : apps/v1 kind : Deployment metadata : annotations : {} labels : {} name : chart-deployment-pod-d4285cc9 spec : replicas : 3 selector : matchLabels : cdk8s.deployment : ChartDeploymentCFC2E30C template : metadata : annotations : {} labels : cdk8s.deployment : ChartDeploymentCFC2E30C spec : containers : - command : - node - index.js - \"80\" env : [] image : node:14.4.0-alpine3.12 name : main ports : - containerPort : 80 volumeMounts : - mountPath : /var/lib/app name : configmap-chart-appdata-configmap-da4c63ab workingDir : /var/lib/app volumes : - configMap : name : chart-appdata-configmap-da4c63ab name : configmap-chart-appdata-configmap-da4c63ab --- apiVersion : v1 kind : Service metadata : annotations : {} labels : {} name : chart-deployment-service-pod-42f50c26 spec : externalIPs : [] ports : - port : 8080 targetPort : 80 selector : cdk8s.deployment : ChartDeploymentCFC2E30C type : LoadBalancer","title":"At a glance"},{"location":"plus/#getting-started","text":"TypeScript/JavaScript \u276f npm install cdk8s-plus-22 cdk8s import * as kplus from 'cdk8s-plus-22' ; import * as cdk8s from 'cdk8s' ; const app = new cdk8s . App (); const chart = new cdk8s . Chart ( app , 'Chart' ); new kplus . Deployment ( chart , 'Deployment' , { replicas : 3 , containers : [{ image : 'ubuntu' , }], }); app . synth (); Python \u276f pip install --pre cdk8s-plus-22 cdk8s import cdk8s_plus_22 as kplus import cdk8s app = cdk8s . App () chart = cdk8s . Chart ( app , 'Chart' ) kplus . Deployment ( chart , 'Deployment' , replicas = 1 , containers = [ kplus . ContainerProps ( image = 'ubuntu' )] ) app . synth () Java <dependency> <groupId> org.cdk8s </groupId> <artifactId> cdk8s </artifactId> <version> 1.0.0-beta.46 </version> </dependency> <dependency> <groupId> org.cdk8s </groupId> <artifactId> cdk8s-plus-22 </artifactId> <version> 1.0.0-beta.1 </version> </dependency> import org.cdk8s.App ; import org.cdk8s.Chart ; import org.cdk8s.plus22.Deployment ; import org.cdk8s.plus22.ContainerProps ; App app = new App (); Chart chart = new Chart ( app , \"Chart\" ); Deployment . Builder . create ( this , \"Deployment\" ) . replicas ( 3 ) . containers ( Arrays . asList ( ContainerProps . builder () . image ( \"ubuntu\" ) . build ())) . build (); app . synth (); Go import ( \"github.com/aws/constructs-go/constructs/v3\" \"github.com/aws/jsii-runtime-go\" \"github.com/cdk8s-team/cdk8s-core-go/cdk8s\" \"github.com/cdk8s-team/cdk8s-plus-go/cdk8splus22\" ) app := cdk8s . NewApp ( nil ) chart := cdk8s . NewChart ( app , jsii . String ( \"ubuntu\" ), nil ) cdk8splus22 . NewDeployment ( chart , jsii . String ( \"Deployment\" ), & cdk8splus22 . DeploymentProps { Replicas : jsii . Number ( 3 ), Containers : & [] * cdk8splus22 . ContainerProps {{ Image : jsii . String ( \"ubuntu\" ), }}, }) app . Synth ()","title":"Getting Started"},{"location":"plus/config-map/","text":"ConfigMap \u00b6 ConfigMap are used to store configuration data. They provide a dictionary based data structure that can be consumed in various shapes and forms. API Reference Use an existing ConfigMap \u00b6 You can reference to an existing ConfigMap like so. Note that this does not create a new object, and will therefore not be included in the resulting manifest. import * as kplus from 'cdk8s-plus-22' ; const config : kplus.IConfigMap = kplus . ConfigMap . fromConfigMapName ( 'config' ); // the 'config' constant can later be used by API's that require an IConfigMap. // for example when creating a volume. const volume = kplus . Volume . fromConfigMap ( config ); Adding data \u00b6 You can create config maps and add some data to them like so: import * as kplus from 'cdk8s-plus-22' ; import * as k from 'cdk8s' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const config = new kplus . ConfigMap ( chart , 'Config' ); config . addData ( 'url' , 'https://my-endpoint:8080' ); Creating a volume from a directory \u00b6 Here is a nifty little trick you can use to create a volume that contains a directory on the client machine (machine that runs cdk8s synth ): import * as kplus from 'cdk8s-plus-22' ; import * as k from 'cdk8s' ; import * as path from 'path' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const appMap = new kplus . ConfigMap ( chart , 'Config' ); // add the files in the directory to the config map. // this will create a key for each file. // note that only top level files will be included, sub-directories are not yet supported. appMap . addDirectory ( path . join ( __dirname , 'app' )); const appVolume = kplus . Volume . fromConfigMap ( appMap ); const mountPath = '/var/app' ; const pod = new kplus . Pod ( chart , 'Pod' ); const container = pod . addContainer ({ image : 'node' , command : [ 'node' , 'app.js' ], workingDir : mountPath , }); // from here, just mount the volume to a container, and run your app! container . mount ( mountPath , appVolume );","title":"ConfigMap"},{"location":"plus/config-map/#configmap","text":"ConfigMap are used to store configuration data. They provide a dictionary based data structure that can be consumed in various shapes and forms. API Reference","title":"ConfigMap"},{"location":"plus/config-map/#use-an-existing-configmap","text":"You can reference to an existing ConfigMap like so. Note that this does not create a new object, and will therefore not be included in the resulting manifest. import * as kplus from 'cdk8s-plus-22' ; const config : kplus.IConfigMap = kplus . ConfigMap . fromConfigMapName ( 'config' ); // the 'config' constant can later be used by API's that require an IConfigMap. // for example when creating a volume. const volume = kplus . Volume . fromConfigMap ( config );","title":"Use an existing ConfigMap"},{"location":"plus/config-map/#adding-data","text":"You can create config maps and add some data to them like so: import * as kplus from 'cdk8s-plus-22' ; import * as k from 'cdk8s' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const config = new kplus . ConfigMap ( chart , 'Config' ); config . addData ( 'url' , 'https://my-endpoint:8080' );","title":"Adding data"},{"location":"plus/config-map/#creating-a-volume-from-a-directory","text":"Here is a nifty little trick you can use to create a volume that contains a directory on the client machine (machine that runs cdk8s synth ): import * as kplus from 'cdk8s-plus-22' ; import * as k from 'cdk8s' ; import * as path from 'path' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const appMap = new kplus . ConfigMap ( chart , 'Config' ); // add the files in the directory to the config map. // this will create a key for each file. // note that only top level files will be included, sub-directories are not yet supported. appMap . addDirectory ( path . join ( __dirname , 'app' )); const appVolume = kplus . Volume . fromConfigMap ( appMap ); const mountPath = '/var/app' ; const pod = new kplus . Pod ( chart , 'Pod' ); const container = pod . addContainer ({ image : 'node' , command : [ 'node' , 'app.js' ], workingDir : mountPath , }); // from here, just mount the volume to a container, and run your app! container . mount ( mountPath , appVolume );","title":"Creating a volume from a directory"},{"location":"plus/container/","text":"Container \u00b6 Define containers that run in a pod using the Container class. API Reference Environment variables \u00b6 Environment variables can be added to containers using various sources, via semantically explicit API\u2019s: import * as kplus from 'cdk8s-plus-22' const pod = new kplus . Pod ( this , 'Pod' ); const container = pod . addContainer ({ image : 'my-app' }); // explicitly use a value. container . addEnv ( 'endpoint' , kplus . EnvValue . fromValue ( 'value' )); // use a specific key from a config map. const backendsConfig = kplus . ConfigMap . fromConfigMapName ( 'backends' ); container . addEnv ( 'endpoint' , kplus . EnvValue . fromConfigMap ( backendsConfig , 'endpoint' )); // use a specific key from a secret. const credentials = kplus . Secret . fromSecretName ( 'credentials' ); container . addEnv ( 'password' , kplus . EnvValue . fromSecret ( credentials , 'password' )); Volume Mounts \u00b6 A very common capability is to mount a volume with some data onto a container. Using pure kubernetes API, this would require writing something like: kind : Pod apiVersion : v1 spec : containers : - name : main volumeMounts : - mountPath : /path/to/mount name : 'config-volume' volumes : - name : 'config-volume' configMap : name : 'config' Notice the apparent redundancy of having to specify the volume name twice. Also, if you happen to need the same mount in other pods, you would need to duplicate this configuration. This can get complex and cluttered very fast. In contrast, here is how to do this with cdk8s+ : import * as kplus from 'cdk8s-plus-22' ; const config = kplus . ConfigMap . fromConfigMapName ( 'config' ); const volume = kplus . Volume . fromConfigMap ( config ); const pod = new kplus . Pod ( this , 'Pod' ); const container = pod . addContainer ({ image : 'my-app' }) // Cool alert: every pod that will later be configured with this container, // will automatically have access to this volume, so you don't need to explicitly add it to the pod spec!. container . mount ( '/path/to/mount' , volume ); Probes \u00b6 A Probe is a diagnostic performed periodically by the kubelet on a Container. To perform a diagnostic, the kubelet calls a Handler implemented by the container. A Probe instance can be created through one of the fromXxx static methods: Probe.fromHttpGet() Probe.fromCommand() Readiness, liveness, and startup probes can be configured at the container-level through the readiness , liveness , and startup options: new kplus . Pod ( this , 'Pod' , { containers : [ { // ... readiness : kplus.Probe.fromHttpGet ( '/ping' ), } ] }); See the API reference for details.","title":"Container"},{"location":"plus/container/#container","text":"Define containers that run in a pod using the Container class. API Reference","title":"Container"},{"location":"plus/container/#environment-variables","text":"Environment variables can be added to containers using various sources, via semantically explicit API\u2019s: import * as kplus from 'cdk8s-plus-22' const pod = new kplus . Pod ( this , 'Pod' ); const container = pod . addContainer ({ image : 'my-app' }); // explicitly use a value. container . addEnv ( 'endpoint' , kplus . EnvValue . fromValue ( 'value' )); // use a specific key from a config map. const backendsConfig = kplus . ConfigMap . fromConfigMapName ( 'backends' ); container . addEnv ( 'endpoint' , kplus . EnvValue . fromConfigMap ( backendsConfig , 'endpoint' )); // use a specific key from a secret. const credentials = kplus . Secret . fromSecretName ( 'credentials' ); container . addEnv ( 'password' , kplus . EnvValue . fromSecret ( credentials , 'password' ));","title":"Environment variables"},{"location":"plus/container/#volume-mounts","text":"A very common capability is to mount a volume with some data onto a container. Using pure kubernetes API, this would require writing something like: kind : Pod apiVersion : v1 spec : containers : - name : main volumeMounts : - mountPath : /path/to/mount name : 'config-volume' volumes : - name : 'config-volume' configMap : name : 'config' Notice the apparent redundancy of having to specify the volume name twice. Also, if you happen to need the same mount in other pods, you would need to duplicate this configuration. This can get complex and cluttered very fast. In contrast, here is how to do this with cdk8s+ : import * as kplus from 'cdk8s-plus-22' ; const config = kplus . ConfigMap . fromConfigMapName ( 'config' ); const volume = kplus . Volume . fromConfigMap ( config ); const pod = new kplus . Pod ( this , 'Pod' ); const container = pod . addContainer ({ image : 'my-app' }) // Cool alert: every pod that will later be configured with this container, // will automatically have access to this volume, so you don't need to explicitly add it to the pod spec!. container . mount ( '/path/to/mount' , volume );","title":"Volume Mounts"},{"location":"plus/container/#probes","text":"A Probe is a diagnostic performed periodically by the kubelet on a Container. To perform a diagnostic, the kubelet calls a Handler implemented by the container. A Probe instance can be created through one of the fromXxx static methods: Probe.fromHttpGet() Probe.fromCommand() Readiness, liveness, and startup probes can be configured at the container-level through the readiness , liveness , and startup options: new kplus . Pod ( this , 'Pod' , { containers : [ { // ... readiness : kplus.Probe.fromHttpGet ( '/ping' ), } ] }); See the API reference for details.","title":"Probes"},{"location":"plus/deployment/","text":"Deployment \u00b6 Create a deployment to govern the lifecycle and orchestration of a set of identical pods. API Reference Automatic pod selection \u00b6 When you specify pods in a deployment, you normally have to configure the appropriate labels and selectors to make the deployment control the relevant pods. This construct does this automatically. import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-22' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); new kplus . Deployment ( chart , 'FrontEnds' , { containers : [ { image : 'node' } ], }); Note the resulting manifest contains a special cdk8s.deployment label that is applied to the pods, and is used as the selector for the deployment. apiVersion : apps/v1 kind : Deployment metadata : annotations : {} labels : {} name : chart-frontends-pod-a48e7f2e spec : replicas : 1 selector : matchLabels : cdk8s.deployment : ChartFrontEndsDD8A97CE template : metadata : annotations : {} labels : cdk8s.deployment : ChartFrontEndsDD8A97CE Exposing via a service \u00b6 Following up on pod selection, you can also easily create a service that will select the pods relevant to the deployment. // store the deployment to created in a constant const frontends = new kplus . Deployment ( chart , 'FrontEnds' ); // create a ClusterIP service that listens on port 9000 and redirects to port 9000 on the containers. frontends . expose ( 9000 ) Notice the resulting manifest, will have the same cdk8s.deployment magic label as the selector. This will cause the service to attach to the pods that were configured as part of the said deployment. apiVersion : v1 kind : Service metadata : annotations : {} labels : {} name : chart-frontends-service-pod-1f70150b spec : externalIPs : [] ports : - port : 9000 selector : cdk8s.deployment : ChartFrontEndsDD8A97CE type : ClusterIP","title":"Deployment"},{"location":"plus/deployment/#deployment","text":"Create a deployment to govern the lifecycle and orchestration of a set of identical pods. API Reference","title":"Deployment"},{"location":"plus/deployment/#automatic-pod-selection","text":"When you specify pods in a deployment, you normally have to configure the appropriate labels and selectors to make the deployment control the relevant pods. This construct does this automatically. import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-22' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); new kplus . Deployment ( chart , 'FrontEnds' , { containers : [ { image : 'node' } ], }); Note the resulting manifest contains a special cdk8s.deployment label that is applied to the pods, and is used as the selector for the deployment. apiVersion : apps/v1 kind : Deployment metadata : annotations : {} labels : {} name : chart-frontends-pod-a48e7f2e spec : replicas : 1 selector : matchLabels : cdk8s.deployment : ChartFrontEndsDD8A97CE template : metadata : annotations : {} labels : cdk8s.deployment : ChartFrontEndsDD8A97CE","title":"Automatic pod selection"},{"location":"plus/deployment/#exposing-via-a-service","text":"Following up on pod selection, you can also easily create a service that will select the pods relevant to the deployment. // store the deployment to created in a constant const frontends = new kplus . Deployment ( chart , 'FrontEnds' ); // create a ClusterIP service that listens on port 9000 and redirects to port 9000 on the containers. frontends . expose ( 9000 ) Notice the resulting manifest, will have the same cdk8s.deployment magic label as the selector. This will cause the service to attach to the pods that were configured as part of the said deployment. apiVersion : v1 kind : Service metadata : annotations : {} labels : {} name : chart-frontends-service-pod-1f70150b spec : externalIPs : [] ports : - port : 9000 selector : cdk8s.deployment : ChartFrontEndsDD8A97CE type : ClusterIP","title":"Exposing via a service"},{"location":"plus/ingress/","text":"Ingress \u00b6 Ingress manages external access to services in a cluster, typically through HTTP. Ingress may provide load balancing, SSL termination and name-based virtual hosting. API Reference You must have an Ingress controller to satisfy an Ingress. Only creating an Ingress resource has no effect. The following example will route HTTP requests sent to the /hello url prefix to a service associated with a deployment of the hashicorp/http-echo image. const helloDeployment = new kplus . Deployment ( this , text , { containers : [ { image : 'hashicorp/http-echo' , args : [ '-text' , 'hello ingress' ] } ] }); const helloService = helloDeployment . expose ( 5678 ); const ingress = new Ingress ( this , 'ingress' ); ingress . addRule ( '/hello' , kplus . IngressBackend . fromService ( helloService )); You can use addHostRule(host, path, backend) to define a route that will only apply to requests with this Host header. This can be used to implement virtual hosts. The addDefaultBackend(backend) and addHostDefaultBackend(host, backend) methods can be used to define backends that will accept all requests that do not match any other rules. The TCP port used to route requests to services will be determined based on which ports are exposed by the service (e.g. through serve() ). If the service exposes multiple ports, then a port must be specified via IngressBackend.fromService(service, { port }) .","title":"Ingress"},{"location":"plus/ingress/#ingress","text":"Ingress manages external access to services in a cluster, typically through HTTP. Ingress may provide load balancing, SSL termination and name-based virtual hosting. API Reference You must have an Ingress controller to satisfy an Ingress. Only creating an Ingress resource has no effect. The following example will route HTTP requests sent to the /hello url prefix to a service associated with a deployment of the hashicorp/http-echo image. const helloDeployment = new kplus . Deployment ( this , text , { containers : [ { image : 'hashicorp/http-echo' , args : [ '-text' , 'hello ingress' ] } ] }); const helloService = helloDeployment . expose ( 5678 ); const ingress = new Ingress ( this , 'ingress' ); ingress . addRule ( '/hello' , kplus . IngressBackend . fromService ( helloService )); You can use addHostRule(host, path, backend) to define a route that will only apply to requests with this Host header. This can be used to implement virtual hosts. The addDefaultBackend(backend) and addHostDefaultBackend(host, backend) methods can be used to define backends that will accept all requests that do not match any other rules. The TCP port used to route requests to services will be determined based on which ports are exposed by the service (e.g. through serve() ). If the service exposes multiple ports, then a port must be specified via IngressBackend.fromService(service, { port }) .","title":"Ingress"},{"location":"plus/job/","text":"Job \u00b6 Jobs are a very useful concept in kubernetes deployments. They can be used for add-hoc provisioning tasks, as well as long running processing jobs. In configuration, they don\u2019t differ much from regular pods, but offer some additional properties. API Reference Delete a Job after its finished \u00b6 You can configure a TTL for the job after it finished its execution successfully. import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-22' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); // let's define a job spec, and set a 1 second TTL. const load = new kplus . Job ( chart , 'LoadData' , { ttlAfterFinished : kplus.Duration.seconds ( 1 ) }); // now add a container to all the pods created by this job job . addContainer ({ image : 'loader' });","title":"Job"},{"location":"plus/job/#job","text":"Jobs are a very useful concept in kubernetes deployments. They can be used for add-hoc provisioning tasks, as well as long running processing jobs. In configuration, they don\u2019t differ much from regular pods, but offer some additional properties. API Reference","title":"Job"},{"location":"plus/job/#delete-a-job-after-its-finished","text":"You can configure a TTL for the job after it finished its execution successfully. import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-22' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); // let's define a job spec, and set a 1 second TTL. const load = new kplus . Job ( chart , 'LoadData' , { ttlAfterFinished : kplus.Duration.seconds ( 1 ) }); // now add a container to all the pods created by this job job . addContainer ({ image : 'loader' });","title":"Delete a Job after its finished"},{"location":"plus/pod/","text":"Pod \u00b6 A pod is essentially a collection of containers. It is the most fundamental computation unit that can be provisioned. API Reference Adding Containers/Volumes \u00b6 Containers and volumes can be added to pod definition like so: import * as kplus from 'cdk8s-plus-22' ; const pod = new kplus . Pod ( chart , 'Pod' ); const container = pod . addContainer ({ image : 'node' , }); const storage = kplus . Volume . fromEmptyDir ( 'storage' ); container . mount ( '/data' , storage ); const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); // this will automatically add the volume as well. pod . addContainer ( container ); // but if you want to explicitly add it, simply use: pod . addVolume ( storage ); Applying a restart policy \u00b6 import * as kplus from 'cdk8s-plus-22' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const pod = new kplus . Pod ( chart , 'Pod' , { restartPolicy : kplus.RestartPolicy.NEVER , }); Assigning a ServiceAccount \u00b6 import * as kplus from 'cdk8s-plus-22' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const pod = new kplus . Pod ( chart , 'Pod' , { serviceAccount : kplus.ServiceAccount.fromServiceAccountName ( 'aws' ), });","title":"Pod"},{"location":"plus/pod/#pod","text":"A pod is essentially a collection of containers. It is the most fundamental computation unit that can be provisioned. API Reference","title":"Pod"},{"location":"plus/pod/#adding-containersvolumes","text":"Containers and volumes can be added to pod definition like so: import * as kplus from 'cdk8s-plus-22' ; const pod = new kplus . Pod ( chart , 'Pod' ); const container = pod . addContainer ({ image : 'node' , }); const storage = kplus . Volume . fromEmptyDir ( 'storage' ); container . mount ( '/data' , storage ); const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); // this will automatically add the volume as well. pod . addContainer ( container ); // but if you want to explicitly add it, simply use: pod . addVolume ( storage );","title":"Adding Containers/Volumes"},{"location":"plus/pod/#applying-a-restart-policy","text":"import * as kplus from 'cdk8s-plus-22' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const pod = new kplus . Pod ( chart , 'Pod' , { restartPolicy : kplus.RestartPolicy.NEVER , });","title":"Applying a restart policy"},{"location":"plus/pod/#assigning-a-serviceaccount","text":"import * as kplus from 'cdk8s-plus-22' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const pod = new kplus . Pod ( chart , 'Pod' , { serviceAccount : kplus.ServiceAccount.fromServiceAccountName ( 'aws' ), });","title":"Assigning a ServiceAccount"},{"location":"plus/secret/","text":"Secret \u00b6 Secrets are used to store confidential information. Never store such information on the definition of the pod itself. API Reference Use an existing Secret \u00b6 To reference a secret created outside of your deployment definition, use the following. Note that this does not create a new object, and will therefore not be included in the resulting manifest. import * as kplus from 'cdk8s-plus-22' ; const secret = kplus . Secret . fromSecretName ( 'aws-creds' ); Adding data \u00b6 To create a new secret with some data, use: import * as kplus from 'cdk8s-plus-22' ; import * as k from 'cdk8s' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const secret = new kplus . Secret ( chart , 'Secret' ); secret . addStringData ( 'password' , 'some-encrypted-data' );","title":"Secret"},{"location":"plus/secret/#secret","text":"Secrets are used to store confidential information. Never store such information on the definition of the pod itself. API Reference","title":"Secret"},{"location":"plus/secret/#use-an-existing-secret","text":"To reference a secret created outside of your deployment definition, use the following. Note that this does not create a new object, and will therefore not be included in the resulting manifest. import * as kplus from 'cdk8s-plus-22' ; const secret = kplus . Secret . fromSecretName ( 'aws-creds' );","title":"Use an existing Secret"},{"location":"plus/secret/#adding-data","text":"To create a new secret with some data, use: import * as kplus from 'cdk8s-plus-22' ; import * as k from 'cdk8s' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const secret = new kplus . Secret ( chart , 'Secret' ); secret . addStringData ( 'password' , 'some-encrypted-data' );","title":"Adding data"},{"location":"plus/service-account/","text":"ServiceAccount \u00b6 Use service accounts to provide an identity for pods. API Reference Use an existing ServiceAccount \u00b6 To reference a service account created outside of your deployment definition, use the following. Note that this does not create a new object, and will therefore not be included in the resulting manifest. import * as kplus from 'cdk8s-plus-22' ; const serviceAccount = kplus . ServiceAccount . fromServiceAccountName ( 'aws-service' ); Allowing access to secrets \u00b6 To create a new service account, and give it access to some secrets, use the following: import * as kplus from 'cdk8s-plus-22' ; import * as k from 'cdk8s' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const awsCreds = kplus . Secret . fromSecretName ( 'aws-creds' ); const awsService = new kplus . ServiceAccount ( chart , 'AWS' ); // give access to the aws creds secret. awsService . addSecret ( awsCreds );","title":"ServiceAccount"},{"location":"plus/service-account/#serviceaccount","text":"Use service accounts to provide an identity for pods. API Reference","title":"ServiceAccount"},{"location":"plus/service-account/#use-an-existing-serviceaccount","text":"To reference a service account created outside of your deployment definition, use the following. Note that this does not create a new object, and will therefore not be included in the resulting manifest. import * as kplus from 'cdk8s-plus-22' ; const serviceAccount = kplus . ServiceAccount . fromServiceAccountName ( 'aws-service' );","title":"Use an existing ServiceAccount"},{"location":"plus/service-account/#allowing-access-to-secrets","text":"To create a new service account, and give it access to some secrets, use the following: import * as kplus from 'cdk8s-plus-22' ; import * as k from 'cdk8s' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const awsCreds = kplus . Secret . fromSecretName ( 'aws-creds' ); const awsService = new kplus . ServiceAccount ( chart , 'AWS' ); // give access to the aws creds secret. awsService . addSecret ( awsCreds );","title":"Allowing access to secrets"},{"location":"plus/service/","text":"Service \u00b6 Use services when you want to expose a set of pods using a stable network identity. They can also be used for externalizing endpoints to clients outside of the kubernetes cluster. API Reference Selectors \u00b6 Services must be configured with selectors that tell it which pods should it serve. The most common selector method is using labels. import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-22' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const frontends = new kplus . Service ( chart , 'FrontEnds' ); // this will cause the service to select all pods with the 'run: frontend' label. frontends . selectByLabel ( 'run' , 'frontend' ) Ports \u00b6 Ports that the service will listen and redirect to can be configured like so: import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-22' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const frontends = new kplus . Service ( chart , 'FrontEnds' ); // make the service bind to port 9000 and redirect to port 80 on the associated containers. frontends . serve ({ port : 9000 , targetPort : 80 )","title":"Service"},{"location":"plus/service/#service","text":"Use services when you want to expose a set of pods using a stable network identity. They can also be used for externalizing endpoints to clients outside of the kubernetes cluster. API Reference","title":"Service"},{"location":"plus/service/#selectors","text":"Services must be configured with selectors that tell it which pods should it serve. The most common selector method is using labels. import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-22' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const frontends = new kplus . Service ( chart , 'FrontEnds' ); // this will cause the service to select all pods with the 'run: frontend' label. frontends . selectByLabel ( 'run' , 'frontend' )","title":"Selectors"},{"location":"plus/service/#ports","text":"Ports that the service will listen and redirect to can be configured like so: import * as k from 'cdk8s' ; import * as kplus from 'cdk8s-plus-22' ; const app = new k . App (); const chart = new k . Chart ( app , 'Chart' ); const frontends = new kplus . Service ( chart , 'FrontEnds' ); // make the service bind to port 9000 and redirect to port 80 on the associated containers. frontends . serve ({ port : 9000 , targetPort : 80 )","title":"Ports"},{"location":"plus/volume/","text":"Volume \u00b6 Volume represents a named volume in a pod that may be accessed by any container in the pod. API Reference Create from a ConfigMap \u00b6 A very useful operation is to create a volume from a ConfigMap . Kubernetes will translate every key in the config map to a file, who\u2019s content is the value of the key. import * as kplus from 'cdk8s-plus-22' ; const configMap = kplus . ConfigMap . fromConfigMapName ( 'redis-config' ); const configVolume = kplus . Volume . fromConfigMap ( configMap ); Create from an EmptyDir \u00b6 The easiest way to allocate some persistent storage to your container is to create a volume from an empty directory. This volume, as the name suggests, is initially empty, and can be written to by containers who mount it. The data in the volume is preserved throughout the lifecycle of the pod, but is deleted forever as soon as the pod itself is removed. import * as kplus from 'cdk8s-plus-22' ; const data = kplus . Volume . fromEmptyDir ( configMap ); const pod = new kplus . Pod ( this , 'Pod' ); const redis = pod . addContainer ({ image : 'redis' }) // mount to the redis container. redis . mount ( '/var/lib/redis' , data );","title":"Volume"},{"location":"plus/volume/#volume","text":"Volume represents a named volume in a pod that may be accessed by any container in the pod. API Reference","title":"Volume"},{"location":"plus/volume/#create-from-a-configmap","text":"A very useful operation is to create a volume from a ConfigMap . Kubernetes will translate every key in the config map to a file, who\u2019s content is the value of the key. import * as kplus from 'cdk8s-plus-22' ; const configMap = kplus . ConfigMap . fromConfigMapName ( 'redis-config' ); const configVolume = kplus . Volume . fromConfigMap ( configMap );","title":"Create from a ConfigMap"},{"location":"plus/volume/#create-from-an-emptydir","text":"The easiest way to allocate some persistent storage to your container is to create a volume from an empty directory. This volume, as the name suggests, is initially empty, and can be written to by containers who mount it. The data in the volume is preserved throughout the lifecycle of the pod, but is deleted forever as soon as the pod itself is removed. import * as kplus from 'cdk8s-plus-22' ; const data = kplus . Volume . fromEmptyDir ( configMap ); const pod = new kplus . Pod ( this , 'Pod' ); const redis = pod . addContainer ({ image : 'redis' }) // mount to the redis container. redis . mount ( '/var/lib/redis' , data );","title":"Create from an EmptyDir"},{"location":"project/CHANGELOG/","text":"Changelog \u00b6 CDK8s is maintained via 3 repostories, each publishing their own modules. You can see each individual module changelog by visiting the releases page of each repository: cdk8s (Note that the cdk8s package is maintained in the cdk8s-team/cdk8s-core repository) cdk8s-cli cdk8s-plus","title":"Changelog"},{"location":"project/CHANGELOG/#changelog","text":"CDK8s is maintained via 3 repostories, each publishing their own modules. You can see each individual module changelog by visiting the releases page of each repository: cdk8s (Note that the cdk8s package is maintained in the cdk8s-team/cdk8s-core repository) cdk8s-cli cdk8s-plus","title":"Changelog"},{"location":"project/CONTRIBUTING/","text":"Contribution Guide \u00b6 cdk8s is licensed under Apache 2.0 and accepts contributions via GitHub pull requests. This document outlines some of the conventions on commit message formatting, contact points for developers, and other resources to help get contributions into cdk8s. You can contribute to cdk8s in many ways. Contributions of all shapes and sizes are welcome and celebrated: Reporting Issues Code Contributions RFCs We follows the CNCF Community Code of Conduct Reporting Issues \u00b6 If any part of the project has bugs or documentation mistakes, please let us know by raising an issue. We treat bugs and mistakes very seriously and believe no issue is too small. Before creating a bug report, please check that an issue reporting the same problem does not already exist. In addition, make sure you are submitting the issue to the correct repository. If you know your issue petains to a specific CDK8s package, it better belongs in the respective repository. For a list of the repositories, see Repositories An issue can either be a bug report or a feature-request . If you wish to ask a question or seek guidance, please consider one of the other support channels . Bug reports \u00b6 To make the bug report accurate and easy to understand, please try to create bug reports that are: Specific : Include as much details as possible: which version, what environment, what configuration, etc. Reproducible : Include the steps to reproduce the problem. We understand some issues might be hard to reproduce, please includes the steps that might lead to the problem. If possible, please provide a minimal code snippet that reproduces the bug. Isolated : Please try to isolate and reproduce the bug with minimum dependencies. It would significantly slow down the speed to fix a bug if too many dependencies are involved in a bug report. Unique : Do not duplicate existing bug report. Scoped : One bug per report. Do not follow up with another bug inside one report. We might ask for further information to locate a bug. A duplicated bug report will be closed. Submit a bug report here . Feature Requests \u00b6 We also accept suggestions for new features or missing capabilities as GitHub issues. The most important aspect of a suggestion issue is to provide as many details as possible about your use case and less focus on the solution. It is usually possible to support different use cases in many different ways, and we need to understand the motivation before we dive into a solution. If you wish to suggest a major change to the project, please consider to submit an RFC instead of a simple issue. An RFC also starts with a GitHub issue. Submit a suggestion here Code Contributions \u00b6 The general workflow for code contributions: Submit/find an issue in this repository Clone the relevant repo Make your code change Write tests & update docs Build & test locally Submit a pull request (Iterate) Your PR will be approved and merged Tracking issue \u00b6 All pull requests should be tracked with a GitHub issue. You should search for an existing issue or raise a new bug or suggestion . Add a comment indicating you are willing to pick it up in order to ensure no one else is currently working on it. If this is a major contribution, consider submitting an RFC to obtain feedback from the community and maintainers. Repositories \u00b6 This project consists of multiple modules, maintained and released via the following repositories: cdk8s-cli : command-line interface cdk8s-core : core library cdk8s-plus : high-level constructs for Kubernetes core. Development environment \u00b6 Prerequisites: Node.js >= 12.14.0 yarn >= 1.22.0 Prepare your environment: Fork the relevant repo and obtain a local clone. Install all dependencies: yarn install Run yarn build to build all modules. Unit tests \u00b6 Unit tests are located under the test/ directory within each module and use the jest framework. To run unit tests, execute yarn test either from the root of the repo (to unit test all modules) or from individual module directories: yarn test Out tests utilize jest snapshot testing . In case a snapshot needs to be updated, just run: yarn test -u Integration Tests \u00b6 Integration tests are executed against the latest published modules . This means that in order to execute integration tests against a development version, you\u2019lol need to yarn link your local version to this repository (all deps are at the root): $ cd cdk8s-core $ yarn link $ cd ../cdk8s $ yarn link cdk8s Now, you can run integration tests via: yarn integ Our integration tests also utilize snapshot testing. To update integration test snapshots, run: yarn integ:update Running Integration Tests \u00b6 The test directory contains integration tests for the cdk8s project. Each subdirectory represents a single test, with an entrypoint of test.sh . Tests are written as simple shell scripts and can simulate user activity. You can either run individual tests by executing their entrypoint directly (e.g. test-python-app/test.sh ) or run all tests by executing the script ./test-all.sh . Writing Integration Tests \u00b6 Create a new subdirectory with a test- prefix. Create a file named test.sh , make it executable. Test Environment: The script test.sh is executed within a temporary working directory under /tmp/xxxx/test (where xxxx is some random tmp file). See existing tests as examples on how to bring in auxiliary files to the test. Test MUST NOT install any dependencies or the cdk8s CLI. They can expect it to be available in the environment. To install dependencies from package managers, use yarn , npm , pipenv , mvn and nuget . Those programs will be shimmed to allow consuming local dependencies. Snapshot Testing \u00b6 Some integration tests utilize a simple snapshot testing mechanism. To update snapshots, run tests with: UPDATE_SNAPSHOTS=1 Or, run this from the root of the repo: yarn integ:update Docker environment for integration tests \u00b6 Due to the polyglot nature of the jsii tools used by cdk8s, the toolchain requirements are somewhat more complicated than for most projects. To help with this, you can use the jsii/superchain docker image that includes all the required tools. In order to get an interactive shell within a superchain container you can use the following command. docker run --rm --net=host -it -v $PWD:$PWD -w $PWD jsii/superchain Then once in the docker shell, you can package and execute the tests as normal. $ pip install pipenv # Currently not included in jsii docker image $ yarn build $ yarn run package $ yarn integ:update Note: this may leave some files owned as the docker root user id. These will need to be cleaned up manually. Pull Requests \u00b6 We use the PR title when we automatically generate the change log for each release. Therefore please following these guidelines to the letter: PR title : Must adhere to conventional commits . All lowercase with no period at the end of the title If this is a fix (bug) the title should describe the bug If this is a feat (feature) the title should describe the feature PR description : Describe how did you fix the bug or what changes you had to make in order to implement the feature Indicate fixes #NNN or resolves #NNN with the tracking issue number. If you had to test your change manually, describe how you tested it and paste the test results. If this is a breaking change, the last paragraph should describe the breaking change with the prefix BREAKING CHANGE: xxxxxx . Developer Certificate Of Origin (DCO) \u00b6 Every commit should be signed-off in compliance with the Developer Certificate Of Origin . You can sign your commits by using the git commit -s command. To configure automatic signoff, see git-hooks . Documentation \u00b6 Documentation is rendered from markdown using mkdocs-material and sourced from the docs directory. API documentation for cdk8s and all cdk8s-plus-* packages is auto-generated from inline docstrings during build. To test locally, install python3 deps: pip3 install -r docs/requirements.txt And then: mkdocs serve This will serve a local web server with the website. A good reference for syntax and capabilities is the mkdocs-material website. Examples \u00b6 Examples are stored under examples and organized according to programming language. Every example also has an entry under docs/examples/xxx which describes the example and includes links to the source code (on the main branch). RFCs \u00b6 An RFC (request for comments) is a document that proposes and details a change or addition to cdk8s. It also is a process for reviewing and discussing the proposal and tracking its implementation. \u201cRequest for comments\u201d means a request for discussion and oversight about the future of cdk8s from contributors and users. It is an open forum for suggestions, questions, and feedback. To create an RFC follow this process: Create an [issue][https://github.com/cdk8s-team/cdk8s/issues/new?assignees=&labels=enhancement&template=rfc.md&title=%5BRFC%5D+describe+your+RFC] which will be the tracking issue for this RFC. Title should represent the title of the RFC. Description should provide the motivation for the RFC. Create a markdown file based off of rfc/0000-template.md under the rfc/<nnnn>-<title-of-rfc> where <nnnn> is the tracking issue number and <title-of-rfc> is a symbolic name for the title. For example: rfc/0030-construct-operators.md . File a pull request with this markdown file. The title of the PR should indicate rfc: <nnnn> <same as issue title> . The RFC will be reviewed as a pull request and once merged it means it is ready for implementation. Community Meeting \u00b6 Join us for the CDK8s community meeting which takes place the 2nd Monday of the month at 9:00am Pacific Time . Meeting link: https://chime.aws/7929414778 Agenda Portions of this guide were adopted from the contribution guides of the AWS CDK and etcd .","title":"Contribution Guide"},{"location":"project/CONTRIBUTING/#contribution-guide","text":"cdk8s is licensed under Apache 2.0 and accepts contributions via GitHub pull requests. This document outlines some of the conventions on commit message formatting, contact points for developers, and other resources to help get contributions into cdk8s. You can contribute to cdk8s in many ways. Contributions of all shapes and sizes are welcome and celebrated: Reporting Issues Code Contributions RFCs We follows the CNCF Community Code of Conduct","title":"Contribution Guide"},{"location":"project/CONTRIBUTING/#reporting-issues","text":"If any part of the project has bugs or documentation mistakes, please let us know by raising an issue. We treat bugs and mistakes very seriously and believe no issue is too small. Before creating a bug report, please check that an issue reporting the same problem does not already exist. In addition, make sure you are submitting the issue to the correct repository. If you know your issue petains to a specific CDK8s package, it better belongs in the respective repository. For a list of the repositories, see Repositories An issue can either be a bug report or a feature-request . If you wish to ask a question or seek guidance, please consider one of the other support channels .","title":"Reporting Issues"},{"location":"project/CONTRIBUTING/#bug-reports","text":"To make the bug report accurate and easy to understand, please try to create bug reports that are: Specific : Include as much details as possible: which version, what environment, what configuration, etc. Reproducible : Include the steps to reproduce the problem. We understand some issues might be hard to reproduce, please includes the steps that might lead to the problem. If possible, please provide a minimal code snippet that reproduces the bug. Isolated : Please try to isolate and reproduce the bug with minimum dependencies. It would significantly slow down the speed to fix a bug if too many dependencies are involved in a bug report. Unique : Do not duplicate existing bug report. Scoped : One bug per report. Do not follow up with another bug inside one report. We might ask for further information to locate a bug. A duplicated bug report will be closed. Submit a bug report here .","title":"Bug reports"},{"location":"project/CONTRIBUTING/#feature-requests","text":"We also accept suggestions for new features or missing capabilities as GitHub issues. The most important aspect of a suggestion issue is to provide as many details as possible about your use case and less focus on the solution. It is usually possible to support different use cases in many different ways, and we need to understand the motivation before we dive into a solution. If you wish to suggest a major change to the project, please consider to submit an RFC instead of a simple issue. An RFC also starts with a GitHub issue. Submit a suggestion here","title":"Feature Requests"},{"location":"project/CONTRIBUTING/#code-contributions","text":"The general workflow for code contributions: Submit/find an issue in this repository Clone the relevant repo Make your code change Write tests & update docs Build & test locally Submit a pull request (Iterate) Your PR will be approved and merged","title":"Code Contributions"},{"location":"project/CONTRIBUTING/#tracking-issue","text":"All pull requests should be tracked with a GitHub issue. You should search for an existing issue or raise a new bug or suggestion . Add a comment indicating you are willing to pick it up in order to ensure no one else is currently working on it. If this is a major contribution, consider submitting an RFC to obtain feedback from the community and maintainers.","title":"Tracking issue"},{"location":"project/CONTRIBUTING/#repositories","text":"This project consists of multiple modules, maintained and released via the following repositories: cdk8s-cli : command-line interface cdk8s-core : core library cdk8s-plus : high-level constructs for Kubernetes core.","title":"Repositories"},{"location":"project/CONTRIBUTING/#development-environment","text":"Prerequisites: Node.js >= 12.14.0 yarn >= 1.22.0 Prepare your environment: Fork the relevant repo and obtain a local clone. Install all dependencies: yarn install Run yarn build to build all modules.","title":"Development environment"},{"location":"project/CONTRIBUTING/#unit-tests","text":"Unit tests are located under the test/ directory within each module and use the jest framework. To run unit tests, execute yarn test either from the root of the repo (to unit test all modules) or from individual module directories: yarn test Out tests utilize jest snapshot testing . In case a snapshot needs to be updated, just run: yarn test -u","title":"Unit tests"},{"location":"project/CONTRIBUTING/#integration-tests","text":"Integration tests are executed against the latest published modules . This means that in order to execute integration tests against a development version, you\u2019lol need to yarn link your local version to this repository (all deps are at the root): $ cd cdk8s-core $ yarn link $ cd ../cdk8s $ yarn link cdk8s Now, you can run integration tests via: yarn integ Our integration tests also utilize snapshot testing. To update integration test snapshots, run: yarn integ:update","title":"Integration Tests"},{"location":"project/CONTRIBUTING/#pull-requests","text":"We use the PR title when we automatically generate the change log for each release. Therefore please following these guidelines to the letter: PR title : Must adhere to conventional commits . All lowercase with no period at the end of the title If this is a fix (bug) the title should describe the bug If this is a feat (feature) the title should describe the feature PR description : Describe how did you fix the bug or what changes you had to make in order to implement the feature Indicate fixes #NNN or resolves #NNN with the tracking issue number. If you had to test your change manually, describe how you tested it and paste the test results. If this is a breaking change, the last paragraph should describe the breaking change with the prefix BREAKING CHANGE: xxxxxx .","title":"Pull Requests"},{"location":"project/CONTRIBUTING/#documentation","text":"Documentation is rendered from markdown using mkdocs-material and sourced from the docs directory. API documentation for cdk8s and all cdk8s-plus-* packages is auto-generated from inline docstrings during build. To test locally, install python3 deps: pip3 install -r docs/requirements.txt And then: mkdocs serve This will serve a local web server with the website. A good reference for syntax and capabilities is the mkdocs-material website.","title":"Documentation"},{"location":"project/CONTRIBUTING/#examples","text":"Examples are stored under examples and organized according to programming language. Every example also has an entry under docs/examples/xxx which describes the example and includes links to the source code (on the main branch).","title":"Examples"},{"location":"project/CONTRIBUTING/#rfcs","text":"An RFC (request for comments) is a document that proposes and details a change or addition to cdk8s. It also is a process for reviewing and discussing the proposal and tracking its implementation. \u201cRequest for comments\u201d means a request for discussion and oversight about the future of cdk8s from contributors and users. It is an open forum for suggestions, questions, and feedback. To create an RFC follow this process: Create an [issue][https://github.com/cdk8s-team/cdk8s/issues/new?assignees=&labels=enhancement&template=rfc.md&title=%5BRFC%5D+describe+your+RFC] which will be the tracking issue for this RFC. Title should represent the title of the RFC. Description should provide the motivation for the RFC. Create a markdown file based off of rfc/0000-template.md under the rfc/<nnnn>-<title-of-rfc> where <nnnn> is the tracking issue number and <title-of-rfc> is a symbolic name for the title. For example: rfc/0030-construct-operators.md . File a pull request with this markdown file. The title of the PR should indicate rfc: <nnnn> <same as issue title> . The RFC will be reviewed as a pull request and once merged it means it is ready for implementation.","title":"RFCs"},{"location":"project/CONTRIBUTING/#community-meeting","text":"Join us for the CDK8s community meeting which takes place the 2nd Monday of the month at 9:00am Pacific Time . Meeting link: https://chime.aws/7929414778 Agenda Portions of this guide were adopted from the contribution guides of the AWS CDK and etcd .","title":"Community Meeting"},{"location":"project/ROADMAP/","text":"Roadmap \u00b6 To see items we are working on, visit our RoadMap GitHub project . You can submit an idea here .","title":"Roadmap"},{"location":"project/ROADMAP/#roadmap","text":"To see items we are working on, visit our RoadMap GitHub project . You can submit an idea here .","title":"Roadmap"},{"location":"reference/","text":"Overview \u00b6 This section includes API reference for the various components of CDK8s: cdk8s : Core library TypeScript Python Java Go cdk8s-plus-22 : Intent-based APIs for Kubernetes resources. (spec version 1.22.0 ) TypeScript Python Java Go cdk8s-plus-21 : Intent-based APIs for Kubernetes resources. (spec version 1.21.0 ) TypeScript Python Java Go cdk8s-plus-20 : Intent-based APIs for Kubernetes resources. (spec version 1.20.0 ) TypeScript Python Java Go cdk8s-plus-17 : Intent-based APIs for Kubernetes resources. (spec version 1.17.0 ) TypeScript Python Java Go","title":"Overview"},{"location":"reference/#overview","text":"This section includes API reference for the various components of CDK8s: cdk8s : Core library TypeScript Python Java Go cdk8s-plus-22 : Intent-based APIs for Kubernetes resources. (spec version 1.22.0 ) TypeScript Python Java Go cdk8s-plus-21 : Intent-based APIs for Kubernetes resources. (spec version 1.21.0 ) TypeScript Python Java Go cdk8s-plus-20 : Intent-based APIs for Kubernetes resources. (spec version 1.20.0 ) TypeScript Python Java Go cdk8s-plus-17 : Intent-based APIs for Kubernetes resources. (spec version 1.17.0 ) TypeScript Python Java Go","title":"Overview"},{"location":"reference/cdk8s/go/","text":"cdk8s (Go) \u00b6 For Go API reference, please visit https://pkg.go.dev/github.com/cdk8s-team/cdk8s-core-go/cdk8s .","title":"Go"},{"location":"reference/cdk8s/go/#cdk8s-go","text":"For Go API reference, please visit https://pkg.go.dev/github.com/cdk8s-team/cdk8s-core-go/cdk8s .","title":"cdk8s (Go) "},{"location":"reference/cdk8s/java/","text":"cdk8s (Java) \u00b6 Constructs \u00b6 ApiObject \u00b6 Initializers \u00b6 import org.cdk8s.ApiObject ; ApiObject . Builder . create ( Construct scope , java . lang . String id ) . apiVersion ( java . lang . String ) . kind ( java . lang . String ) // .metadata(ApiObjectMetadata) . build (); scope Required \u00b6 Type: software.constructs.Construct the construct scope. id Required \u00b6 Type: java.lang.String namespace. apiVersion Required \u00b6 Type: java.lang.String API version. kind Required \u00b6 Type: java.lang.String Resource kind. metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Object metadata. If name is not specified, an app-unique name will be allocated by the framework based on the path of the construct within thes construct tree. Methods \u00b6 addDependency \u00b6 public addDependency ( IConstruct dependencies ) dependencies Required \u00b6 Type: software.constructs.IConstruct the dependencies to add. addJsonPatch \u00b6 public addJsonPatch ( JsonPatch ops ) ops Required \u00b6 Type: org.cdk8s.JsonPatch The JSON-Patch operations to apply. toJson \u00b6 public toJson () Static Functions \u00b6 of \u00b6 import org.cdk8s.ApiObject ; ApiObject . of ( IConstruct c ) c Required \u00b6 Type: software.constructs.IConstruct The higher-level construct. Properties \u00b6 apiGroup Required \u00b6 public java . lang . String getApiGroup (); Type: java.lang.String The group portion of the API version (e.g. authorization.k8s.io ). apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. authorization.k8s.io/v1 ). chart Required \u00b6 public Chart getChart (); Type: org.cdk8s.Chart The chart in which this object is defined. kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind. metadata Required \u00b6 public ApiObjectMetadataDefinition getMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition Metadata associated with this API object. name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The name of the API object. If a name is specified in metadata.name this will be the name returned. Otherwise, a name will be generated by calling Chart.of(this).generatedObjectName(this) , which by default uses the construct path to generate a DNS-compatible name for the resource. App \u00b6 Represents a cdk8s application. Initializers \u00b6 import org.cdk8s.App ; App . Builder . create () // .outdir(java.lang.String) // .yamlOutputType(YamlOutputType) . build (); outdir Optional \u00b6 Type: java.lang.String Default: CDK8S_OUTDIR if defined, otherwise \u201cdist\u201d The directory to output Kubernetes manifests. yamlOutputType Optional \u00b6 Type: org.cdk8s.YamlOutputType Default: YamlOutputType.FILE_PER_CHART How to divide the YAML output into files. Methods \u00b6 synth \u00b6 public synth () synthYaml \u00b6 public synthYaml () Properties \u00b6 charts Required \u00b6 public java . util . List < Chart > getCharts (); Type: java.util.List< org.cdk8s.Chart > Returns all the charts in this app, sorted topologically. outdir Required \u00b6 public java . lang . String getOutdir (); Type: java.lang.String The output directory into which manifests will be synthesized. yamlOutputType Required \u00b6 public YamlOutputType getYamlOutputType (); Type: org.cdk8s.YamlOutputType Default: YamlOutputType.FILE_PER_CHART How to divide the YAML output into files. Chart \u00b6 Initializers \u00b6 import org.cdk8s.Chart ; Chart . Builder . create ( Construct scope , java . lang . String id ) // .labels(java.util.Map<java.lang.String, java.lang.String>) // .namespace(java.lang.String) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String labels Optional \u00b6 Type: java.util.Map java.lang.String > Default: no common labels Labels to apply to all resources in this chart. namespace Optional \u00b6 Type: java.lang.String Default: no namespace is synthesized (usually this implies \u201cdefault\u201d) The default namespace for all objects defined in this chart (directly or indirectly). This namespace will only apply to objects that don\u2019t have a namespace explicitly defined for them. Methods \u00b6 addDependency \u00b6 public addDependency ( IConstruct dependencies ) dependencies Required \u00b6 Type: software.constructs.IConstruct the dependencies to add. generateObjectName \u00b6 public generateObjectName ( ApiObject apiObject ) apiObject Required \u00b6 Type: org.cdk8s.ApiObject The API object to generate a name for. toJson \u00b6 public toJson () Static Functions \u00b6 of \u00b6 import org.cdk8s.Chart ; Chart . of ( IConstruct c ) c Required \u00b6 Type: software.constructs.IConstruct a construct node. Properties \u00b6 labels Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getLabels (); Type: java.util.Map java.lang.String > Labels applied to all resources in this chart. This is an immutable copy. namespace Optional \u00b6 public java . lang . String getNamespace (); Type: java.lang.String The default namespace for all objects in this chart. Helm \u00b6 Represents a Helm deployment. Use this construct to import an existing Helm chart and incorporate it into your constructs. Initializers \u00b6 import org.cdk8s.Helm ; Helm . Builder . create ( Construct scope , java . lang . String id ) . chart ( java . lang . String ) // .helmExecutable(java.lang.String) // .helmFlags(java.util.List<java.lang.String>) // .releaseName(java.lang.String) // .values(java.util.Map<java.lang.String, java.lang.Object>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String chart Required \u00b6 Type: java.lang.String The chart name to use. It can be a chart from a helm repository or a local directory. This name is passed to helm template and has all the relevant semantics. helmExecutable Optional \u00b6 Type: java.lang.String Default: \u201chelm\u201d The local helm executable to use in order to create the manifest the chart. helmFlags Optional \u00b6 Type: java.util.List< java.lang.String > Default: [] Additional flags to add to the helm execution. releaseName Optional \u00b6 Type: java.lang.String Default: if unspecified, a name will be allocated based on the construct path The release name. https://helm.sh/docs/intro/using_helm/#three-big-concepts values Optional \u00b6 Type: java.util.Map java.lang.Object > Default: If no values are specified, chart will use the defaults. Values to pass to the chart. Properties \u00b6 releaseName Required \u00b6 public java . lang . String getReleaseName (); Type: java.lang.String The helm release name. Include \u00b6 Reads a YAML manifest from a file or a URL and defines all resources as API objects within the defined scope. The names ( metadata.name ) of imported resources will be preserved as-is from the manifest. Initializers \u00b6 import org.cdk8s.Include ; Include . Builder . create ( Construct scope , java . lang . String id ) . url ( java . lang . String ) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String url Required \u00b6 Type: java.lang.String Local file path or URL which includes a Kubernetes YAML manifest. Properties \u00b6 apiObjects Required \u00b6 public java . util . List < ApiObject > getApiObjects (); Type: java.util.List< org.cdk8s.ApiObject > Returns all the included API objects. Structs \u00b6 ApiObjectMetadata \u00b6 Metadata associated with this object. Initializer \u00b6 import org.cdk8s.ApiObjectMetadata ; ApiObjectMetadata . builder () // .annotations(java.util.Map<java.lang.String, java.lang.String>) // .finalizers(java.util.List<java.lang.String>) // .labels(java.util.Map<java.lang.String, java.lang.String>) // .name(java.lang.String) // .namespace(java.lang.String) // .ownerReferences(java.util.List<OwnerReference>) . build (); annotations Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getAnnotations (); Type: java.util.Map java.lang.String > Default: No annotations. Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. http://kubernetes.io/docs/user-guide/annotations finalizers Optional \u00b6 public java . util . List < java . lang . String > getFinalizers (); Type: java.util.List< java.lang.String > Default: No finalizers. Namespaced keys that tell Kubernetes to wait until specific conditions are met before it fully deletes resources marked for deletion. Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order. Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list. https://kubernetes.io/docs/concepts/overview/working-with-objects/finalizers/ labels Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getLabels (); Type: java.util.Map java.lang.String > Default: No labels. Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. http://kubernetes.io/docs/user-guide/labels name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: an app-unique name generated by the chart The unique, namespace-global, name of this object inside the Kubernetes cluster. Normally, you shouldn\u2019t specify names for objects and let the CDK generate a name for you that is application-unique. The names CDK generates are composed from the construct path components, separated by dots and a suffix that is based on a hash of the entire path, to ensure uniqueness. You can supply custom name allocation logic by overriding the chart.generateObjectName method. If you use an explicit name here, bear in mind that this reduces the composability of your construct because it won\u2019t be possible to include more than one instance in any app. Therefore it is highly recommended to leave this unspecified. namespace Optional \u00b6 public java . lang . String getNamespace (); Type: java.lang.String Default: undefined (will be assigned to the \u2018default\u2019 namespace) Namespace defines the space within each name must be unique. An empty namespace is equivalent to the \u201cdefault\u201d namespace, but \u201cdefault\u201d is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty. Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces ownerReferences Optional \u00b6 public java . util . List < OwnerReference > getOwnerReferences (); Type: java.util.List< org.cdk8s.OwnerReference > Default: automatically set by Kubernetes List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller. Kubernetes sets the value of this field automatically for objects that are dependents of other objects like ReplicaSets, DaemonSets, Deployments, Jobs and CronJobs, and ReplicationControllers. You can also configure these relationships manually by changing the value of this field. However, you usually don\u2019t need to and can allow Kubernetes to automatically manage the relationships. https://kubernetes.io/docs/concepts/overview/working-with-objects/owners-dependents/ ApiObjectProps \u00b6 Options for defining API objects. Initializer \u00b6 import org.cdk8s.ApiObjectProps ; ApiObjectProps . builder () . apiVersion ( java . lang . String ) . kind ( java . lang . String ) // .metadata(ApiObjectMetadata) . build (); apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String API version. kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String Resource kind. metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Object metadata. If name is not specified, an app-unique name will be allocated by the framework based on the path of the construct within thes construct tree. AppProps \u00b6 Initializer \u00b6 import org.cdk8s.AppProps ; AppProps . builder () // .outdir(java.lang.String) // .yamlOutputType(YamlOutputType) . build (); outdir Optional \u00b6 public java . lang . String getOutdir (); Type: java.lang.String Default: CDK8S_OUTDIR if defined, otherwise \u201cdist\u201d The directory to output Kubernetes manifests. yamlOutputType Optional \u00b6 public YamlOutputType getYamlOutputType (); Type: org.cdk8s.YamlOutputType Default: YamlOutputType.FILE_PER_CHART How to divide the YAML output into files. ChartProps \u00b6 Initializer \u00b6 import org.cdk8s.ChartProps ; ChartProps . builder () // .labels(java.util.Map<java.lang.String, java.lang.String>) // .namespace(java.lang.String) . build (); labels Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getLabels (); Type: java.util.Map java.lang.String > Default: no common labels Labels to apply to all resources in this chart. namespace Optional \u00b6 public java . lang . String getNamespace (); Type: java.lang.String Default: no namespace is synthesized (usually this implies \u201cdefault\u201d) The default namespace for all objects defined in this chart (directly or indirectly). This namespace will only apply to objects that don\u2019t have a namespace explicitly defined for them. GroupVersionKind \u00b6 Initializer \u00b6 import org.cdk8s.GroupVersionKind ; GroupVersionKind . builder () . apiVersion ( java . lang . String ) . kind ( java . lang . String ) . build (); apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String The object\u2019s API version (e.g. authorization.k8s.io/v1 ). kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String The object kind. HelmProps \u00b6 Options for Helm . Initializer \u00b6 import org.cdk8s.HelmProps ; HelmProps . builder () . chart ( java . lang . String ) // .helmExecutable(java.lang.String) // .helmFlags(java.util.List<java.lang.String>) // .releaseName(java.lang.String) // .values(java.util.Map<java.lang.String, java.lang.Object>) . build (); chart Required \u00b6 public java . lang . String getChart (); Type: java.lang.String The chart name to use. It can be a chart from a helm repository or a local directory. This name is passed to helm template and has all the relevant semantics. helmExecutable Optional \u00b6 public java . lang . String getHelmExecutable (); Type: java.lang.String Default: \u201chelm\u201d The local helm executable to use in order to create the manifest the chart. helmFlags Optional \u00b6 public java . util . List < java . lang . String > getHelmFlags (); Type: java.util.List< java.lang.String > Default: [] Additional flags to add to the helm execution. releaseName Optional \u00b6 public java . lang . String getReleaseName (); Type: java.lang.String Default: if unspecified, a name will be allocated based on the construct path The release name. https://helm.sh/docs/intro/using_helm/#three-big-concepts values Optional \u00b6 public java . util . Map < java . lang . String , java . lang . Object > getValues (); Type: java.util.Map java.lang.Object > Default: If no values are specified, chart will use the defaults. Values to pass to the chart. IncludeProps \u00b6 Initializer \u00b6 import org.cdk8s.IncludeProps ; IncludeProps . builder () . url ( java . lang . String ) . build (); url Required \u00b6 public java . lang . String getUrl (); Type: java.lang.String Local file path or URL which includes a Kubernetes YAML manifest. NameOptions \u00b6 Options for name generation. Initializer \u00b6 import org.cdk8s.NameOptions ; NameOptions . builder () // .delimiter(java.lang.String) // .extra(java.util.List<java.lang.String>) // .includeHash(java.lang.Boolean) // .maxLen(java.lang.Number) . build (); delimiter Optional \u00b6 public java . lang . String getDelimiter (); Type: java.lang.String Default: \u201c-\u201c Delimiter to use between components. extra Optional \u00b6 public java . util . List < java . lang . String > getExtra (); Type: java.util.List< java.lang.String > Default: [] use the construct path components Extra components to include in the name. includeHash Optional \u00b6 public java . lang . Boolean getIncludeHash (); Type: java.lang.Boolean Default: true Include a short hash as last part of the name. maxLen Optional \u00b6 public java . lang . Number getMaxLen (); Type: java.lang.Number Default: 63 Maximum allowed length for the name. OwnerReference \u00b6 OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field. Initializer \u00b6 import org.cdk8s.OwnerReference ; OwnerReference . builder () . apiVersion ( java . lang . String ) . kind ( java . lang . String ) . name ( java . lang . String ) . uid ( java . lang . String ) // .blockOwnerDeletion(java.lang.Boolean) // .controller(java.lang.Boolean) . build (); apiVersion Required \u00b6 public java . lang . String getApiVersion (); Type: java.lang.String API version of the referent. kind Required \u00b6 public java . lang . String getKind (); Type: java.lang.String Kind of the referent. https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds name Required \u00b6 public java . lang . String getName (); Type: java.lang.String Name of the referent. http://kubernetes.io/docs/user-guide/identifiers#names uid Required \u00b6 public java . lang . String getUid (); Type: java.lang.String UID of the referent. http://kubernetes.io/docs/user-guide/identifiers#uids blockOwnerDeletion Optional \u00b6 public java . lang . Boolean getBlockOwnerDeletion (); Type: java.lang.Boolean Default: false. To set this field, a user needs \u201cdelete\u201d permission of the owner, otherwise 422 (Unprocessable Entity) will be returned. If true, AND if the owner has the \u201cforegroundDeletion\u201d finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. Defaults to false. To set this field, a user needs \u201cdelete\u201d permission of the owner, otherwise 422 (Unprocessable Entity) will be returned. controller Optional \u00b6 public java . lang . Boolean getController (); Type: java.lang.Boolean If true, this reference points to the managing controller. SizeConversionOptions \u00b6 Options for how to convert time to a different unit. Initializer \u00b6 import org.cdk8s.SizeConversionOptions ; SizeConversionOptions . builder () // .rounding(SizeRoundingBehavior) . build (); rounding Optional \u00b6 public SizeRoundingBehavior getRounding (); Type: org.cdk8s.SizeRoundingBehavior Default: SizeRoundingBehavior.FAIL How conversions should behave when it encounters a non-integer result. TimeConversionOptions \u00b6 Options for how to convert time to a different unit. Initializer \u00b6 import org.cdk8s.TimeConversionOptions ; TimeConversionOptions . builder () // .integral(java.lang.Boolean) . build (); integral Optional \u00b6 public java . lang . Boolean getIntegral (); Type: java.lang.Boolean Default: true If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. Classes \u00b6 ApiObjectMetadataDefinition \u00b6 Object metadata. Initializers \u00b6 import org.cdk8s.ApiObjectMetadataDefinition ; ApiObjectMetadataDefinition . Builder . create () // .annotations(java.util.Map<java.lang.String, java.lang.String>) // .finalizers(java.util.List<java.lang.String>) // .labels(java.util.Map<java.lang.String, java.lang.String>) // .name(java.lang.String) // .namespace(java.lang.String) // .ownerReferences(java.util.List<OwnerReference>) . build (); annotations Optional \u00b6 Type: java.util.Map java.lang.String > Default: No annotations. Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. http://kubernetes.io/docs/user-guide/annotations finalizers Optional \u00b6 Type: java.util.List< java.lang.String > Default: No finalizers. Namespaced keys that tell Kubernetes to wait until specific conditions are met before it fully deletes resources marked for deletion. Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order. Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list. https://kubernetes.io/docs/concepts/overview/working-with-objects/finalizers/ labels Optional \u00b6 Type: java.util.Map java.lang.String > Default: No labels. Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. http://kubernetes.io/docs/user-guide/labels name Optional \u00b6 Type: java.lang.String Default: an app-unique name generated by the chart The unique, namespace-global, name of this object inside the Kubernetes cluster. Normally, you shouldn\u2019t specify names for objects and let the CDK generate a name for you that is application-unique. The names CDK generates are composed from the construct path components, separated by dots and a suffix that is based on a hash of the entire path, to ensure uniqueness. You can supply custom name allocation logic by overriding the chart.generateObjectName method. If you use an explicit name here, bear in mind that this reduces the composability of your construct because it won\u2019t be possible to include more than one instance in any app. Therefore it is highly recommended to leave this unspecified. namespace Optional \u00b6 Type: java.lang.String Default: undefined (will be assigned to the \u2018default\u2019 namespace) Namespace defines the space within each name must be unique. An empty namespace is equivalent to the \u201cdefault\u201d namespace, but \u201cdefault\u201d is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty. Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces ownerReferences Optional \u00b6 Type: java.util.List< org.cdk8s.OwnerReference > Default: automatically set by Kubernetes List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller. Kubernetes sets the value of this field automatically for objects that are dependents of other objects like ReplicaSets, DaemonSets, Deployments, Jobs and CronJobs, and ReplicationControllers. You can also configure these relationships manually by changing the value of this field. However, you usually don\u2019t need to and can allow Kubernetes to automatically manage the relationships. https://kubernetes.io/docs/concepts/overview/working-with-objects/owners-dependents/ Methods \u00b6 add \u00b6 public add ( java . lang . String key , java . lang . Object value ) key Required \u00b6 Type: java.lang.String Metadata key. value Required \u00b6 Type: java.lang.Object Metadata value. addAnnotation \u00b6 public addAnnotation ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String The key. value Required \u00b6 Type: java.lang.String The value. addFinalizers \u00b6 public addFinalizers ( java . lang . String finalizers ) finalizers Required \u00b6 Type: java.lang.String the finalizers. addLabel \u00b6 public addLabel ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String The key. value Required \u00b6 Type: java.lang.String The value. addOwnerReference \u00b6 public addOwnerReference ( OwnerReference owner ) owner Required \u00b6 Type: org.cdk8s.OwnerReference the owner. getLabel \u00b6 public getLabel ( java . lang . String key ) key Required \u00b6 Type: java.lang.String the label. toJson \u00b6 public toJson () Properties \u00b6 name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String The name of the API object. If a name is specified in metadata.name this will be the name returned. Otherwise, a name will be generated by calling Chart.of(this).generatedObjectName(this) , which by default uses the construct path to generate a DNS-compatible name for the resource. namespace Optional \u00b6 public java . lang . String getNamespace (); Type: java.lang.String The object\u2019s namespace. DependencyGraph \u00b6 Represents the dependency graph for a given Node. This graph includes the dependency relationships between all nodes in the node (construct) sub-tree who\u2019s root is this Node. Note that this means that lonely nodes (no dependencies and no dependants) are also included in this graph as childless children of the root node of the graph. The graph does not include cross-scope dependencies. That is, if a child on the current scope depends on a node from a different scope, that relationship is not represented in this graph. Initializers \u00b6 import org.cdk8s.DependencyGraph ; new DependencyGraph ( Node node ); node Required \u00b6 Type: software.constructs.Node Methods \u00b6 topology \u00b6 public topology () Properties \u00b6 root Required \u00b6 public DependencyVertex getRoot (); Type: org.cdk8s.DependencyVertex Returns the root of the graph. Note that this vertex will always have null as its .value since it is an artifical root that binds all the connected spaces of the graph. DependencyVertex \u00b6 Represents a vertex in the graph. The value of each vertex is an IConstruct that is accessible via the .value getter. Initializers \u00b6 import org.cdk8s.DependencyVertex ; new DependencyVertex (); new DependencyVertex ( IConstruct value ); value Optional \u00b6 Type: software.constructs.IConstruct Methods \u00b6 addChild \u00b6 public addChild ( DependencyVertex dep ) dep Required \u00b6 Type: org.cdk8s.DependencyVertex The dependency. topology \u00b6 public topology () Properties \u00b6 inbound Required \u00b6 public java . util . List < DependencyVertex > getInbound (); Type: java.util.List< org.cdk8s.DependencyVertex > Returns the parents of the vertex (i.e dependants). outbound Required \u00b6 public java . util . List < DependencyVertex > getOutbound (); Type: java.util.List< org.cdk8s.DependencyVertex > Returns the children of the vertex (i.e dependencies). value Optional \u00b6 public IConstruct getValue (); Type: software.constructs.IConstruct Returns the IConstruct this graph vertex represents. null in case this is the root of the graph. Duration \u00b6 Represents a length of time. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative. Methods \u00b6 toDays \u00b6 public toDays () public toDays ( TimeConversionOptions opts ) opts Optional \u00b6 Type: org.cdk8s.TimeConversionOptions toHours \u00b6 public toHours () public toHours ( TimeConversionOptions opts ) opts Optional \u00b6 Type: org.cdk8s.TimeConversionOptions toHumanString \u00b6 public toHumanString () toIsoString \u00b6 public toIsoString () toMilliseconds \u00b6 public toMilliseconds () public toMilliseconds ( TimeConversionOptions opts ) opts Optional \u00b6 Type: org.cdk8s.TimeConversionOptions toMinutes \u00b6 public toMinutes () public toMinutes ( TimeConversionOptions opts ) opts Optional \u00b6 Type: org.cdk8s.TimeConversionOptions toSeconds \u00b6 public toSeconds () public toSeconds ( TimeConversionOptions opts ) opts Optional \u00b6 Type: org.cdk8s.TimeConversionOptions Static Functions \u00b6 days \u00b6 import org.cdk8s.Duration ; Duration . days ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number the amount of Days the Duration will represent. hours \u00b6 import org.cdk8s.Duration ; Duration . hours ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number the amount of Hours the Duration will represent. millis \u00b6 import org.cdk8s.Duration ; Duration . millis ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number the amount of Milliseconds the Duration will represent. minutes \u00b6 import org.cdk8s.Duration ; Duration . minutes ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number the amount of Minutes the Duration will represent. parse \u00b6 import org.cdk8s.Duration ; Duration . parse ( java . lang . String duration ) duration Required \u00b6 Type: java.lang.String an ISO-formtted duration to be parsed. seconds \u00b6 import org.cdk8s.Duration ; Duration . seconds ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number the amount of Seconds the Duration will represent. JsonPatch \u00b6 Utility for applying RFC-6902 JSON-Patch to a document. Use the the JsonPatch.apply(doc, ...ops) function to apply a set of operations to a JSON document and return the result. Operations can be created using the factory methods JsonPatch.add() , JsonPatch.remove() , etc. Static Functions \u00b6 add \u00b6 import org.cdk8s.JsonPatch ; JsonPatch . add ( java . lang . String path , java . lang . Object value ) path Required \u00b6 Type: java.lang.String value Required \u00b6 Type: java.lang.Object apply \u00b6 import org.cdk8s.JsonPatch ; JsonPatch . apply ( java . lang . Object document , JsonPatch ops ) document Required \u00b6 Type: java.lang.Object The document to patch. ops Required \u00b6 Type: org.cdk8s.JsonPatch The operations to apply. copy \u00b6 import org.cdk8s.JsonPatch ; JsonPatch . copy ( java . lang . String from , java . lang . String path ) from Required \u00b6 Type: java.lang.String path Required \u00b6 Type: java.lang.String move \u00b6 import org.cdk8s.JsonPatch ; JsonPatch . move ( java . lang . String from , java . lang . String path ) from Required \u00b6 Type: java.lang.String path Required \u00b6 Type: java.lang.String remove \u00b6 import org.cdk8s.JsonPatch ; JsonPatch . remove ( java . lang . String path ) path Required \u00b6 Type: java.lang.String replace \u00b6 import org.cdk8s.JsonPatch ; JsonPatch . replace ( java . lang . String path , java . lang . Object value ) path Required \u00b6 Type: java.lang.String value Required \u00b6 Type: java.lang.Object test \u00b6 import org.cdk8s.JsonPatch ; JsonPatch . test ( java . lang . String path , java . lang . Object value ) path Required \u00b6 Type: java.lang.String value Required \u00b6 Type: java.lang.Object Lazy \u00b6 Methods \u00b6 produce \u00b6 public produce () Static Functions \u00b6 any \u00b6 import org.cdk8s.Lazy ; Lazy . any ( IAnyProducer producer ) producer Required \u00b6 Type: org.cdk8s.IAnyProducer Names \u00b6 Utilities for generating unique and stable names. Static Functions \u00b6 toDnsLabel \u00b6 import org.cdk8s.Names ; Names . toDnsLabel ( Construct scope ) Names . toDnsLabel ( Construct scope , NameOptions options ) scope Required \u00b6 Type: software.constructs.Construct The construct for which to render the DNS label. options Optional \u00b6 Type: org.cdk8s.NameOptions Name options. toLabelValue \u00b6 import org.cdk8s.Names ; Names . toLabelValue ( Construct scope ) Names . toLabelValue ( Construct scope , NameOptions options ) scope Required \u00b6 Type: software.constructs.Construct The construct for which to render the DNS label. options Optional \u00b6 Type: org.cdk8s.NameOptions Name options. Size \u00b6 Represents the amount of digital storage. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative. When the amount is passed as a token, unit conversion is not possible. Methods \u00b6 toGibibytes \u00b6 public toGibibytes () public toGibibytes ( SizeConversionOptions opts ) opts Optional \u00b6 Type: org.cdk8s.SizeConversionOptions toKibibytes \u00b6 public toKibibytes () public toKibibytes ( SizeConversionOptions opts ) opts Optional \u00b6 Type: org.cdk8s.SizeConversionOptions toMebibytes \u00b6 public toMebibytes () public toMebibytes ( SizeConversionOptions opts ) opts Optional \u00b6 Type: org.cdk8s.SizeConversionOptions toPebibytes \u00b6 public toPebibytes () public toPebibytes ( SizeConversionOptions opts ) opts Optional \u00b6 Type: org.cdk8s.SizeConversionOptions toTebibytes \u00b6 public toTebibytes () public toTebibytes ( SizeConversionOptions opts ) opts Optional \u00b6 Type: org.cdk8s.SizeConversionOptions Static Functions \u00b6 gibibytes \u00b6 import org.cdk8s.Size ; Size . gibibytes ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number kibibytes \u00b6 import org.cdk8s.Size ; Size . kibibytes ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number mebibytes \u00b6 import org.cdk8s.Size ; Size . mebibytes ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number pebibyte \u00b6 import org.cdk8s.Size ; Size . pebibyte ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number tebibytes \u00b6 import org.cdk8s.Size ; Size . tebibytes ( java . lang . Number amount ) amount Required \u00b6 Type: java.lang.Number Testing \u00b6 Testing utilities for cdk8s applications. Static Functions \u00b6 app \u00b6 import org.cdk8s.Testing ; Testing . app () Testing . app ( AppProps props ) props Optional \u00b6 Type: org.cdk8s.AppProps chart \u00b6 import org.cdk8s.Testing ; Testing . chart () synth \u00b6 import org.cdk8s.Testing ; Testing . synth ( Chart chart ) chart Required \u00b6 Type: org.cdk8s.Chart Yaml \u00b6 YAML utilities. Static Functions \u00b6 ~~ formatObjects ~~ \u00b6 import org.cdk8s.Yaml ; Yaml . formatObjects ( java . util . List < java . lang . Object > docs ) docs Required \u00b6 Type: java.util.List< java.lang.Object > load \u00b6 import org.cdk8s.Yaml ; Yaml . load ( java . lang . String urlOrFile ) urlOrFile Required \u00b6 Type: java.lang.String a URL of a file path to load from. save \u00b6 import org.cdk8s.Yaml ; Yaml . save ( java . lang . String filePath , java . util . List < java . lang . Object > docs ) filePath Required \u00b6 Type: java.lang.String The output path. docs Required \u00b6 Type: java.util.List< java.lang.Object > The set of objects. stringify \u00b6 import org.cdk8s.Yaml ; Yaml . stringify ( java . lang . Object docs ) docs Required \u00b6 Type: java.lang.Object A set of objects to convert to YAML. tmp \u00b6 import org.cdk8s.Yaml ; Yaml . tmp ( java . util . List < java . lang . Object > docs ) docs Required \u00b6 Type: java.util.List< java.lang.Object > the set of documents to save. Protocols \u00b6 IAnyProducer \u00b6 Implemented By: org.cdk8s.IAnyProducer Methods \u00b6 produce \u00b6 public produce () Enums \u00b6 SizeRoundingBehavior \u00b6 Rounding behaviour when converting between units of Size . FAIL \u00b6 Fail the conversion if the result is not an integer. FLOOR \u00b6 If the result is not an integer, round it to the closest integer less than the result. NONE \u00b6 Don\u2019t round. Return even if the result is a fraction. YamlOutputType \u00b6 The method to divide YAML output into files. FILE_PER_APP \u00b6 All resources are output into a single YAML file. FILE_PER_CHART \u00b6 Resources are split into seperate files by chart. FILE_PER_RESOURCE \u00b6 Each resource is output to its own file.","title":"Java"},{"location":"reference/cdk8s/java/#cdk8s-java","text":"","title":"cdk8s (Java) "},{"location":"reference/cdk8s/java/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s/java/#apiobject","text":"","title":"ApiObject "},{"location":"reference/cdk8s/java/#app","text":"Represents a cdk8s application.","title":"App "},{"location":"reference/cdk8s/java/#chart","text":"","title":"Chart "},{"location":"reference/cdk8s/java/#helm","text":"Represents a Helm deployment. Use this construct to import an existing Helm chart and incorporate it into your constructs.","title":"Helm "},{"location":"reference/cdk8s/java/#include","text":"Reads a YAML manifest from a file or a URL and defines all resources as API objects within the defined scope. The names ( metadata.name ) of imported resources will be preserved as-is from the manifest.","title":"Include "},{"location":"reference/cdk8s/java/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s/java/#apiobjectmetadata","text":"Metadata associated with this object.","title":"ApiObjectMetadata "},{"location":"reference/cdk8s/java/#apiobjectprops","text":"Options for defining API objects.","title":"ApiObjectProps "},{"location":"reference/cdk8s/java/#appprops","text":"","title":"AppProps "},{"location":"reference/cdk8s/java/#chartprops","text":"","title":"ChartProps "},{"location":"reference/cdk8s/java/#groupversionkind","text":"","title":"GroupVersionKind "},{"location":"reference/cdk8s/java/#helmprops","text":"Options for Helm .","title":"HelmProps "},{"location":"reference/cdk8s/java/#includeprops","text":"","title":"IncludeProps "},{"location":"reference/cdk8s/java/#nameoptions","text":"Options for name generation.","title":"NameOptions "},{"location":"reference/cdk8s/java/#ownerreference","text":"OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field.","title":"OwnerReference "},{"location":"reference/cdk8s/java/#sizeconversionoptions","text":"Options for how to convert time to a different unit.","title":"SizeConversionOptions "},{"location":"reference/cdk8s/java/#timeconversionoptions","text":"Options for how to convert time to a different unit.","title":"TimeConversionOptions "},{"location":"reference/cdk8s/java/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s/java/#apiobjectmetadatadefinition","text":"Object metadata.","title":"ApiObjectMetadataDefinition "},{"location":"reference/cdk8s/java/#dependencygraph","text":"Represents the dependency graph for a given Node. This graph includes the dependency relationships between all nodes in the node (construct) sub-tree who\u2019s root is this Node. Note that this means that lonely nodes (no dependencies and no dependants) are also included in this graph as childless children of the root node of the graph. The graph does not include cross-scope dependencies. That is, if a child on the current scope depends on a node from a different scope, that relationship is not represented in this graph.","title":"DependencyGraph "},{"location":"reference/cdk8s/java/#dependencyvertex","text":"Represents a vertex in the graph. The value of each vertex is an IConstruct that is accessible via the .value getter.","title":"DependencyVertex "},{"location":"reference/cdk8s/java/#duration","text":"Represents a length of time. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative.","title":"Duration "},{"location":"reference/cdk8s/java/#jsonpatch","text":"Utility for applying RFC-6902 JSON-Patch to a document. Use the the JsonPatch.apply(doc, ...ops) function to apply a set of operations to a JSON document and return the result. Operations can be created using the factory methods JsonPatch.add() , JsonPatch.remove() , etc.","title":"JsonPatch "},{"location":"reference/cdk8s/java/#lazy","text":"","title":"Lazy "},{"location":"reference/cdk8s/java/#names","text":"Utilities for generating unique and stable names.","title":"Names "},{"location":"reference/cdk8s/java/#size","text":"Represents the amount of digital storage. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative. When the amount is passed as a token, unit conversion is not possible.","title":"Size "},{"location":"reference/cdk8s/java/#testing","text":"Testing utilities for cdk8s applications.","title":"Testing "},{"location":"reference/cdk8s/java/#yaml","text":"YAML utilities.","title":"Yaml "},{"location":"reference/cdk8s/java/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s/java/#ianyproducer","text":"Implemented By: org.cdk8s.IAnyProducer","title":"IAnyProducer "},{"location":"reference/cdk8s/java/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s/java/#sizeroundingbehavior","text":"Rounding behaviour when converting between units of Size .","title":"SizeRoundingBehavior "},{"location":"reference/cdk8s/java/#yamloutputtype","text":"The method to divide YAML output into files.","title":"YamlOutputType "},{"location":"reference/cdk8s/python/","text":"cdk8s (Python) \u00b6 Constructs \u00b6 ApiObject \u00b6 Initializers \u00b6 import cdk8s cdk8s . ApiObject ( scope : Construct , id : str , api_version : str , kind : str , metadata : ApiObjectMetadata = None ) scope Required \u00b6 Type: constructs.Construct the construct scope. id Required \u00b6 Type: str namespace. api_version Required \u00b6 Type: str API version. kind Required \u00b6 Type: str Resource kind. metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Object metadata. If name is not specified, an app-unique name will be allocated by the framework based on the path of the construct within thes construct tree. Methods \u00b6 add_dependency \u00b6 def add_dependency ( dependencies : IConstruct ) dependencies Required \u00b6 Type: constructs.IConstruct the dependencies to add. add_json_patch \u00b6 def add_json_patch ( ops : JsonPatch ) ops Required \u00b6 Type: cdk8s.JsonPatch The JSON-Patch operations to apply. to_json \u00b6 def to_json () Static Functions \u00b6 of \u00b6 import cdk8s cdk8s . ApiObject . of ( c : IConstruct ) c Required \u00b6 Type: constructs.IConstruct The higher-level construct. Properties \u00b6 api_group Required \u00b6 api_group : str Type: str The group portion of the API version (e.g. authorization.k8s.io ). api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. authorization.k8s.io/v1 ). chart Required \u00b6 chart : Chart Type: cdk8s.Chart The chart in which this object is defined. kind Required \u00b6 kind : str Type: str The object kind. metadata Required \u00b6 metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition Metadata associated with this API object. name Required \u00b6 name : str Type: str The name of the API object. If a name is specified in metadata.name this will be the name returned. Otherwise, a name will be generated by calling Chart.of(this).generatedObjectName(this) , which by default uses the construct path to generate a DNS-compatible name for the resource. App \u00b6 Represents a cdk8s application. Initializers \u00b6 import cdk8s cdk8s . App ( outdir : str = None , yaml_output_type : YamlOutputType = None ) outdir Optional \u00b6 Type: str Default: CDK8S_OUTDIR if defined, otherwise \u201cdist\u201d The directory to output Kubernetes manifests. yaml_output_type Optional \u00b6 Type: cdk8s.YamlOutputType Default: YamlOutputType.FILE_PER_CHART How to divide the YAML output into files. Methods \u00b6 synth \u00b6 def synth () synth_yaml \u00b6 def synth_yaml () Properties \u00b6 charts Required \u00b6 charts : typing . List [ Chart ] Type: typing.List[ cdk8s.Chart ] Returns all the charts in this app, sorted topologically. outdir Required \u00b6 outdir : str Type: str The output directory into which manifests will be synthesized. yaml_output_type Required \u00b6 yaml_output_type : YamlOutputType Type: cdk8s.YamlOutputType Default: YamlOutputType.FILE_PER_CHART How to divide the YAML output into files. Chart \u00b6 Initializers \u00b6 import cdk8s cdk8s . Chart ( scope : Construct , id : str , labels : typing . Mapping [ str ] = None , namespace : str = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str labels Optional \u00b6 Type: typing.Mapping[ str ] Default: no common labels Labels to apply to all resources in this chart. namespace Optional \u00b6 Type: str Default: no namespace is synthesized (usually this implies \u201cdefault\u201d) The default namespace for all objects defined in this chart (directly or indirectly). This namespace will only apply to objects that don\u2019t have a namespace explicitly defined for them. Methods \u00b6 add_dependency \u00b6 def add_dependency ( dependencies : IConstruct ) dependencies Required \u00b6 Type: constructs.IConstruct the dependencies to add. generate_object_name \u00b6 def generate_object_name ( api_object : ApiObject ) api_object Required \u00b6 Type: cdk8s.ApiObject The API object to generate a name for. to_json \u00b6 def to_json () Static Functions \u00b6 of \u00b6 import cdk8s cdk8s . Chart . of ( c : IConstruct ) c Required \u00b6 Type: constructs.IConstruct a construct node. Properties \u00b6 labels Required \u00b6 labels : typing . Mapping [ str ] Type: typing.Mapping[ str ] Labels applied to all resources in this chart. This is an immutable copy. namespace Optional \u00b6 namespace : str Type: str The default namespace for all objects in this chart. Helm \u00b6 Represents a Helm deployment. Use this construct to import an existing Helm chart and incorporate it into your constructs. Initializers \u00b6 import cdk8s cdk8s . Helm ( scope : Construct , id : str , chart : str , helm_executable : str = None , helm_flags : typing . List [ str ] = None , release_name : str = None , values : typing . Mapping [ typing . Any ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str chart Required \u00b6 Type: str The chart name to use. It can be a chart from a helm repository or a local directory. This name is passed to helm template and has all the relevant semantics. helm_executable Optional \u00b6 Type: str Default: \u201chelm\u201d The local helm executable to use in order to create the manifest the chart. helm_flags Optional \u00b6 Type: typing.List[ str ] Default: [] Additional flags to add to the helm execution. release_name Optional \u00b6 Type: str Default: if unspecified, a name will be allocated based on the construct path The release name. https://helm.sh/docs/intro/using_helm/#three-big-concepts values Optional \u00b6 Type: typing.Mapping[ typing.Any ] Default: If no values are specified, chart will use the defaults. Values to pass to the chart. Properties \u00b6 release_name Required \u00b6 release_name : str Type: str The helm release name. Include \u00b6 Reads a YAML manifest from a file or a URL and defines all resources as API objects within the defined scope. The names ( metadata.name ) of imported resources will be preserved as-is from the manifest. Initializers \u00b6 import cdk8s cdk8s . Include ( scope : Construct , id : str , url : str ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str url Required \u00b6 Type: str Local file path or URL which includes a Kubernetes YAML manifest. Properties \u00b6 api_objects Required \u00b6 api_objects : typing . List [ ApiObject ] Type: typing.List[ cdk8s.ApiObject ] Returns all the included API objects. Structs \u00b6 ApiObjectMetadata \u00b6 Metadata associated with this object. Initializer \u00b6 import cdk8s cdk8s . ApiObjectMetadata ( annotations : typing . Mapping [ str ] = None , finalizers : typing . List [ str ] = None , labels : typing . Mapping [ str ] = None , name : str = None , namespace : str = None , owner_references : typing . List [ OwnerReference ] = None ) annotations Optional \u00b6 annotations : typing . Mapping [ str ] Type: typing.Mapping[ str ] Default: No annotations. Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. http://kubernetes.io/docs/user-guide/annotations finalizers Optional \u00b6 finalizers : typing . List [ str ] Type: typing.List[ str ] Default: No finalizers. Namespaced keys that tell Kubernetes to wait until specific conditions are met before it fully deletes resources marked for deletion. Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order. Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list. https://kubernetes.io/docs/concepts/overview/working-with-objects/finalizers/ labels Optional \u00b6 labels : typing . Mapping [ str ] Type: typing.Mapping[ str ] Default: No labels. Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. http://kubernetes.io/docs/user-guide/labels name Optional \u00b6 name : str Type: str Default: an app-unique name generated by the chart The unique, namespace-global, name of this object inside the Kubernetes cluster. Normally, you shouldn\u2019t specify names for objects and let the CDK generate a name for you that is application-unique. The names CDK generates are composed from the construct path components, separated by dots and a suffix that is based on a hash of the entire path, to ensure uniqueness. You can supply custom name allocation logic by overriding the chart.generateObjectName method. If you use an explicit name here, bear in mind that this reduces the composability of your construct because it won\u2019t be possible to include more than one instance in any app. Therefore it is highly recommended to leave this unspecified. namespace Optional \u00b6 namespace : str Type: str Default: undefined (will be assigned to the \u2018default\u2019 namespace) Namespace defines the space within each name must be unique. An empty namespace is equivalent to the \u201cdefault\u201d namespace, but \u201cdefault\u201d is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty. Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces owner_references Optional \u00b6 owner_references : typing . List [ OwnerReference ] Type: typing.List[ cdk8s.OwnerReference ] Default: automatically set by Kubernetes List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller. Kubernetes sets the value of this field automatically for objects that are dependents of other objects like ReplicaSets, DaemonSets, Deployments, Jobs and CronJobs, and ReplicationControllers. You can also configure these relationships manually by changing the value of this field. However, you usually don\u2019t need to and can allow Kubernetes to automatically manage the relationships. https://kubernetes.io/docs/concepts/overview/working-with-objects/owners-dependents/ ApiObjectProps \u00b6 Options for defining API objects. Initializer \u00b6 import cdk8s cdk8s . ApiObjectProps ( api_version : str , kind : str , metadata : ApiObjectMetadata = None ) api_version Required \u00b6 api_version : str Type: str API version. kind Required \u00b6 kind : str Type: str Resource kind. metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Object metadata. If name is not specified, an app-unique name will be allocated by the framework based on the path of the construct within thes construct tree. AppProps \u00b6 Initializer \u00b6 import cdk8s cdk8s . AppProps ( outdir : str = None , yaml_output_type : YamlOutputType = None ) outdir Optional \u00b6 outdir : str Type: str Default: CDK8S_OUTDIR if defined, otherwise \u201cdist\u201d The directory to output Kubernetes manifests. yaml_output_type Optional \u00b6 yaml_output_type : YamlOutputType Type: cdk8s.YamlOutputType Default: YamlOutputType.FILE_PER_CHART How to divide the YAML output into files. ChartProps \u00b6 Initializer \u00b6 import cdk8s cdk8s . ChartProps ( labels : typing . Mapping [ str ] = None , namespace : str = None ) labels Optional \u00b6 labels : typing . Mapping [ str ] Type: typing.Mapping[ str ] Default: no common labels Labels to apply to all resources in this chart. namespace Optional \u00b6 namespace : str Type: str Default: no namespace is synthesized (usually this implies \u201cdefault\u201d) The default namespace for all objects defined in this chart (directly or indirectly). This namespace will only apply to objects that don\u2019t have a namespace explicitly defined for them. GroupVersionKind \u00b6 Initializer \u00b6 import cdk8s cdk8s . GroupVersionKind ( api_version : str , kind : str ) api_version Required \u00b6 api_version : str Type: str The object\u2019s API version (e.g. authorization.k8s.io/v1 ). kind Required \u00b6 kind : str Type: str The object kind. HelmProps \u00b6 Options for Helm . Initializer \u00b6 import cdk8s cdk8s . HelmProps ( chart : str , helm_executable : str = None , helm_flags : typing . List [ str ] = None , release_name : str = None , values : typing . Mapping [ typing . Any ] = None ) chart Required \u00b6 chart : str Type: str The chart name to use. It can be a chart from a helm repository or a local directory. This name is passed to helm template and has all the relevant semantics. helm_executable Optional \u00b6 helm_executable : str Type: str Default: \u201chelm\u201d The local helm executable to use in order to create the manifest the chart. helm_flags Optional \u00b6 helm_flags : typing . List [ str ] Type: typing.List[ str ] Default: [] Additional flags to add to the helm execution. release_name Optional \u00b6 release_name : str Type: str Default: if unspecified, a name will be allocated based on the construct path The release name. https://helm.sh/docs/intro/using_helm/#three-big-concepts values Optional \u00b6 values : typing . Mapping [ typing . Any ] Type: typing.Mapping[ typing.Any ] Default: If no values are specified, chart will use the defaults. Values to pass to the chart. IncludeProps \u00b6 Initializer \u00b6 import cdk8s cdk8s . IncludeProps ( url : str ) url Required \u00b6 url : str Type: str Local file path or URL which includes a Kubernetes YAML manifest. NameOptions \u00b6 Options for name generation. Initializer \u00b6 import cdk8s cdk8s . NameOptions ( delimiter : str = None , extra : typing . List [ str ] = None , include_hash : bool = None , max_len : typing . Union [ int , float ] = None ) delimiter Optional \u00b6 delimiter : str Type: str Default: \u201c-\u201c Delimiter to use between components. extra Optional \u00b6 extra : typing . List [ str ] Type: typing.List[ str ] Default: [] use the construct path components Extra components to include in the name. include_hash Optional \u00b6 include_hash : bool Type: bool Default: true Include a short hash as last part of the name. max_len Optional \u00b6 max_len : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 63 Maximum allowed length for the name. OwnerReference \u00b6 OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field. Initializer \u00b6 import cdk8s cdk8s . OwnerReference ( api_version : str , kind : str , name : str , uid : str , block_owner_deletion : bool = None , controller : bool = None ) api_version Required \u00b6 api_version : str Type: str API version of the referent. kind Required \u00b6 kind : str Type: str Kind of the referent. https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds name Required \u00b6 name : str Type: str Name of the referent. http://kubernetes.io/docs/user-guide/identifiers#names uid Required \u00b6 uid : str Type: str UID of the referent. http://kubernetes.io/docs/user-guide/identifiers#uids block_owner_deletion Optional \u00b6 block_owner_deletion : bool Type: bool Default: false. To set this field, a user needs \u201cdelete\u201d permission of the owner, otherwise 422 (Unprocessable Entity) will be returned. If true, AND if the owner has the \u201cforegroundDeletion\u201d finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. Defaults to false. To set this field, a user needs \u201cdelete\u201d permission of the owner, otherwise 422 (Unprocessable Entity) will be returned. controller Optional \u00b6 controller : bool Type: bool If true, this reference points to the managing controller. SizeConversionOptions \u00b6 Options for how to convert time to a different unit. Initializer \u00b6 import cdk8s cdk8s . SizeConversionOptions ( rounding : SizeRoundingBehavior = None ) rounding Optional \u00b6 rounding : SizeRoundingBehavior Type: cdk8s.SizeRoundingBehavior Default: SizeRoundingBehavior.FAIL How conversions should behave when it encounters a non-integer result. TimeConversionOptions \u00b6 Options for how to convert time to a different unit. Initializer \u00b6 import cdk8s cdk8s . TimeConversionOptions ( integral : bool = None ) integral Optional \u00b6 integral : bool Type: bool Default: true If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. Classes \u00b6 ApiObjectMetadataDefinition \u00b6 Object metadata. Initializers \u00b6 import cdk8s cdk8s . ApiObjectMetadataDefinition ( annotations : typing . Mapping [ str ] = None , finalizers : typing . List [ str ] = None , labels : typing . Mapping [ str ] = None , name : str = None , namespace : str = None , owner_references : typing . List [ OwnerReference ] = None ) annotations Optional \u00b6 Type: typing.Mapping[ str ] Default: No annotations. Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. http://kubernetes.io/docs/user-guide/annotations finalizers Optional \u00b6 Type: typing.List[ str ] Default: No finalizers. Namespaced keys that tell Kubernetes to wait until specific conditions are met before it fully deletes resources marked for deletion. Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order. Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list. https://kubernetes.io/docs/concepts/overview/working-with-objects/finalizers/ labels Optional \u00b6 Type: typing.Mapping[ str ] Default: No labels. Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. http://kubernetes.io/docs/user-guide/labels name Optional \u00b6 Type: str Default: an app-unique name generated by the chart The unique, namespace-global, name of this object inside the Kubernetes cluster. Normally, you shouldn\u2019t specify names for objects and let the CDK generate a name for you that is application-unique. The names CDK generates are composed from the construct path components, separated by dots and a suffix that is based on a hash of the entire path, to ensure uniqueness. You can supply custom name allocation logic by overriding the chart.generateObjectName method. If you use an explicit name here, bear in mind that this reduces the composability of your construct because it won\u2019t be possible to include more than one instance in any app. Therefore it is highly recommended to leave this unspecified. namespace Optional \u00b6 Type: str Default: undefined (will be assigned to the \u2018default\u2019 namespace) Namespace defines the space within each name must be unique. An empty namespace is equivalent to the \u201cdefault\u201d namespace, but \u201cdefault\u201d is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty. Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces owner_references Optional \u00b6 Type: typing.List[ cdk8s.OwnerReference ] Default: automatically set by Kubernetes List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller. Kubernetes sets the value of this field automatically for objects that are dependents of other objects like ReplicaSets, DaemonSets, Deployments, Jobs and CronJobs, and ReplicationControllers. You can also configure these relationships manually by changing the value of this field. However, you usually don\u2019t need to and can allow Kubernetes to automatically manage the relationships. https://kubernetes.io/docs/concepts/overview/working-with-objects/owners-dependents/ Methods \u00b6 add \u00b6 def add ( key : str , value : typing . Any ) key Required \u00b6 Type: str Metadata key. value Required \u00b6 Type: typing.Any Metadata value. add_annotation \u00b6 def add_annotation ( key : str , value : str ) key Required \u00b6 Type: str The key. value Required \u00b6 Type: str The value. add_finalizers \u00b6 def add_finalizers ( finalizers : str ) finalizers Required \u00b6 Type: str the finalizers. add_label \u00b6 def add_label ( key : str , value : str ) key Required \u00b6 Type: str The key. value Required \u00b6 Type: str The value. add_owner_reference \u00b6 def add_owner_reference ( api_version : str , kind : str , name : str , uid : str , block_owner_deletion : bool = None , controller : bool = None ) api_version Required \u00b6 Type: str API version of the referent. kind Required \u00b6 Type: str Kind of the referent. https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds name Required \u00b6 Type: str Name of the referent. http://kubernetes.io/docs/user-guide/identifiers#names uid Required \u00b6 Type: str UID of the referent. http://kubernetes.io/docs/user-guide/identifiers#uids block_owner_deletion Optional \u00b6 Type: bool Default: false. To set this field, a user needs \u201cdelete\u201d permission of the owner, otherwise 422 (Unprocessable Entity) will be returned. If true, AND if the owner has the \u201cforegroundDeletion\u201d finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. Defaults to false. To set this field, a user needs \u201cdelete\u201d permission of the owner, otherwise 422 (Unprocessable Entity) will be returned. controller Optional \u00b6 Type: bool If true, this reference points to the managing controller. get_label \u00b6 def get_label ( key : str ) key Required \u00b6 Type: str the label. to_json \u00b6 def to_json () Properties \u00b6 name Optional \u00b6 name : str Type: str The name of the API object. If a name is specified in metadata.name this will be the name returned. Otherwise, a name will be generated by calling Chart.of(this).generatedObjectName(this) , which by default uses the construct path to generate a DNS-compatible name for the resource. namespace Optional \u00b6 namespace : str Type: str The object\u2019s namespace. DependencyGraph \u00b6 Represents the dependency graph for a given Node. This graph includes the dependency relationships between all nodes in the node (construct) sub-tree who\u2019s root is this Node. Note that this means that lonely nodes (no dependencies and no dependants) are also included in this graph as childless children of the root node of the graph. The graph does not include cross-scope dependencies. That is, if a child on the current scope depends on a node from a different scope, that relationship is not represented in this graph. Initializers \u00b6 import cdk8s cdk8s . DependencyGraph ( node : Node ) node Required \u00b6 Type: constructs.Node Methods \u00b6 topology \u00b6 def topology () Properties \u00b6 root Required \u00b6 root : DependencyVertex Type: cdk8s.DependencyVertex Returns the root of the graph. Note that this vertex will always have null as its .value since it is an artifical root that binds all the connected spaces of the graph. DependencyVertex \u00b6 Represents a vertex in the graph. The value of each vertex is an IConstruct that is accessible via the .value getter. Initializers \u00b6 import cdk8s cdk8s . DependencyVertex ( value : IConstruct = None ) value Optional \u00b6 Type: constructs.IConstruct Methods \u00b6 add_child \u00b6 def add_child ( dep : DependencyVertex ) dep Required \u00b6 Type: cdk8s.DependencyVertex The dependency. topology \u00b6 def topology () Properties \u00b6 inbound Required \u00b6 inbound : typing . List [ DependencyVertex ] Type: typing.List[ cdk8s.DependencyVertex ] Returns the parents of the vertex (i.e dependants). outbound Required \u00b6 outbound : typing . List [ DependencyVertex ] Type: typing.List[ cdk8s.DependencyVertex ] Returns the children of the vertex (i.e dependencies). value Optional \u00b6 value : IConstruct Type: constructs.IConstruct Returns the IConstruct this graph vertex represents. null in case this is the root of the graph. Duration \u00b6 Represents a length of time. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative. Methods \u00b6 to_days \u00b6 def to_days ( integral : bool = None ) integral Optional \u00b6 Type: bool Default: true If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. to_hours \u00b6 def to_hours ( integral : bool = None ) integral Optional \u00b6 Type: bool Default: true If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. to_human_string \u00b6 def to_human_string () to_iso_string \u00b6 def to_iso_string () to_milliseconds \u00b6 def to_milliseconds ( integral : bool = None ) integral Optional \u00b6 Type: bool Default: true If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. to_minutes \u00b6 def to_minutes ( integral : bool = None ) integral Optional \u00b6 Type: bool Default: true If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. to_seconds \u00b6 def to_seconds ( integral : bool = None ) integral Optional \u00b6 Type: bool Default: true If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. Static Functions \u00b6 days \u00b6 import cdk8s cdk8s . Duration . days ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] the amount of Days the Duration will represent. hours \u00b6 import cdk8s cdk8s . Duration . hours ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] the amount of Hours the Duration will represent. millis \u00b6 import cdk8s cdk8s . Duration . millis ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] the amount of Milliseconds the Duration will represent. minutes \u00b6 import cdk8s cdk8s . Duration . minutes ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] the amount of Minutes the Duration will represent. parse \u00b6 import cdk8s cdk8s . Duration . parse ( duration : str ) duration Required \u00b6 Type: str an ISO-formtted duration to be parsed. seconds \u00b6 import cdk8s cdk8s . Duration . seconds ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] the amount of Seconds the Duration will represent. JsonPatch \u00b6 Utility for applying RFC-6902 JSON-Patch to a document. Use the the JsonPatch.apply(doc, ...ops) function to apply a set of operations to a JSON document and return the result. Operations can be created using the factory methods JsonPatch.add() , JsonPatch.remove() , etc. Static Functions \u00b6 add \u00b6 import cdk8s cdk8s . JsonPatch . add ( path : str , value : typing . Any ) path Required \u00b6 Type: str value Required \u00b6 Type: typing.Any apply \u00b6 import cdk8s cdk8s . JsonPatch . apply ( document : typing . Any , ops : JsonPatch ) document Required \u00b6 Type: typing.Any The document to patch. ops Required \u00b6 Type: cdk8s.JsonPatch The operations to apply. copy \u00b6 import cdk8s cdk8s . JsonPatch . copy ( from : str , path : str ) from Required \u00b6 Type: str path Required \u00b6 Type: str move \u00b6 import cdk8s cdk8s . JsonPatch . move ( from : str , path : str ) from Required \u00b6 Type: str path Required \u00b6 Type: str remove \u00b6 import cdk8s cdk8s . JsonPatch . remove ( path : str ) path Required \u00b6 Type: str replace \u00b6 import cdk8s cdk8s . JsonPatch . replace ( path : str , value : typing . Any ) path Required \u00b6 Type: str value Required \u00b6 Type: typing.Any test \u00b6 import cdk8s cdk8s . JsonPatch . test ( path : str , value : typing . Any ) path Required \u00b6 Type: str value Required \u00b6 Type: typing.Any Lazy \u00b6 Methods \u00b6 produce \u00b6 def produce () Static Functions \u00b6 any \u00b6 import cdk8s cdk8s . Lazy . any ( producer : IAnyProducer ) producer Required \u00b6 Type: cdk8s.IAnyProducer Names \u00b6 Utilities for generating unique and stable names. Static Functions \u00b6 to_dns_label \u00b6 import cdk8s cdk8s . Names . to_dns_label ( scope : Construct , delimiter : str = None , extra : typing . List [ str ] = None , include_hash : bool = None , max_len : typing . Union [ int , float ] = None ) scope Required \u00b6 Type: constructs.Construct The construct for which to render the DNS label. delimiter Optional \u00b6 Type: str Default: \u201c-\u201c Delimiter to use between components. extra Optional \u00b6 Type: typing.List[ str ] Default: [] use the construct path components Extra components to include in the name. include_hash Optional \u00b6 Type: bool Default: true Include a short hash as last part of the name. max_len Optional \u00b6 Type: typing.Union[int, float] Default: 63 Maximum allowed length for the name. to_label_value \u00b6 import cdk8s cdk8s . Names . to_label_value ( scope : Construct , delimiter : str = None , extra : typing . List [ str ] = None , include_hash : bool = None , max_len : typing . Union [ int , float ] = None ) scope Required \u00b6 Type: constructs.Construct The construct for which to render the DNS label. delimiter Optional \u00b6 Type: str Default: \u201c-\u201c Delimiter to use between components. extra Optional \u00b6 Type: typing.List[ str ] Default: [] use the construct path components Extra components to include in the name. include_hash Optional \u00b6 Type: bool Default: true Include a short hash as last part of the name. max_len Optional \u00b6 Type: typing.Union[int, float] Default: 63 Maximum allowed length for the name. Size \u00b6 Represents the amount of digital storage. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative. When the amount is passed as a token, unit conversion is not possible. Methods \u00b6 to_gibibytes \u00b6 def to_gibibytes ( rounding : SizeRoundingBehavior = None ) rounding Optional \u00b6 Type: cdk8s.SizeRoundingBehavior Default: SizeRoundingBehavior.FAIL How conversions should behave when it encounters a non-integer result. to_kibibytes \u00b6 def to_kibibytes ( rounding : SizeRoundingBehavior = None ) rounding Optional \u00b6 Type: cdk8s.SizeRoundingBehavior Default: SizeRoundingBehavior.FAIL How conversions should behave when it encounters a non-integer result. to_mebibytes \u00b6 def to_mebibytes ( rounding : SizeRoundingBehavior = None ) rounding Optional \u00b6 Type: cdk8s.SizeRoundingBehavior Default: SizeRoundingBehavior.FAIL How conversions should behave when it encounters a non-integer result. to_pebibytes \u00b6 def to_pebibytes ( rounding : SizeRoundingBehavior = None ) rounding Optional \u00b6 Type: cdk8s.SizeRoundingBehavior Default: SizeRoundingBehavior.FAIL How conversions should behave when it encounters a non-integer result. to_tebibytes \u00b6 def to_tebibytes ( rounding : SizeRoundingBehavior = None ) rounding Optional \u00b6 Type: cdk8s.SizeRoundingBehavior Default: SizeRoundingBehavior.FAIL How conversions should behave when it encounters a non-integer result. Static Functions \u00b6 gibibytes \u00b6 import cdk8s cdk8s . Size . gibibytes ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] kibibytes \u00b6 import cdk8s cdk8s . Size . kibibytes ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] mebibytes \u00b6 import cdk8s cdk8s . Size . mebibytes ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] pebibyte \u00b6 import cdk8s cdk8s . Size . pebibyte ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] tebibytes \u00b6 import cdk8s cdk8s . Size . tebibytes ( amount : typing . Union [ int , float ] ) amount Required \u00b6 Type: typing.Union[int, float] Testing \u00b6 Testing utilities for cdk8s applications. Static Functions \u00b6 app \u00b6 import cdk8s cdk8s . Testing . app ( outdir : str = None , yaml_output_type : YamlOutputType = None ) outdir Optional \u00b6 Type: str Default: CDK8S_OUTDIR if defined, otherwise \u201cdist\u201d The directory to output Kubernetes manifests. yaml_output_type Optional \u00b6 Type: cdk8s.YamlOutputType Default: YamlOutputType.FILE_PER_CHART How to divide the YAML output into files. chart \u00b6 import cdk8s cdk8s . Testing . chart () synth \u00b6 import cdk8s cdk8s . Testing . synth ( chart : Chart ) chart Required \u00b6 Type: cdk8s.Chart Yaml \u00b6 YAML utilities. Static Functions \u00b6 ~~ format_objects ~~ \u00b6 import cdk8s cdk8s . Yaml . format_objects ( docs : typing . List [ typing . Any ] ) docs Required \u00b6 Type: typing.List[ typing.Any ] load \u00b6 import cdk8s cdk8s . Yaml . load ( url_or_file : str ) url_or_file Required \u00b6 Type: str a URL of a file path to load from. save \u00b6 import cdk8s cdk8s . Yaml . save ( file_path : str , docs : typing . List [ typing . Any ] ) file_path Required \u00b6 Type: str The output path. docs Required \u00b6 Type: typing.List[ typing.Any ] The set of objects. stringify \u00b6 import cdk8s cdk8s . Yaml . stringify ( docs : typing . Any ) docs Required \u00b6 Type: typing.Any A set of objects to convert to YAML. tmp \u00b6 import cdk8s cdk8s . Yaml . tmp ( docs : typing . List [ typing . Any ] ) docs Required \u00b6 Type: typing.List[ typing.Any ] the set of documents to save. Protocols \u00b6 IAnyProducer \u00b6 Implemented By: cdk8s.IAnyProducer Methods \u00b6 produce \u00b6 def produce () Enums \u00b6 SizeRoundingBehavior \u00b6 Rounding behaviour when converting between units of Size . FAIL \u00b6 Fail the conversion if the result is not an integer. FLOOR \u00b6 If the result is not an integer, round it to the closest integer less than the result. NONE \u00b6 Don\u2019t round. Return even if the result is a fraction. YamlOutputType \u00b6 The method to divide YAML output into files. FILE_PER_APP \u00b6 All resources are output into a single YAML file. FILE_PER_CHART \u00b6 Resources are split into seperate files by chart. FILE_PER_RESOURCE \u00b6 Each resource is output to its own file.","title":"Python"},{"location":"reference/cdk8s/python/#cdk8s-python","text":"","title":"cdk8s (Python) "},{"location":"reference/cdk8s/python/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s/python/#apiobject","text":"","title":"ApiObject "},{"location":"reference/cdk8s/python/#app","text":"Represents a cdk8s application.","title":"App "},{"location":"reference/cdk8s/python/#chart","text":"","title":"Chart "},{"location":"reference/cdk8s/python/#helm","text":"Represents a Helm deployment. Use this construct to import an existing Helm chart and incorporate it into your constructs.","title":"Helm "},{"location":"reference/cdk8s/python/#include","text":"Reads a YAML manifest from a file or a URL and defines all resources as API objects within the defined scope. The names ( metadata.name ) of imported resources will be preserved as-is from the manifest.","title":"Include "},{"location":"reference/cdk8s/python/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s/python/#apiobjectmetadata","text":"Metadata associated with this object.","title":"ApiObjectMetadata "},{"location":"reference/cdk8s/python/#apiobjectprops","text":"Options for defining API objects.","title":"ApiObjectProps "},{"location":"reference/cdk8s/python/#appprops","text":"","title":"AppProps "},{"location":"reference/cdk8s/python/#chartprops","text":"","title":"ChartProps "},{"location":"reference/cdk8s/python/#groupversionkind","text":"","title":"GroupVersionKind "},{"location":"reference/cdk8s/python/#helmprops","text":"Options for Helm .","title":"HelmProps "},{"location":"reference/cdk8s/python/#includeprops","text":"","title":"IncludeProps "},{"location":"reference/cdk8s/python/#nameoptions","text":"Options for name generation.","title":"NameOptions "},{"location":"reference/cdk8s/python/#ownerreference","text":"OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field.","title":"OwnerReference "},{"location":"reference/cdk8s/python/#sizeconversionoptions","text":"Options for how to convert time to a different unit.","title":"SizeConversionOptions "},{"location":"reference/cdk8s/python/#timeconversionoptions","text":"Options for how to convert time to a different unit.","title":"TimeConversionOptions "},{"location":"reference/cdk8s/python/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s/python/#apiobjectmetadatadefinition","text":"Object metadata.","title":"ApiObjectMetadataDefinition "},{"location":"reference/cdk8s/python/#dependencygraph","text":"Represents the dependency graph for a given Node. This graph includes the dependency relationships between all nodes in the node (construct) sub-tree who\u2019s root is this Node. Note that this means that lonely nodes (no dependencies and no dependants) are also included in this graph as childless children of the root node of the graph. The graph does not include cross-scope dependencies. That is, if a child on the current scope depends on a node from a different scope, that relationship is not represented in this graph.","title":"DependencyGraph "},{"location":"reference/cdk8s/python/#dependencyvertex","text":"Represents a vertex in the graph. The value of each vertex is an IConstruct that is accessible via the .value getter.","title":"DependencyVertex "},{"location":"reference/cdk8s/python/#duration","text":"Represents a length of time. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative.","title":"Duration "},{"location":"reference/cdk8s/python/#jsonpatch","text":"Utility for applying RFC-6902 JSON-Patch to a document. Use the the JsonPatch.apply(doc, ...ops) function to apply a set of operations to a JSON document and return the result. Operations can be created using the factory methods JsonPatch.add() , JsonPatch.remove() , etc.","title":"JsonPatch "},{"location":"reference/cdk8s/python/#lazy","text":"","title":"Lazy "},{"location":"reference/cdk8s/python/#names","text":"Utilities for generating unique and stable names.","title":"Names "},{"location":"reference/cdk8s/python/#size","text":"Represents the amount of digital storage. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative. When the amount is passed as a token, unit conversion is not possible.","title":"Size "},{"location":"reference/cdk8s/python/#testing","text":"Testing utilities for cdk8s applications.","title":"Testing "},{"location":"reference/cdk8s/python/#yaml","text":"YAML utilities.","title":"Yaml "},{"location":"reference/cdk8s/python/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s/python/#ianyproducer","text":"Implemented By: cdk8s.IAnyProducer","title":"IAnyProducer "},{"location":"reference/cdk8s/python/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s/python/#sizeroundingbehavior","text":"Rounding behaviour when converting between units of Size .","title":"SizeRoundingBehavior "},{"location":"reference/cdk8s/python/#yamloutputtype","text":"The method to divide YAML output into files.","title":"YamlOutputType "},{"location":"reference/cdk8s/typescript/","text":"cdk8s (TypeScript) \u00b6 Constructs \u00b6 ApiObject \u00b6 Initializers \u00b6 import { ApiObject } from 'cdk8s' new ApiObject ( scope : Construct , id : string , props : ApiObjectProps ) scope Required \u00b6 Type: constructs.Construct the construct scope. id Required \u00b6 Type: string namespace. props Required \u00b6 Type: cdk8s.ApiObjectProps options. Methods \u00b6 addDependency \u00b6 public addDependency ( dependencies : IConstruct ) dependencies Required \u00b6 Type: constructs.IConstruct the dependencies to add. addJsonPatch \u00b6 public addJsonPatch ( ops : JsonPatch ) ops Required \u00b6 Type: cdk8s.JsonPatch The JSON-Patch operations to apply. toJson \u00b6 public toJson () Static Functions \u00b6 of \u00b6 import { ApiObject } from 'cdk8s' ApiObject . of ( c : IConstruct ) c Required \u00b6 Type: constructs.IConstruct The higher-level construct. Properties \u00b6 apiGroup Required \u00b6 public readonly apiGroup : string ; Type: string The group portion of the API version (e.g. authorization.k8s.io ). apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. authorization.k8s.io/v1 ). chart Required \u00b6 public readonly chart : Chart ; Type: cdk8s.Chart The chart in which this object is defined. kind Required \u00b6 public readonly kind : string ; Type: string The object kind. metadata Required \u00b6 public readonly metadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition Metadata associated with this API object. name Required \u00b6 public readonly name : string ; Type: string The name of the API object. If a name is specified in metadata.name this will be the name returned. Otherwise, a name will be generated by calling Chart.of(this).generatedObjectName(this) , which by default uses the construct path to generate a DNS-compatible name for the resource. App \u00b6 Represents a cdk8s application. Initializers \u00b6 import { App } from 'cdk8s' new App ( props? : AppProps ) props Optional \u00b6 Type: cdk8s.AppProps configuration options. Methods \u00b6 synth \u00b6 public synth () synthYaml \u00b6 public synthYaml () Properties \u00b6 charts Required \u00b6 public readonly charts : Chart []; Type: cdk8s.Chart [] Returns all the charts in this app, sorted topologically. outdir Required \u00b6 public readonly outdir : string ; Type: string The output directory into which manifests will be synthesized. yamlOutputType Required \u00b6 public readonly yamlOutputType : YamlOutputType ; Type: cdk8s.YamlOutputType Default: YamlOutputType.FILE_PER_CHART How to divide the YAML output into files. Chart \u00b6 Initializers \u00b6 import { Chart } from 'cdk8s' new Chart ( scope : Construct , id : string , props? : ChartProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s.ChartProps Methods \u00b6 addDependency \u00b6 public addDependency ( dependencies : IConstruct ) dependencies Required \u00b6 Type: constructs.IConstruct the dependencies to add. generateObjectName \u00b6 public generateObjectName ( apiObject : ApiObject ) apiObject Required \u00b6 Type: cdk8s.ApiObject The API object to generate a name for. toJson \u00b6 public toJson () Static Functions \u00b6 of \u00b6 import { Chart } from 'cdk8s' Chart . of ( c : IConstruct ) c Required \u00b6 Type: constructs.IConstruct a construct node. Properties \u00b6 labels Required \u00b6 public readonly labels : {[ key : string ] : string }; Type: {[ key: string ]: string } Labels applied to all resources in this chart. This is an immutable copy. namespace Optional \u00b6 public readonly namespace : string ; Type: string The default namespace for all objects in this chart. Helm \u00b6 Represents a Helm deployment. Use this construct to import an existing Helm chart and incorporate it into your constructs. Initializers \u00b6 import { Helm } from 'cdk8s' new Helm ( scope : Construct , id : string , props : HelmProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s.HelmProps Properties \u00b6 releaseName Required \u00b6 public readonly releaseName : string ; Type: string The helm release name. Include \u00b6 Reads a YAML manifest from a file or a URL and defines all resources as API objects within the defined scope. The names ( metadata.name ) of imported resources will be preserved as-is from the manifest. Initializers \u00b6 import { Include } from 'cdk8s' new Include ( scope : Construct , id : string , props : IncludeProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s.IncludeProps Properties \u00b6 apiObjects Required \u00b6 public readonly apiObjects : ApiObject []; Type: cdk8s.ApiObject [] Returns all the included API objects. Structs \u00b6 ApiObjectMetadata \u00b6 Metadata associated with this object. Initializer \u00b6 import { ApiObjectMetadata } from 'cdk8s' const apiObjectMetadata : ApiObjectMetadata = { ... } annotations Optional \u00b6 public readonly annotations : {[ key : string ] : string }; Type: {[ key: string ]: string } Default: No annotations. Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. http://kubernetes.io/docs/user-guide/annotations finalizers Optional \u00b6 public readonly finalizers : string []; Type: string [] Default: No finalizers. Namespaced keys that tell Kubernetes to wait until specific conditions are met before it fully deletes resources marked for deletion. Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order. Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list. https://kubernetes.io/docs/concepts/overview/working-with-objects/finalizers/ labels Optional \u00b6 public readonly labels : {[ key : string ] : string }; Type: {[ key: string ]: string } Default: No labels. Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. http://kubernetes.io/docs/user-guide/labels name Optional \u00b6 public readonly name : string ; Type: string Default: an app-unique name generated by the chart The unique, namespace-global, name of this object inside the Kubernetes cluster. Normally, you shouldn\u2019t specify names for objects and let the CDK generate a name for you that is application-unique. The names CDK generates are composed from the construct path components, separated by dots and a suffix that is based on a hash of the entire path, to ensure uniqueness. You can supply custom name allocation logic by overriding the chart.generateObjectName method. If you use an explicit name here, bear in mind that this reduces the composability of your construct because it won\u2019t be possible to include more than one instance in any app. Therefore it is highly recommended to leave this unspecified. namespace Optional \u00b6 public readonly namespace : string ; Type: string Default: undefined (will be assigned to the \u2018default\u2019 namespace) Namespace defines the space within each name must be unique. An empty namespace is equivalent to the \u201cdefault\u201d namespace, but \u201cdefault\u201d is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty. Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces ownerReferences Optional \u00b6 public readonly ownerReferences : OwnerReference []; Type: cdk8s.OwnerReference [] Default: automatically set by Kubernetes List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller. Kubernetes sets the value of this field automatically for objects that are dependents of other objects like ReplicaSets, DaemonSets, Deployments, Jobs and CronJobs, and ReplicationControllers. You can also configure these relationships manually by changing the value of this field. However, you usually don\u2019t need to and can allow Kubernetes to automatically manage the relationships. https://kubernetes.io/docs/concepts/overview/working-with-objects/owners-dependents/ ApiObjectProps \u00b6 Options for defining API objects. Initializer \u00b6 import { ApiObjectProps } from 'cdk8s' const apiObjectProps : ApiObjectProps = { ... } apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string API version. kind Required \u00b6 public readonly kind : string ; Type: string Resource kind. metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Object metadata. If name is not specified, an app-unique name will be allocated by the framework based on the path of the construct within thes construct tree. AppProps \u00b6 Initializer \u00b6 import { AppProps } from 'cdk8s' const appProps : AppProps = { ... } outdir Optional \u00b6 public readonly outdir : string ; Type: string Default: CDK8S_OUTDIR if defined, otherwise \u201cdist\u201d The directory to output Kubernetes manifests. yamlOutputType Optional \u00b6 public readonly yamlOutputType : YamlOutputType ; Type: cdk8s.YamlOutputType Default: YamlOutputType.FILE_PER_CHART How to divide the YAML output into files. ChartProps \u00b6 Initializer \u00b6 import { ChartProps } from 'cdk8s' const chartProps : ChartProps = { ... } labels Optional \u00b6 public readonly labels : {[ key : string ] : string }; Type: {[ key: string ]: string } Default: no common labels Labels to apply to all resources in this chart. namespace Optional \u00b6 public readonly namespace : string ; Type: string Default: no namespace is synthesized (usually this implies \u201cdefault\u201d) The default namespace for all objects defined in this chart (directly or indirectly). This namespace will only apply to objects that don\u2019t have a namespace explicitly defined for them. GroupVersionKind \u00b6 Initializer \u00b6 import { GroupVersionKind } from 'cdk8s' const groupVersionKind : GroupVersionKind = { ... } apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string The object\u2019s API version (e.g. authorization.k8s.io/v1 ). kind Required \u00b6 public readonly kind : string ; Type: string The object kind. HelmProps \u00b6 Options for Helm . Initializer \u00b6 import { HelmProps } from 'cdk8s' const helmProps : HelmProps = { ... } chart Required \u00b6 public readonly chart : string ; Type: string The chart name to use. It can be a chart from a helm repository or a local directory. This name is passed to helm template and has all the relevant semantics. helmExecutable Optional \u00b6 public readonly helmExecutable : string ; Type: string Default: \u201chelm\u201d The local helm executable to use in order to create the manifest the chart. helmFlags Optional \u00b6 public readonly helmFlags : string []; Type: string [] Default: [] Additional flags to add to the helm execution. releaseName Optional \u00b6 public readonly releaseName : string ; Type: string Default: if unspecified, a name will be allocated based on the construct path The release name. https://helm.sh/docs/intro/using_helm/#three-big-concepts values Optional \u00b6 public readonly values : {[ key : string ] : any }; Type: {[ key: string ]: any } Default: If no values are specified, chart will use the defaults. Values to pass to the chart. IncludeProps \u00b6 Initializer \u00b6 import { IncludeProps } from 'cdk8s' const includeProps : IncludeProps = { ... } url Required \u00b6 public readonly url : string ; Type: string Local file path or URL which includes a Kubernetes YAML manifest. NameOptions \u00b6 Options for name generation. Initializer \u00b6 import { NameOptions } from 'cdk8s' const nameOptions : NameOptions = { ... } delimiter Optional \u00b6 public readonly delimiter : string ; Type: string Default: \u201c-\u201c Delimiter to use between components. extra Optional \u00b6 public readonly extra : string []; Type: string [] Default: [] use the construct path components Extra components to include in the name. includeHash Optional \u00b6 public readonly includeHash : boolean ; Type: boolean Default: true Include a short hash as last part of the name. maxLen Optional \u00b6 public readonly maxLen : number ; Type: number Default: 63 Maximum allowed length for the name. OwnerReference \u00b6 OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field. Initializer \u00b6 import { OwnerReference } from 'cdk8s' const ownerReference : OwnerReference = { ... } apiVersion Required \u00b6 public readonly apiVersion : string ; Type: string API version of the referent. kind Required \u00b6 public readonly kind : string ; Type: string Kind of the referent. https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds name Required \u00b6 public readonly name : string ; Type: string Name of the referent. http://kubernetes.io/docs/user-guide/identifiers#names uid Required \u00b6 public readonly uid : string ; Type: string UID of the referent. http://kubernetes.io/docs/user-guide/identifiers#uids blockOwnerDeletion Optional \u00b6 public readonly blockOwnerDeletion : boolean ; Type: boolean Default: false. To set this field, a user needs \u201cdelete\u201d permission of the owner, otherwise 422 (Unprocessable Entity) will be returned. If true, AND if the owner has the \u201cforegroundDeletion\u201d finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. Defaults to false. To set this field, a user needs \u201cdelete\u201d permission of the owner, otherwise 422 (Unprocessable Entity) will be returned. controller Optional \u00b6 public readonly controller : boolean ; Type: boolean If true, this reference points to the managing controller. SizeConversionOptions \u00b6 Options for how to convert time to a different unit. Initializer \u00b6 import { SizeConversionOptions } from 'cdk8s' const sizeConversionOptions : SizeConversionOptions = { ... } rounding Optional \u00b6 public readonly rounding : SizeRoundingBehavior ; Type: cdk8s.SizeRoundingBehavior Default: SizeRoundingBehavior.FAIL How conversions should behave when it encounters a non-integer result. TimeConversionOptions \u00b6 Options for how to convert time to a different unit. Initializer \u00b6 import { TimeConversionOptions } from 'cdk8s' const timeConversionOptions : TimeConversionOptions = { ... } integral Optional \u00b6 public readonly integral : boolean ; Type: boolean Default: true If true , conversions into a larger time unit (e.g. Seconds to Minutes ) will fail if the result is not an integer. Classes \u00b6 ApiObjectMetadataDefinition \u00b6 Object metadata. Initializers \u00b6 import { ApiObjectMetadataDefinition } from 'cdk8s' new ApiObjectMetadataDefinition ( options? : ApiObjectMetadata ) options Optional \u00b6 Type: cdk8s.ApiObjectMetadata Methods \u00b6 add \u00b6 public add ( key : string , value : any ) key Required \u00b6 Type: string Metadata key. value Required \u00b6 Type: any Metadata value. addAnnotation \u00b6 public addAnnotation ( key : string , value : string ) key Required \u00b6 Type: string The key. value Required \u00b6 Type: string The value. addFinalizers \u00b6 public addFinalizers ( finalizers : string ) finalizers Required \u00b6 Type: string the finalizers. addLabel \u00b6 public addLabel ( key : string , value : string ) key Required \u00b6 Type: string The key. value Required \u00b6 Type: string The value. addOwnerReference \u00b6 public addOwnerReference ( owner : OwnerReference ) owner Required \u00b6 Type: cdk8s.OwnerReference the owner. getLabel \u00b6 public getLabel ( key : string ) key Required \u00b6 Type: string the label. toJson \u00b6 public toJson () Properties \u00b6 name Optional \u00b6 public readonly name : string ; Type: string The name of the API object. If a name is specified in metadata.name this will be the name returned. Otherwise, a name will be generated by calling Chart.of(this).generatedObjectName(this) , which by default uses the construct path to generate a DNS-compatible name for the resource. namespace Optional \u00b6 public readonly namespace : string ; Type: string The object\u2019s namespace. DependencyGraph \u00b6 Represents the dependency graph for a given Node. This graph includes the dependency relationships between all nodes in the node (construct) sub-tree who\u2019s root is this Node. Note that this means that lonely nodes (no dependencies and no dependants) are also included in this graph as childless children of the root node of the graph. The graph does not include cross-scope dependencies. That is, if a child on the current scope depends on a node from a different scope, that relationship is not represented in this graph. Initializers \u00b6 import { DependencyGraph } from 'cdk8s' new DependencyGraph ( node : Node ) node Required \u00b6 Type: constructs.Node Methods \u00b6 topology \u00b6 public topology () Properties \u00b6 root Required \u00b6 public readonly root : DependencyVertex ; Type: cdk8s.DependencyVertex Returns the root of the graph. Note that this vertex will always have null as its .value since it is an artifical root that binds all the connected spaces of the graph. DependencyVertex \u00b6 Represents a vertex in the graph. The value of each vertex is an IConstruct that is accessible via the .value getter. Initializers \u00b6 import { DependencyVertex } from 'cdk8s' new DependencyVertex ( value? : IConstruct ) value Optional \u00b6 Type: constructs.IConstruct Methods \u00b6 addChild \u00b6 public addChild ( dep : DependencyVertex ) dep Required \u00b6 Type: cdk8s.DependencyVertex The dependency. topology \u00b6 public topology () Properties \u00b6 inbound Required \u00b6 public readonly inbound : DependencyVertex []; Type: cdk8s.DependencyVertex [] Returns the parents of the vertex (i.e dependants). outbound Required \u00b6 public readonly outbound : DependencyVertex []; Type: cdk8s.DependencyVertex [] Returns the children of the vertex (i.e dependencies). value Optional \u00b6 public readonly value : IConstruct ; Type: constructs.IConstruct Returns the IConstruct this graph vertex represents. null in case this is the root of the graph. Duration \u00b6 Represents a length of time. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative. Methods \u00b6 toDays \u00b6 public toDays ( opts? : TimeConversionOptions ) opts Optional \u00b6 Type: cdk8s.TimeConversionOptions toHours \u00b6 public toHours ( opts? : TimeConversionOptions ) opts Optional \u00b6 Type: cdk8s.TimeConversionOptions toHumanString \u00b6 public toHumanString () toIsoString \u00b6 public toIsoString () toMilliseconds \u00b6 public toMilliseconds ( opts? : TimeConversionOptions ) opts Optional \u00b6 Type: cdk8s.TimeConversionOptions toMinutes \u00b6 public toMinutes ( opts? : TimeConversionOptions ) opts Optional \u00b6 Type: cdk8s.TimeConversionOptions toSeconds \u00b6 public toSeconds ( opts? : TimeConversionOptions ) opts Optional \u00b6 Type: cdk8s.TimeConversionOptions Static Functions \u00b6 days \u00b6 import { Duration } from 'cdk8s' Duration . days ( amount : number ) amount Required \u00b6 Type: number the amount of Days the Duration will represent. hours \u00b6 import { Duration } from 'cdk8s' Duration . hours ( amount : number ) amount Required \u00b6 Type: number the amount of Hours the Duration will represent. millis \u00b6 import { Duration } from 'cdk8s' Duration . millis ( amount : number ) amount Required \u00b6 Type: number the amount of Milliseconds the Duration will represent. minutes \u00b6 import { Duration } from 'cdk8s' Duration . minutes ( amount : number ) amount Required \u00b6 Type: number the amount of Minutes the Duration will represent. parse \u00b6 import { Duration } from 'cdk8s' Duration . parse ( duration : string ) duration Required \u00b6 Type: string an ISO-formtted duration to be parsed. seconds \u00b6 import { Duration } from 'cdk8s' Duration . seconds ( amount : number ) amount Required \u00b6 Type: number the amount of Seconds the Duration will represent. JsonPatch \u00b6 Utility for applying RFC-6902 JSON-Patch to a document. Use the the JsonPatch.apply(doc, ...ops) function to apply a set of operations to a JSON document and return the result. Operations can be created using the factory methods JsonPatch.add() , JsonPatch.remove() , etc. Static Functions \u00b6 add \u00b6 import { JsonPatch } from 'cdk8s' JsonPatch . add ( path : string , value : any ) path Required \u00b6 Type: string value Required \u00b6 Type: any apply \u00b6 import { JsonPatch } from 'cdk8s' JsonPatch . apply ( document : any , ops : JsonPatch ) document Required \u00b6 Type: any The document to patch. ops Required \u00b6 Type: cdk8s.JsonPatch The operations to apply. copy \u00b6 import { JsonPatch } from 'cdk8s' JsonPatch . copy ( from : string , path : string ) from Required \u00b6 Type: string path Required \u00b6 Type: string move \u00b6 import { JsonPatch } from 'cdk8s' JsonPatch . move ( from : string , path : string ) from Required \u00b6 Type: string path Required \u00b6 Type: string remove \u00b6 import { JsonPatch } from 'cdk8s' JsonPatch . remove ( path : string ) path Required \u00b6 Type: string replace \u00b6 import { JsonPatch } from 'cdk8s' JsonPatch . replace ( path : string , value : any ) path Required \u00b6 Type: string value Required \u00b6 Type: any test \u00b6 import { JsonPatch } from 'cdk8s' JsonPatch . test ( path : string , value : any ) path Required \u00b6 Type: string value Required \u00b6 Type: any Lazy \u00b6 Methods \u00b6 produce \u00b6 public produce () Static Functions \u00b6 any \u00b6 import { Lazy } from 'cdk8s' Lazy . any ( producer : IAnyProducer ) producer Required \u00b6 Type: cdk8s.IAnyProducer Names \u00b6 Utilities for generating unique and stable names. Static Functions \u00b6 toDnsLabel \u00b6 import { Names } from 'cdk8s' Names . toDnsLabel ( scope : Construct , options? : NameOptions ) scope Required \u00b6 Type: constructs.Construct The construct for which to render the DNS label. options Optional \u00b6 Type: cdk8s.NameOptions Name options. toLabelValue \u00b6 import { Names } from 'cdk8s' Names . toLabelValue ( scope : Construct , options? : NameOptions ) scope Required \u00b6 Type: constructs.Construct The construct for which to render the DNS label. options Optional \u00b6 Type: cdk8s.NameOptions Name options. Size \u00b6 Represents the amount of digital storage. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative. When the amount is passed as a token, unit conversion is not possible. Methods \u00b6 toGibibytes \u00b6 public toGibibytes ( opts? : SizeConversionOptions ) opts Optional \u00b6 Type: cdk8s.SizeConversionOptions toKibibytes \u00b6 public toKibibytes ( opts? : SizeConversionOptions ) opts Optional \u00b6 Type: cdk8s.SizeConversionOptions toMebibytes \u00b6 public toMebibytes ( opts? : SizeConversionOptions ) opts Optional \u00b6 Type: cdk8s.SizeConversionOptions toPebibytes \u00b6 public toPebibytes ( opts? : SizeConversionOptions ) opts Optional \u00b6 Type: cdk8s.SizeConversionOptions toTebibytes \u00b6 public toTebibytes ( opts? : SizeConversionOptions ) opts Optional \u00b6 Type: cdk8s.SizeConversionOptions Static Functions \u00b6 gibibytes \u00b6 import { Size } from 'cdk8s' Size . gibibytes ( amount : number ) amount Required \u00b6 Type: number kibibytes \u00b6 import { Size } from 'cdk8s' Size . kibibytes ( amount : number ) amount Required \u00b6 Type: number mebibytes \u00b6 import { Size } from 'cdk8s' Size . mebibytes ( amount : number ) amount Required \u00b6 Type: number pebibyte \u00b6 import { Size } from 'cdk8s' Size . pebibyte ( amount : number ) amount Required \u00b6 Type: number tebibytes \u00b6 import { Size } from 'cdk8s' Size . tebibytes ( amount : number ) amount Required \u00b6 Type: number Testing \u00b6 Testing utilities for cdk8s applications. Static Functions \u00b6 app \u00b6 import { Testing } from 'cdk8s' Testing . app ( props? : AppProps ) props Optional \u00b6 Type: cdk8s.AppProps chart \u00b6 import { Testing } from 'cdk8s' Testing . chart () synth \u00b6 import { Testing } from 'cdk8s' Testing . synth ( chart : Chart ) chart Required \u00b6 Type: cdk8s.Chart Yaml \u00b6 YAML utilities. Static Functions \u00b6 ~~ formatObjects ~~ \u00b6 import { Yaml } from 'cdk8s' Yaml . formatObjects ( docs : any []) docs Required \u00b6 Type: any [] load \u00b6 import { Yaml } from 'cdk8s' Yaml . load ( urlOrFile : string ) urlOrFile Required \u00b6 Type: string a URL of a file path to load from. save \u00b6 import { Yaml } from 'cdk8s' Yaml . save ( filePath : string , docs : any []) filePath Required \u00b6 Type: string The output path. docs Required \u00b6 Type: any [] The set of objects. stringify \u00b6 import { Yaml } from 'cdk8s' Yaml . stringify ( docs : any ) docs Required \u00b6 Type: any A set of objects to convert to YAML. tmp \u00b6 import { Yaml } from 'cdk8s' Yaml . tmp ( docs : any []) docs Required \u00b6 Type: any [] the set of documents to save. Protocols \u00b6 IAnyProducer \u00b6 Implemented By: cdk8s.IAnyProducer Methods \u00b6 produce \u00b6 public produce () Enums \u00b6 SizeRoundingBehavior \u00b6 Rounding behaviour when converting between units of Size . FAIL \u00b6 Fail the conversion if the result is not an integer. FLOOR \u00b6 If the result is not an integer, round it to the closest integer less than the result. NONE \u00b6 Don\u2019t round. Return even if the result is a fraction. YamlOutputType \u00b6 The method to divide YAML output into files. FILE_PER_APP \u00b6 All resources are output into a single YAML file. FILE_PER_CHART \u00b6 Resources are split into seperate files by chart. FILE_PER_RESOURCE \u00b6 Each resource is output to its own file.","title":"TypeScript"},{"location":"reference/cdk8s/typescript/#cdk8s-typescript","text":"","title":"cdk8s (TypeScript) "},{"location":"reference/cdk8s/typescript/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s/typescript/#apiobject","text":"","title":"ApiObject "},{"location":"reference/cdk8s/typescript/#app","text":"Represents a cdk8s application.","title":"App "},{"location":"reference/cdk8s/typescript/#chart","text":"","title":"Chart "},{"location":"reference/cdk8s/typescript/#helm","text":"Represents a Helm deployment. Use this construct to import an existing Helm chart and incorporate it into your constructs.","title":"Helm "},{"location":"reference/cdk8s/typescript/#include","text":"Reads a YAML manifest from a file or a URL and defines all resources as API objects within the defined scope. The names ( metadata.name ) of imported resources will be preserved as-is from the manifest.","title":"Include "},{"location":"reference/cdk8s/typescript/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s/typescript/#apiobjectmetadata","text":"Metadata associated with this object.","title":"ApiObjectMetadata "},{"location":"reference/cdk8s/typescript/#apiobjectprops","text":"Options for defining API objects.","title":"ApiObjectProps "},{"location":"reference/cdk8s/typescript/#appprops","text":"","title":"AppProps "},{"location":"reference/cdk8s/typescript/#chartprops","text":"","title":"ChartProps "},{"location":"reference/cdk8s/typescript/#groupversionkind","text":"","title":"GroupVersionKind "},{"location":"reference/cdk8s/typescript/#helmprops","text":"Options for Helm .","title":"HelmProps "},{"location":"reference/cdk8s/typescript/#includeprops","text":"","title":"IncludeProps "},{"location":"reference/cdk8s/typescript/#nameoptions","text":"Options for name generation.","title":"NameOptions "},{"location":"reference/cdk8s/typescript/#ownerreference","text":"OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field.","title":"OwnerReference "},{"location":"reference/cdk8s/typescript/#sizeconversionoptions","text":"Options for how to convert time to a different unit.","title":"SizeConversionOptions "},{"location":"reference/cdk8s/typescript/#timeconversionoptions","text":"Options for how to convert time to a different unit.","title":"TimeConversionOptions "},{"location":"reference/cdk8s/typescript/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s/typescript/#apiobjectmetadatadefinition","text":"Object metadata.","title":"ApiObjectMetadataDefinition "},{"location":"reference/cdk8s/typescript/#dependencygraph","text":"Represents the dependency graph for a given Node. This graph includes the dependency relationships between all nodes in the node (construct) sub-tree who\u2019s root is this Node. Note that this means that lonely nodes (no dependencies and no dependants) are also included in this graph as childless children of the root node of the graph. The graph does not include cross-scope dependencies. That is, if a child on the current scope depends on a node from a different scope, that relationship is not represented in this graph.","title":"DependencyGraph "},{"location":"reference/cdk8s/typescript/#dependencyvertex","text":"Represents a vertex in the graph. The value of each vertex is an IConstruct that is accessible via the .value getter.","title":"DependencyVertex "},{"location":"reference/cdk8s/typescript/#duration","text":"Represents a length of time. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative.","title":"Duration "},{"location":"reference/cdk8s/typescript/#jsonpatch","text":"Utility for applying RFC-6902 JSON-Patch to a document. Use the the JsonPatch.apply(doc, ...ops) function to apply a set of operations to a JSON document and return the result. Operations can be created using the factory methods JsonPatch.add() , JsonPatch.remove() , etc.","title":"JsonPatch "},{"location":"reference/cdk8s/typescript/#lazy","text":"","title":"Lazy "},{"location":"reference/cdk8s/typescript/#names","text":"Utilities for generating unique and stable names.","title":"Names "},{"location":"reference/cdk8s/typescript/#size","text":"Represents the amount of digital storage. The amount can be specified either as a literal value (e.g: 10 ) which cannot be negative. When the amount is passed as a token, unit conversion is not possible.","title":"Size "},{"location":"reference/cdk8s/typescript/#testing","text":"Testing utilities for cdk8s applications.","title":"Testing "},{"location":"reference/cdk8s/typescript/#yaml","text":"YAML utilities.","title":"Yaml "},{"location":"reference/cdk8s/typescript/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s/typescript/#ianyproducer","text":"Implemented By: cdk8s.IAnyProducer","title":"IAnyProducer "},{"location":"reference/cdk8s/typescript/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s/typescript/#sizeroundingbehavior","text":"Rounding behaviour when converting between units of Size .","title":"SizeRoundingBehavior "},{"location":"reference/cdk8s/typescript/#yamloutputtype","text":"The method to divide YAML output into files.","title":"YamlOutputType "},{"location":"reference/cdk8s-plus-17/go/","text":"cdk8s-plus-17 (Go) \u00b6 For Go API reference, please visit https://pkg.go.dev/github.com/cdk8s-team/cdk8s-plus-17-go/cdk8splus17 .","title":"Go"},{"location":"reference/cdk8s-plus-17/go/#cdk8s-plus-17-go","text":"For Go API reference, please visit https://pkg.go.dev/github.com/cdk8s-team/cdk8s-plus-17-go/cdk8splus17 .","title":"cdk8s-plus-17 (Go) "},{"location":"reference/cdk8s-plus-17/java/","text":"cdk8s-plus-17 (Java) \u00b6 Constructs \u00b6 ConfigMap \u00b6 Implements: org.cdk8s.plus17.IConfigMap ConfigMap holds configuration data for pods to consume. Initializers \u00b6 import org.cdk8s.plus17.ConfigMap ; ConfigMap . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .binaryData(java.util.Map<java.lang.String, java.lang.String>) // .data(java.util.Map<java.lang.String, java.lang.String>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binaryData Optional \u00b6 Type: java.util.Map java.lang.String > BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. Using this field will require 1.10+ apiserver and kubelet. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 Type: java.util.Map java.lang.String > Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . Methods \u00b6 addBinaryData \u00b6 public addBinaryData ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String The key. value Required \u00b6 Type: java.lang.String The value. addData \u00b6 public addData ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String The key. value Required \u00b6 Type: java.lang.String The value. addDirectory \u00b6 public addDirectory ( java . lang . String localDir ) public addDirectory ( java . lang . String localDir , AddDirectoryOptions options ) localDir Required \u00b6 Type: java.lang.String A path to a local directory. options Optional \u00b6 Type: org.cdk8s.plus17.AddDirectoryOptions Options. addFile \u00b6 public addFile ( java . lang . String localFile ) public addFile ( java . lang . String localFile , java . lang . String key ) localFile Required \u00b6 Type: java.lang.String The path to the local file. key Optional \u00b6 Type: java.lang.String The ConfigMap key (default to the file name). Static Functions \u00b6 fromConfigMapName \u00b6 import org.cdk8s.plus17.ConfigMap ; ConfigMap . fromConfigMapName ( java . lang . String name ) name Required \u00b6 Type: java.lang.String The name of the config map to import. Properties \u00b6 binaryData Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getBinaryData (); Type: java.util.Map java.lang.String > The binary data associated with this config map. Returns a copy. To add data records, use addBinaryData() or addData() . data Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getData (); Type: java.util.Map java.lang.String > The data associated with this config map. Returns an copy. To add data records, use addData() or addBinaryData() . Deployment \u00b6 Implements: org.cdk8s.plus17.IPodTemplate A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case \u00b6 The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore. Initializers \u00b6 import org.cdk8s.plus17.Deployment ; Deployment . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .defaultSelector(java.lang.Boolean) // .replicas(java.lang.Number) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus17.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 Type: org.cdk8s.plus17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 Type: org.cdk8s.plus17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus17.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata. defaultSelector Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod selector for this deployment. If this is set to false you must define your selector through deployment.podMetadata.addLabel() and deployment.selectByLabel() . replicas Optional \u00b6 Type: java.lang.Number Default: 1 Number of desired pods. Methods \u00b6 addContainer \u00b6 public addContainer ( ContainerProps container ) container Required \u00b6 Type: org.cdk8s.plus17.ContainerProps addVolume \u00b6 public addVolume ( Volume volume ) volume Required \u00b6 Type: org.cdk8s.plus17.Volume expose \u00b6 public expose ( java . lang . Number port ) public expose ( java . lang . Number port , ExposeOptions options ) port Required \u00b6 Type: java.lang.Number The port number the service will bind to. options Optional \u00b6 Type: org.cdk8s.plus17.ExposeOptions Options to determine details of the service and port exposed. selectByLabel \u00b6 public selectByLabel ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String The label key. value Required \u00b6 Type: java.lang.String The label value. Properties \u00b6 containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus17.Container > The containers belonging to the pod. Use addContainer to add containers. labelSelector Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getLabelSelector (); Type: java.util.Map java.lang.String > The labels this deployment will match against in order to select pods. Returns a a copy. Use selectByLabel() to add labels. podMetadata Required \u00b6 public ApiObjectMetadataDefinition getPodMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. replicas Required \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Number of desired pods. volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus17.Volume > The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus17.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus17.IServiceAccount The service account used to run this pod. IngressV1Beta1 \u00b6 Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. Initializers \u00b6 import org.cdk8s.plus17.IngressV1Beta1 ; IngressV1Beta1 . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .defaultBackend(IngressV1Beta1Backend) // .rules(java.util.List<IngressV1Beta1Rule>) // .tls(java.util.List<IngressV1Beta1Tls>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. defaultBackend Optional \u00b6 Type: org.cdk8s.plus17.IngressV1Beta1Backend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 Type: java.util.List< org.cdk8s.plus17.IngressV1Beta1Rule > Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 Type: java.util.List< org.cdk8s.plus17.IngressV1Beta1Tls > TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. Methods \u00b6 addDefaultBackend \u00b6 public addDefaultBackend ( IngressV1Beta1Backend backend ) backend Required \u00b6 Type: org.cdk8s.plus17.IngressV1Beta1Backend The backend to use for requests that do not match any rule. addHostDefaultBackend \u00b6 public addHostDefaultBackend ( java . lang . String host , IngressV1Beta1Backend backend ) host Required \u00b6 Type: java.lang.String The host name to match. backend Required \u00b6 Type: org.cdk8s.plus17.IngressV1Beta1Backend The backend to route to. addHostRule \u00b6 public addHostRule ( java . lang . String host , java . lang . String path , IngressV1Beta1Backend backend ) host Required \u00b6 Type: java.lang.String The host name. path Required \u00b6 Type: java.lang.String The HTTP path. backend Required \u00b6 Type: org.cdk8s.plus17.IngressV1Beta1Backend The backend to route requests to. addRule \u00b6 public addRule ( java . lang . String path , IngressV1Beta1Backend backend ) path Required \u00b6 Type: java.lang.String The HTTP path. backend Required \u00b6 Type: org.cdk8s.plus17.IngressV1Beta1Backend The backend to route requests to. addRules \u00b6 public addRules ( IngressV1Beta1Rule rules ) rules Required \u00b6 Type: org.cdk8s.plus17.IngressV1Beta1Rule The rules to add. addTls \u00b6 public addTls ( java . util . List < IngressV1Beta1Tls > tls ) tls Required \u00b6 Type: java.util.List< org.cdk8s.plus17.IngressV1Beta1Tls > Job \u00b6 Implements: org.cdk8s.plus17.IPodTemplate A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel. Initializers \u00b6 import org.cdk8s.plus17.Job ; Job . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .activeDeadline(Duration) // .backoffLimit(java.lang.Number) // .ttlAfterFinished(Duration) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus17.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 Type: org.cdk8s.plus17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 Type: org.cdk8s.plus17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus17.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata. activeDeadline Optional \u00b6 Type: org.cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 Type: java.lang.Number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 Type: org.cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. Methods \u00b6 addContainer \u00b6 public addContainer ( ContainerProps container ) container Required \u00b6 Type: org.cdk8s.plus17.ContainerProps addVolume \u00b6 public addVolume ( Volume volume ) volume Required \u00b6 Type: org.cdk8s.plus17.Volume Properties \u00b6 containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus17.Container > The containers belonging to the pod. Use addContainer to add containers. podMetadata Required \u00b6 public ApiObjectMetadataDefinition getPodMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus17.Volume > The volumes associated with this pod. Use addVolume to add volumes. activeDeadline Optional \u00b6 public Duration getActiveDeadline (); Type: org.cdk8s.Duration Duration before job is terminated. If undefined, there is no deadline. backoffLimit Optional \u00b6 public java . lang . Number getBackoffLimit (); Type: java.lang.Number Number of retries before marking failed. restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus17.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus17.IServiceAccount The service account used to run this pod. ttlAfterFinished Optional \u00b6 public Duration getTtlAfterFinished (); Type: org.cdk8s.Duration TTL before the job is deleted after it is finished. Pod \u00b6 Implements: org.cdk8s.plus17.IPodSpec Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts. Initializers \u00b6 import org.cdk8s.plus17.Pod ; Pod . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus17.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 Type: org.cdk8s.plus17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 Type: org.cdk8s.plus17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus17.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Methods \u00b6 addContainer \u00b6 public addContainer ( ContainerProps container ) container Required \u00b6 Type: org.cdk8s.plus17.ContainerProps addVolume \u00b6 public addVolume ( Volume volume ) volume Required \u00b6 Type: org.cdk8s.plus17.Volume Properties \u00b6 containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus17.Container > The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus17.Volume > The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus17.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus17.IServiceAccount The service account used to run this pod. Resource \u00b6 Implements: org.cdk8s.plus17.IResource Base class for all Kubernetes objects in stdk8s. Represents a single resource. Initializers \u00b6 import org.cdk8s.plus17.Resource ; Resource . Builder . create ( Construct scope , java . lang . String id ) // .nodeFactory(INodeFactory) . build (); scope Required \u00b6 Type: software.constructs.Construct The scope in which to define this construct. id Required \u00b6 Type: java.lang.String The scoped construct ID. Must be unique amongst siblings. If the ID includes a path separator ( / ), then it will be replaced by double dash -- . nodeFactory Optional \u00b6 Type: software.constructs.INodeFactory Default: the default Node is associated A factory for attaching Node s to the construct. Properties \u00b6 metadata Required \u00b6 public ApiObjectMetadataDefinition getMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this API object. Secret \u00b6 Implements: org.cdk8s.plus17.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret Initializers \u00b6 import org.cdk8s.plus17.Secret ; Secret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .stringData(java.util.Map<java.lang.String, java.lang.String>) // .type(java.lang.String) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. stringData Optional \u00b6 Type: java.util.Map java.lang.String > stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 Type: java.lang.String Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. Methods \u00b6 addStringData \u00b6 public addStringData ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String Key. value Required \u00b6 Type: java.lang.String Value. getStringData \u00b6 public getStringData ( java . lang . String key ) key Required \u00b6 Type: java.lang.String Key. Static Functions \u00b6 fromSecretName \u00b6 import org.cdk8s.plus17.Secret ; Secret . fromSecretName ( java . lang . String name ) name Required \u00b6 Type: java.lang.String The name of the secret to reference. Service \u00b6 An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods. Initializers \u00b6 import org.cdk8s.plus17.Service ; Service . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .clusterIP(java.lang.String) // .externalIPs(java.util.List<java.lang.String>) // .externalName(java.lang.String) // .loadBalancerSourceRanges(java.util.List<java.lang.String>) // .ports(java.util.List<ServicePort>) // .type(ServiceType) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. clusterIP Optional \u00b6 Type: java.lang.String Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies externalIPs Optional \u00b6 Type: java.util.List< java.lang.String > Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. externalName Optional \u00b6 Type: java.lang.String Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. loadBalancerSourceRanges Optional \u00b6 Type: java.util.List< java.lang.String > A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 Type: java.util.List< org.cdk8s.plus17.ServicePort > The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 Type: org.cdk8s.plus17.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types Methods \u00b6 addDeployment \u00b6 public addDeployment ( Deployment deployment , java . lang . Number port ) public addDeployment ( Deployment deployment , java . lang . Number port , ServicePortOptions options ) deployment Required \u00b6 Type: org.cdk8s.plus17.Deployment The deployment to expose. port Required \u00b6 Type: java.lang.Number The external port. options Optional \u00b6 Type: org.cdk8s.plus17.ServicePortOptions Optional settings for the port. addSelector \u00b6 public addSelector ( java . lang . String label , java . lang . String value ) label Required \u00b6 Type: java.lang.String The label key. value Required \u00b6 Type: java.lang.String The label value. serve \u00b6 public serve ( java . lang . Number port ) public serve ( java . lang . Number port , ServicePortOptions options ) port Required \u00b6 Type: java.lang.Number The port definition. options Optional \u00b6 Type: org.cdk8s.plus17.ServicePortOptions Properties \u00b6 ports Required \u00b6 public java . util . List < ServicePort > getPorts (); Type: java.util.List< org.cdk8s.plus17.ServicePort > Ports for this service. Use serve() to expose additional service ports. selector Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getSelector (); Type: java.util.Map java.lang.String > Returns the labels which are used to select pods for this service. type Required \u00b6 public ServiceType getType (); Type: org.cdk8s.plus17.ServiceType Determines how the Service is exposed. clusterIP Optional \u00b6 public java . lang . String getClusterIP (); Type: java.lang.String The IP address of the service and is usually assigned randomly by the master. externalName Optional \u00b6 public java . lang . String getExternalName (); Type: java.lang.String The externalName to be used for EXTERNAL_NAME types. ServiceAccount \u00b6 Implements: org.cdk8s.plus17.IServiceAccount A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account Initializers \u00b6 import org.cdk8s.plus17.ServiceAccount ; ServiceAccount . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .secrets(java.util.List<ISecret>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. secrets Optional \u00b6 Type: java.util.List< org.cdk8s.plus17.ISecret > List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret Methods \u00b6 addSecret \u00b6 public addSecret ( ISecret secret ) secret Required \u00b6 Type: org.cdk8s.plus17.ISecret The secret. Static Functions \u00b6 fromServiceAccountName \u00b6 import org.cdk8s.plus17.ServiceAccount ; ServiceAccount . fromServiceAccountName ( java . lang . String name ) name Required \u00b6 Type: java.lang.String The name of the service account resource. Properties \u00b6 secrets Required \u00b6 public java . util . List < ISecret > getSecrets (); Type: java.util.List< org.cdk8s.plus17.ISecret > List of secrets allowed to be used by pods running using this service account. Returns a copy. To add a secret, use addSecret() . StatefulSet \u00b6 Implements: org.cdk8s.plus17.IPodTemplate StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed. Using StatefulSets \u00b6 StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates. Initializers \u00b6 import org.cdk8s.plus17.StatefulSet ; StatefulSet . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) . service ( Service ) // .defaultSelector(java.lang.Boolean) // .podManagementPolicy(PodManagementPolicy) // .replicas(java.lang.Number) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus17.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 Type: org.cdk8s.plus17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 Type: org.cdk8s.plus17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus17.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata. service Required \u00b6 Type: org.cdk8s.plus17.Service Service to associate with the statefulset. defaultSelector Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod selector for this statefulset. If this is set to false you must define your selector through statefulset.podMetadata.addLabel() and statefulset.selectByLabel() . podManagementPolicy Optional \u00b6 Type: org.cdk8s.plus17.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 Type: java.lang.Number Default: 1 Number of desired pods. Methods \u00b6 addContainer \u00b6 public addContainer ( ContainerProps container ) container Required \u00b6 Type: org.cdk8s.plus17.ContainerProps addVolume \u00b6 public addVolume ( Volume volume ) volume Required \u00b6 Type: org.cdk8s.plus17.Volume selectByLabel \u00b6 public selectByLabel ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String The label key. value Required \u00b6 Type: java.lang.String The label value. Properties \u00b6 containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus17.Container > The containers belonging to the pod. Use addContainer to add containers. labelSelector Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getLabelSelector (); Type: java.util.Map java.lang.String > The labels this statefulset will match against in order to select pods. Returns a a copy. Use selectByLabel() to add labels. podManagementPolicy Required \u00b6 public PodManagementPolicy getPodManagementPolicy (); Type: org.cdk8s.plus17.PodManagementPolicy Management policy to use for the set. podMetadata Required \u00b6 public ApiObjectMetadataDefinition getPodMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. replicas Required \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Number of desired pods. volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus17.Volume > The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus17.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus17.IServiceAccount The service account used to run this pod. Structs \u00b6 AddDirectoryOptions \u00b6 Options for configmap.addDirectory() . Initializer \u00b6 import org.cdk8s.plus17.AddDirectoryOptions ; AddDirectoryOptions . builder () // .exclude(java.util.List<java.lang.String>) // .keyPrefix(java.lang.String) . build (); exclude Optional \u00b6 public java . util . List < java . lang . String > getExclude (); Type: java.util.List< java.lang.String > Default: include all files Glob patterns to exclude when adding files. keyPrefix Optional \u00b6 public java . lang . String getKeyPrefix (); Type: java.lang.String Default: \u201c\u201d A prefix to add to all keys in the config map. CommandProbeOptions \u00b6 Options for Probe.fromCommand() . Initializer \u00b6 import org.cdk8s.plus17.CommandProbeOptions ; CommandProbeOptions . builder () // .failureThreshold(java.lang.Number) // .initialDelaySeconds(Duration) // .periodSeconds(Duration) // .successThreshold(java.lang.Number) // .timeoutSeconds(Duration) . build (); failureThreshold Optional \u00b6 public java . lang . Number getFailureThreshold (); Type: java.lang.Number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public Duration getInitialDelaySeconds (); Type: org.cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public Duration getPeriodSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public java . lang . Number getSuccessThreshold (); Type: java.lang.Number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public Duration getTimeoutSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ConfigMapProps \u00b6 Properties for initialization of ConfigMap . Initializer \u00b6 import org.cdk8s.plus17.ConfigMapProps ; ConfigMapProps . builder () // .metadata(ApiObjectMetadata) // .binaryData(java.util.Map<java.lang.String, java.lang.String>) // .data(java.util.Map<java.lang.String, java.lang.String>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binaryData Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getBinaryData (); Type: java.util.Map java.lang.String > BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. Using this field will require 1.10+ apiserver and kubelet. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getData (); Type: java.util.Map java.lang.String > Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . ConfigMapVolumeOptions \u00b6 Options for the ConfigMap-based volume. Initializer \u00b6 import org.cdk8s.plus17.ConfigMapVolumeOptions ; ConfigMapVolumeOptions . builder () // .defaultMode(java.lang.Number) // .items(java.util.Map<java.lang.String, PathMapping>) // .name(java.lang.String) // .optional(java.lang.Boolean) . build (); defaultMode Optional \u00b6 public java . lang . Number getDefaultMode (); Type: java.lang.Number Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 public java . util . Map < java . lang . String , PathMapping > getItems (); Type: java.util.Map \u0002klzzwxh:3194\u0003 > Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto-generated The volume name. optional Optional \u00b6 public java . lang . Boolean getOptional (); Type: java.lang.Boolean Default: undocumented Specify whether the ConfigMap or its keys must be defined. ContainerProps \u00b6 Properties for creating a container. Initializer \u00b6 import org.cdk8s.plus17.ContainerProps ; ContainerProps . builder () . image ( java . lang . String ) // .args(java.util.List<java.lang.String>) // .command(java.util.List<java.lang.String>) // .env(java.util.Map<java.lang.String, EnvValue>) // .imagePullPolicy(ImagePullPolicy) // .liveness(Probe) // .name(java.lang.String) // .port(java.lang.Number) // .readiness(Probe) // .startup(Probe) // .volumeMounts(java.util.List<VolumeMount>) // .workingDir(java.lang.String) . build (); image Required \u00b6 public java . lang . String getImage (); Type: java.lang.String Docker image name. args Optional \u00b6 public java . util . List < java . lang . String > getArgs (); Type: java.util.List< java.lang.String > Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 public java . util . List < java . lang . String > getCommand (); Type: java.util.List< java.lang.String > Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 public java . util . Map < java . lang . String , EnvValue > getEnv (); Type: java.util.Map \u0002klzzwxh:3175\u0003 > Default: No environment variables. List of environment variables to set in the container. Cannot be updated. imagePullPolicy Optional \u00b6 public ImagePullPolicy getImagePullPolicy (); Type: org.cdk8s.plus17.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 public Probe getLiveness (); Type: org.cdk8s.plus17.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 public Probe getReadiness (); Type: org.cdk8s.plus17.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 public Probe getStartup (); Type: org.cdk8s.plus17.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volumeMounts Optional \u00b6 public java . util . List < VolumeMount > getVolumeMounts (); Type: java.util.List< org.cdk8s.plus17.VolumeMount > Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. workingDir Optional \u00b6 public java . lang . String getWorkingDir (); Type: java.lang.String Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. DeploymentProps \u00b6 Properties for initialization of Deployment . Initializer \u00b6 import org.cdk8s.plus17.DeploymentProps ; DeploymentProps . builder () // .metadata(ApiObjectMetadata) // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .defaultSelector(java.lang.Boolean) // .replicas(java.lang.Number) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus17.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus17.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata. defaultSelector Optional \u00b6 public java . lang . Boolean getDefaultSelector (); Type: java.lang.Boolean Default: true Automatically allocates a pod selector for this deployment. If this is set to false you must define your selector through deployment.podMetadata.addLabel() and deployment.selectByLabel() . replicas Optional \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Default: 1 Number of desired pods. EmptyDirVolumeOptions \u00b6 Options for volumes populated with an empty directory. Initializer \u00b6 import org.cdk8s.plus17.EmptyDirVolumeOptions ; EmptyDirVolumeOptions . builder () // .medium(EmptyDirMedium) // .sizeLimit(Size) . build (); medium Optional \u00b6 public EmptyDirMedium getMedium (); Type: org.cdk8s.plus17.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. sizeLimit Optional \u00b6 public Size getSizeLimit (); Type: org.cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. EnvValueFromConfigMapOptions \u00b6 Options to specify an envionment variable value from a ConfigMap key. Initializer \u00b6 import org.cdk8s.plus17.EnvValueFromConfigMapOptions ; EnvValueFromConfigMapOptions . builder () // .optional(java.lang.Boolean) . build (); optional Optional \u00b6 public java . lang . Boolean getOptional (); Type: java.lang.Boolean Default: false Specify whether the ConfigMap or its key must be defined. EnvValueFromProcessOptions \u00b6 Options to specify an environment variable value from the process environment. Initializer \u00b6 import org.cdk8s.plus17.EnvValueFromProcessOptions ; EnvValueFromProcessOptions . builder () // .required(java.lang.Boolean) . build (); required Optional \u00b6 public java . lang . Boolean getRequired (); Type: java.lang.Boolean Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. EnvValueFromSecretOptions \u00b6 Options to specify an environment variable value from a Secret. Initializer \u00b6 import org.cdk8s.plus17.EnvValueFromSecretOptions ; EnvValueFromSecretOptions . builder () // .optional(java.lang.Boolean) . build (); optional Optional \u00b6 public java . lang . Boolean getOptional (); Type: java.lang.Boolean Default: false Specify whether the Secret or its key must be defined. ExposeOptions \u00b6 Options for exposing a deployment via a service. Initializer \u00b6 import org.cdk8s.plus17.ExposeOptions ; ExposeOptions . builder () // .name(java.lang.String) // .protocol(Protocol) // .serviceType(ServiceType) // .targetPort(java.lang.Number) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus17.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. serviceType Optional \u00b6 public ServiceType getServiceType (); Type: org.cdk8s.plus17.ServiceType Default: ClusterIP. The type of the exposed service. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. HttpGetProbeOptions \u00b6 Options for Probe.fromHttpGet() . Initializer \u00b6 import org.cdk8s.plus17.HttpGetProbeOptions ; HttpGetProbeOptions . builder () // .failureThreshold(java.lang.Number) // .initialDelaySeconds(Duration) // .periodSeconds(Duration) // .successThreshold(java.lang.Number) // .timeoutSeconds(Duration) // .port(java.lang.Number) . build (); failureThreshold Optional \u00b6 public java . lang . Number getFailureThreshold (); Type: java.lang.Number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public Duration getInitialDelaySeconds (); Type: org.cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public Duration getPeriodSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public java . lang . Number getSuccessThreshold (); Type: java.lang.Number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public Duration getTimeoutSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: defaults to container.port . The TCP port to use when sending the GET request. IngressV1Beta1Props \u00b6 Properties for Ingress . Initializer \u00b6 import org.cdk8s.plus17.IngressV1Beta1Props ; IngressV1Beta1Props . builder () // .metadata(ApiObjectMetadata) // .defaultBackend(IngressV1Beta1Backend) // .rules(java.util.List<IngressV1Beta1Rule>) // .tls(java.util.List<IngressV1Beta1Tls>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. defaultBackend Optional \u00b6 public IngressV1Beta1Backend getDefaultBackend (); Type: org.cdk8s.plus17.IngressV1Beta1Backend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 public java . util . List < IngressV1Beta1Rule > getRules (); Type: java.util.List< org.cdk8s.plus17.IngressV1Beta1Rule > Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 public java . util . List < IngressV1Beta1Tls > getTls (); Type: java.util.List< org.cdk8s.plus17.IngressV1Beta1Tls > TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. IngressV1Beta1Rule \u00b6 Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path. Initializer \u00b6 import org.cdk8s.plus17.IngressV1Beta1Rule ; IngressV1Beta1Rule . builder () . backend ( IngressV1Beta1Backend ) // .host(java.lang.String) // .path(java.lang.String) . build (); backend Required \u00b6 public IngressV1Beta1Backend getBackend (); Type: org.cdk8s.plus17.IngressV1Beta1Backend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 public java . lang . String getHost (); Type: java.lang.String Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 public java . lang . String getPath (); Type: java.lang.String Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. IngressV1Beta1Tls \u00b6 Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination. Initializer \u00b6 import org.cdk8s.plus17.IngressV1Beta1Tls ; IngressV1Beta1Tls . builder () // .hosts(java.util.List<java.lang.String>) // .secret(ISecret) . build (); hosts Optional \u00b6 public java . util . List < java . lang . String > getHosts (); Type: java.util.List< java.lang.String > Default: If unspecified, it defaults to the wildcard host setting for the loadbalancer controller fulfilling this Ingress. Hosts are a list of hosts included in the TLS certificate. The values in this list must match the name/s used in the TLS Secret. secret Optional \u00b6 public ISecret getSecret (); Type: org.cdk8s.plus17.ISecret Default: If unspecified, it allows SSL routing based on SNI hostname. Secret is the secret that contains the certificate and key used to terminate SSL traffic on 443. If the SNI host in a listener conflicts with the \u201cHost\u201d header field used by an IngressRule, the SNI host is used for termination and value of the Host header is used for routing. JobProps \u00b6 Properties for initialization of Job . Initializer \u00b6 import org.cdk8s.plus17.JobProps ; JobProps . builder () // .metadata(ApiObjectMetadata) // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .activeDeadline(Duration) // .backoffLimit(java.lang.Number) // .ttlAfterFinished(Duration) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus17.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus17.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata. activeDeadline Optional \u00b6 public Duration getActiveDeadline (); Type: org.cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 public java . lang . Number getBackoffLimit (); Type: java.lang.Number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 public Duration getTtlAfterFinished (); Type: org.cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. MountOptions \u00b6 Options for mounts. Initializer \u00b6 import org.cdk8s.plus17.MountOptions ; MountOptions . builder () // .propagation(MountPropagation) // .readOnly(java.lang.Boolean) // .subPath(java.lang.String) // .subPathExpr(java.lang.String) . build (); propagation Optional \u00b6 public MountPropagation getPropagation (); Type: org.cdk8s.plus17.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. This field is beta in 1.10. readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public java . lang . String getSubPath (); Type: java.lang.String Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public java . lang . String getSubPathExpr (); Type: java.lang.String Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). SubPathExpr and SubPath are mutually exclusive. This field is beta in 1.15. subPathExpr and subPath are mutually exclusive. This field is beta in 1.15. PathMapping \u00b6 Maps a string key to a path within a volume. Initializer \u00b6 import org.cdk8s.plus17.PathMapping ; PathMapping . builder () . path ( java . lang . String ) // .mode(java.lang.Number) . build (); path Required \u00b6 public java . lang . String getPath (); Type: java.lang.String The relative path of the file to map the key to. May not be an absolute path. May not contain the path element \u2018..\u2019. May not start with the string \u2018..\u2019. mode Optional \u00b6 public java . lang . Number getMode (); Type: java.lang.Number Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. PodProps \u00b6 Properties for initialization of Pod . Initializer \u00b6 import org.cdk8s.plus17.PodProps ; PodProps . builder () // .metadata(ApiObjectMetadata) // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus17.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus17.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodSpecProps \u00b6 Properties of a PodSpec . Initializer \u00b6 import org.cdk8s.plus17.PodSpecProps ; PodSpecProps . builder () // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus17.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus17.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodTemplateProps \u00b6 Properties of a PodTemplate . Adds metadata information on top of the spec. Initializer \u00b6 import org.cdk8s.plus17.PodTemplateProps ; PodTemplateProps . builder () // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) . build (); containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus17.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus17.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata. ProbeOptions \u00b6 Probe options. Initializer \u00b6 import org.cdk8s.plus17.ProbeOptions ; ProbeOptions . builder () // .failureThreshold(java.lang.Number) // .initialDelaySeconds(Duration) // .periodSeconds(Duration) // .successThreshold(java.lang.Number) // .timeoutSeconds(Duration) . build (); failureThreshold Optional \u00b6 public java . lang . Number getFailureThreshold (); Type: java.lang.Number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public Duration getInitialDelaySeconds (); Type: org.cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public Duration getPeriodSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public java . lang . Number getSuccessThreshold (); Type: java.lang.Number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public Duration getTimeoutSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ResourceProps \u00b6 Initialization properties for resources. Initializer \u00b6 import org.cdk8s.plus17.ResourceProps ; ResourceProps . builder () // .metadata(ApiObjectMetadata) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. SecretProps \u00b6 Initializer \u00b6 import org.cdk8s.plus17.SecretProps ; SecretProps . builder () // .metadata(ApiObjectMetadata) // .stringData(java.util.Map<java.lang.String, java.lang.String>) // .type(java.lang.String) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. stringData Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getStringData (); Type: java.util.Map java.lang.String > stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 public java . lang . String getType (); Type: java.lang.String Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. SecretValue \u00b6 Represents a specific value in JSON secret. Initializer \u00b6 import org.cdk8s.plus17.SecretValue ; SecretValue . builder () . key ( java . lang . String ) . secret ( ISecret ) . build (); key Required \u00b6 public java . lang . String getKey (); Type: java.lang.String The JSON key. secret Required \u00b6 public ISecret getSecret (); Type: org.cdk8s.plus17.ISecret The secret. ServiceAccountProps \u00b6 Properties for initialization of ServiceAccount . Properties for initialization of ServiceAccount . Initializer \u00b6 import org.cdk8s.plus17.ServiceAccountProps ; ServiceAccountProps . builder () // .metadata(ApiObjectMetadata) // .secrets(java.util.List<ISecret>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. secrets Optional \u00b6 public java . util . List < ISecret > getSecrets (); Type: java.util.List< org.cdk8s.plus17.ISecret > List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret ServiceIngressV1BetaBackendOptions \u00b6 Options for setting up backends for ingress rules. Initializer \u00b6 import org.cdk8s.plus17.ServiceIngressV1BetaBackendOptions ; ServiceIngressV1BetaBackendOptions . builder () // .port(java.lang.Number) . build (); port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. - If the service exposes multiple ports, this option must be specified. - If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. ServicePort \u00b6 Definition of a service port. Initializer \u00b6 import org.cdk8s.plus17.ServicePort ; ServicePort . builder () // .name(java.lang.String) // .nodePort(java.lang.Number) // .protocol(Protocol) // .targetPort(java.lang.Number) . port ( java . lang . Number ) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public java . lang . Number getNodePort (); Type: java.lang.Number Default: to auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus17.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The value of port will be used. The port number the service will redirect to. port Required \u00b6 public java . lang . Number getPort (); Type: java.lang.Number The port number the service will bind to. ServicePortOptions \u00b6 Initializer \u00b6 import org.cdk8s.plus17.ServicePortOptions ; ServicePortOptions . builder () // .name(java.lang.String) // .nodePort(java.lang.Number) // .protocol(Protocol) // .targetPort(java.lang.Number) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public java . lang . Number getNodePort (); Type: java.lang.Number Default: to auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus17.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The value of port will be used. The port number the service will redirect to. ServiceProps \u00b6 Properties for initialization of Service . Initializer \u00b6 import org.cdk8s.plus17.ServiceProps ; ServiceProps . builder () // .metadata(ApiObjectMetadata) // .clusterIP(java.lang.String) // .externalIPs(java.util.List<java.lang.String>) // .externalName(java.lang.String) // .loadBalancerSourceRanges(java.util.List<java.lang.String>) // .ports(java.util.List<ServicePort>) // .type(ServiceType) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. clusterIP Optional \u00b6 public java . lang . String getClusterIP (); Type: java.lang.String Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies externalIPs Optional \u00b6 public java . util . List < java . lang . String > getExternalIPs (); Type: java.util.List< java.lang.String > Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. externalName Optional \u00b6 public java . lang . String getExternalName (); Type: java.lang.String Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. loadBalancerSourceRanges Optional \u00b6 public java . util . List < java . lang . String > getLoadBalancerSourceRanges (); Type: java.util.List< java.lang.String > A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 public java . util . List < ServicePort > getPorts (); Type: java.util.List< org.cdk8s.plus17.ServicePort > The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 public ServiceType getType (); Type: org.cdk8s.plus17.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types StatefulSetProps \u00b6 Properties for initialization of StatefulSet . Initializer \u00b6 import org.cdk8s.plus17.StatefulSetProps ; StatefulSetProps . builder () // .metadata(ApiObjectMetadata) // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) . service ( Service ) // .defaultSelector(java.lang.Boolean) // .podManagementPolicy(PodManagementPolicy) // .replicas(java.lang.Number) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus17.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus17.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata. service Required \u00b6 public Service getService (); Type: org.cdk8s.plus17.Service Service to associate with the statefulset. defaultSelector Optional \u00b6 public java . lang . Boolean getDefaultSelector (); Type: java.lang.Boolean Default: true Automatically allocates a pod selector for this statefulset. If this is set to false you must define your selector through statefulset.podMetadata.addLabel() and statefulset.selectByLabel() . podManagementPolicy Optional \u00b6 public PodManagementPolicy getPodManagementPolicy (); Type: org.cdk8s.plus17.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Default: 1 Number of desired pods. VolumeMount \u00b6 Mount a volume from the pod to the container. Initializer \u00b6 import org.cdk8s.plus17.VolumeMount ; VolumeMount . builder () // .propagation(MountPropagation) // .readOnly(java.lang.Boolean) // .subPath(java.lang.String) // .subPathExpr(java.lang.String) . path ( java . lang . String ) . volume ( Volume ) . build (); propagation Optional \u00b6 public MountPropagation getPropagation (); Type: org.cdk8s.plus17.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. This field is beta in 1.10. readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public java . lang . String getSubPath (); Type: java.lang.String Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public java . lang . String getSubPathExpr (); Type: java.lang.String Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). SubPathExpr and SubPath are mutually exclusive. This field is beta in 1.15. subPathExpr and subPath are mutually exclusive. This field is beta in 1.15. path Required \u00b6 public java . lang . String getPath (); Type: java.lang.String Path within the container at which the volume should be mounted. Must not contain \u2018:\u2019. volume Required \u00b6 public Volume getVolume (); Type: org.cdk8s.plus17.Volume The volume to mount. Classes \u00b6 Container \u00b6 A single application container that you want to run within a pod. Initializers \u00b6 import org.cdk8s.plus17.Container ; Container . Builder . create () . image ( java . lang . String ) // .args(java.util.List<java.lang.String>) // .command(java.util.List<java.lang.String>) // .env(java.util.Map<java.lang.String, EnvValue>) // .imagePullPolicy(ImagePullPolicy) // .liveness(Probe) // .name(java.lang.String) // .port(java.lang.Number) // .readiness(Probe) // .startup(Probe) // .volumeMounts(java.util.List<VolumeMount>) // .workingDir(java.lang.String) . build (); image Required \u00b6 Type: java.lang.String Docker image name. args Optional \u00b6 Type: java.util.List< java.lang.String > Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: java.util.List< java.lang.String > Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: java.util.Map \u0002klzzwxh:2775\u0003 > Default: No environment variables. List of environment variables to set in the container. Cannot be updated. imagePullPolicy Optional \u00b6 Type: org.cdk8s.plus17.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: org.cdk8s.plus17.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: java.lang.String Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: java.lang.Number Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: org.cdk8s.plus17.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: org.cdk8s.plus17.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volumeMounts Optional \u00b6 Type: java.util.List< org.cdk8s.plus17.VolumeMount > Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. workingDir Optional \u00b6 Type: java.lang.String Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. Methods \u00b6 addEnv \u00b6 public addEnv ( java . lang . String name , EnvValue value ) name Required \u00b6 Type: java.lang.String The variable name. value Required \u00b6 Type: org.cdk8s.plus17.EnvValue The variable value. mount \u00b6 public mount ( java . lang . String path , Volume volume ) public mount ( java . lang . String path , Volume volume , MountOptions options ) path Required \u00b6 Type: java.lang.String The desired path in the container. volume Required \u00b6 Type: org.cdk8s.plus17.Volume The volume to mount. options Optional \u00b6 Type: org.cdk8s.plus17.MountOptions Properties \u00b6 env Required \u00b6 public java . util . Map < java . lang . String , EnvValue > getEnv (); Type: java.util.Map \u0002klzzwxh:2730\u0003 > The environment variables for this container. Returns a copy. To add environment variables use addEnv() . image Required \u00b6 public java . lang . String getImage (); Type: java.lang.String The container image. imagePullPolicy Required \u00b6 public ImagePullPolicy getImagePullPolicy (); Type: org.cdk8s.plus17.ImagePullPolicy Image pull policy for this container. mounts Required \u00b6 public java . util . List < VolumeMount > getMounts (); Type: java.util.List< org.cdk8s.plus17.VolumeMount > Volume mounts configured for this container. name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The name of the container. args Optional \u00b6 public java . util . List < java . lang . String > getArgs (); Type: java.util.List< java.lang.String > Arguments to the entrypoint. command Optional \u00b6 public java . util . List < java . lang . String > getCommand (); Type: java.util.List< java.lang.String > Entrypoint array (the command to execute when the container starts). port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number The port this container exposes. workingDir Optional \u00b6 public java . lang . String getWorkingDir (); Type: java.lang.String The working directory inside the container. EnvValue \u00b6 Utility class for creating reading env values from various sources. Static Functions \u00b6 fromConfigMap \u00b6 import org.cdk8s.plus17.EnvValue ; EnvValue . fromConfigMap ( IConfigMap configMap , java . lang . String key ) EnvValue . fromConfigMap ( IConfigMap configMap , java . lang . String key , EnvValueFromConfigMapOptions options ) configMap Required \u00b6 Type: org.cdk8s.plus17.IConfigMap The config map. key Required \u00b6 Type: java.lang.String The key to extract the value from. options Optional \u00b6 Type: org.cdk8s.plus17.EnvValueFromConfigMapOptions Additional options. fromProcess \u00b6 import org.cdk8s.plus17.EnvValue ; EnvValue . fromProcess ( java . lang . String key ) EnvValue . fromProcess ( java . lang . String key , EnvValueFromProcessOptions options ) key Required \u00b6 Type: java.lang.String The key to read. options Optional \u00b6 Type: org.cdk8s.plus17.EnvValueFromProcessOptions Additional options. fromSecretValue \u00b6 import org.cdk8s.plus17.EnvValue ; EnvValue . fromSecretValue ( SecretValue secretValue ) EnvValue . fromSecretValue ( SecretValue secretValue , EnvValueFromSecretOptions options ) secretValue Required \u00b6 Type: org.cdk8s.plus17.SecretValue The secret value (secrent + key). options Optional \u00b6 Type: org.cdk8s.plus17.EnvValueFromSecretOptions Additional options. fromValue \u00b6 import org.cdk8s.plus17.EnvValue ; EnvValue . fromValue ( java . lang . String value ) value Required \u00b6 Type: java.lang.String The value. Properties \u00b6 value Optional \u00b6 public java . lang . Object getValue (); Type: java.lang.Object valueFrom Optional \u00b6 public java . lang . Object getValueFrom (); Type: java.lang.Object IngressV1Beta1Backend \u00b6 The backend for an ingress path. Static Functions \u00b6 fromService \u00b6 import org.cdk8s.plus17.IngressV1Beta1Backend ; IngressV1Beta1Backend . fromService ( Service service ) IngressV1Beta1Backend . fromService ( Service service , ServiceIngressV1BetaBackendOptions options ) service Required \u00b6 Type: org.cdk8s.plus17.Service The service object. options Optional \u00b6 Type: org.cdk8s.plus17.ServiceIngressV1BetaBackendOptions PodSpec \u00b6 Implements: org.cdk8s.plus17.IPodSpec Provides read/write capabilities ontop of a PodSpecProps . Initializers \u00b6 import org.cdk8s.plus17.PodSpec ; PodSpec . Builder . create () // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus17.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 Type: org.cdk8s.plus17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 Type: org.cdk8s.plus17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus17.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Methods \u00b6 addContainer \u00b6 public addContainer ( ContainerProps container ) container Required \u00b6 Type: org.cdk8s.plus17.ContainerProps addVolume \u00b6 public addVolume ( Volume volume ) volume Required \u00b6 Type: org.cdk8s.plus17.Volume Properties \u00b6 containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus17.Container > The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus17.Volume > The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus17.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus17.IServiceAccount The service account used to run this pod. PodTemplate \u00b6 Implements: org.cdk8s.plus17.IPodTemplate Provides read/write capabilities ontop of a PodTemplateProps . Initializers \u00b6 import org.cdk8s.plus17.PodTemplate ; PodTemplate . Builder . create () // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) . build (); containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus17.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 Type: org.cdk8s.plus17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 Type: org.cdk8s.plus17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus17.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata. Properties \u00b6 podMetadata Required \u00b6 public ApiObjectMetadataDefinition getPodMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. Probe \u00b6 Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic. Initializers \u00b6 import org.cdk8s.plus17.Probe ; new Probe (); Static Functions \u00b6 fromCommand \u00b6 import org.cdk8s.plus17.Probe ; Probe . fromCommand ( java . util . List < java . lang . String > command ) Probe . fromCommand ( java . util . List < java . lang . String > command , CommandProbeOptions options ) command Required \u00b6 Type: java.util.List< java.lang.String > The command to execute. options Optional \u00b6 Type: org.cdk8s.plus17.CommandProbeOptions Options. fromHttpGet \u00b6 import org.cdk8s.plus17.Probe ; Probe . fromHttpGet ( java . lang . String path ) Probe . fromHttpGet ( java . lang . String path , HttpGetProbeOptions options ) path Required \u00b6 Type: java.lang.String The URL path to hit. options Optional \u00b6 Type: org.cdk8s.plus17.HttpGetProbeOptions Options. Volume \u00b6 Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes Initializers \u00b6 import org.cdk8s.plus17.Volume ; new Volume ( java . lang . String name , java . lang . Object config ); name Required \u00b6 Type: java.lang.String config Required \u00b6 Type: java.lang.Object Static Functions \u00b6 fromConfigMap \u00b6 import org.cdk8s.plus17.Volume ; Volume . fromConfigMap ( IConfigMap configMap ) Volume . fromConfigMap ( IConfigMap configMap , ConfigMapVolumeOptions options ) configMap Required \u00b6 Type: org.cdk8s.plus17.IConfigMap The config map to use to populate the volume. options Optional \u00b6 Type: org.cdk8s.plus17.ConfigMapVolumeOptions Options. fromEmptyDir \u00b6 import org.cdk8s.plus17.Volume ; Volume . fromEmptyDir ( java . lang . String name ) Volume . fromEmptyDir ( java . lang . String name , EmptyDirVolumeOptions options ) name Required \u00b6 Type: java.lang.String options Optional \u00b6 Type: org.cdk8s.plus17.EmptyDirVolumeOptions Additional options. Properties \u00b6 name Required \u00b6 public java . lang . String getName (); Type: java.lang.String Protocols \u00b6 IConfigMap \u00b6 Extends: org.cdk8s.plus17.IResource Implemented By: org.cdk8s.plus17.ConfigMap , org.cdk8s.plus17.IConfigMap Represents a config map. Properties \u00b6 name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IPodSpec \u00b6 Implemented By: org.cdk8s.plus17.Deployment , org.cdk8s.plus17.Job , org.cdk8s.plus17.Pod , org.cdk8s.plus17.PodSpec , org.cdk8s.plus17.PodTemplate , org.cdk8s.plus17.StatefulSet , org.cdk8s.plus17.IPodSpec , org.cdk8s.plus17.IPodTemplate Represents a resource that can be configured with a kuberenets pod spec. (e.g Deployment , Job , Pod , \u2026). Use the PodSpec class as an implementation helper. Methods \u00b6 addContainer \u00b6 public addContainer ( ContainerProps container ) container Required \u00b6 Type: org.cdk8s.plus17.ContainerProps The container. addVolume \u00b6 public addVolume ( Volume volume ) volume Required \u00b6 Type: org.cdk8s.plus17.Volume The volume. Properties \u00b6 containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus17.Container > The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus17.Volume > The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus17.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus17.IServiceAccount The service account used to run this pod. IPodTemplate \u00b6 Extends: org.cdk8s.plus17.IPodSpec Implemented By: org.cdk8s.plus17.Deployment , org.cdk8s.plus17.Job , org.cdk8s.plus17.PodTemplate , org.cdk8s.plus17.StatefulSet , org.cdk8s.plus17.IPodTemplate Represents a resource that can be configured with a kuberenets pod template. (e.g Deployment , Job , \u2026). Use the PodTemplate class as an implementation helper. Properties \u00b6 containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus17.Container > The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus17.Volume > The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus17.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus17.IServiceAccount The service account used to run this pod. podMetadata Required \u00b6 public ApiObjectMetadataDefinition getPodMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. IResource \u00b6 Implemented By: org.cdk8s.plus17.ConfigMap , org.cdk8s.plus17.Deployment , org.cdk8s.plus17.IngressV1Beta1 , org.cdk8s.plus17.Job , org.cdk8s.plus17.Pod , org.cdk8s.plus17.Resource , org.cdk8s.plus17.Secret , org.cdk8s.plus17.Service , org.cdk8s.plus17.ServiceAccount , org.cdk8s.plus17.StatefulSet , org.cdk8s.plus17.IConfigMap , org.cdk8s.plus17.IResource , org.cdk8s.plus17.ISecret , org.cdk8s.plus17.IServiceAccount Represents a resource. Properties \u00b6 name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. ISecret \u00b6 Extends: org.cdk8s.plus17.IResource Implemented By: org.cdk8s.plus17.Secret , org.cdk8s.plus17.ISecret Properties \u00b6 name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IServiceAccount \u00b6 Extends: org.cdk8s.plus17.IResource Implemented By: org.cdk8s.plus17.ServiceAccount , org.cdk8s.plus17.IServiceAccount Properties \u00b6 name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. Enums \u00b6 EmptyDirMedium \u00b6 The medium on which to store the volume. DEFAULT \u00b6 The default volume of the backing node. MEMORY \u00b6 Mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. ImagePullPolicy \u00b6 ALWAYS \u00b6 Every time the kubelet launches a container, the kubelet queries the container image registry to resolve the name to an image digest. If the kubelet has a container image with that exact digest cached locally, the kubelet uses its cached image; otherwise, the kubelet downloads (pulls) the image with the resolved digest, and uses that image to launch the container. Default is Always if ImagePullPolicy is omitted and either the image tag is :latest or the image tag is omitted. IF_NOT_PRESENT \u00b6 The image is pulled only if it is not already present locally. Default is IfNotPresent if ImagePullPolicy is omitted and the image tag is present but not :latest NEVER \u00b6 The image is assumed to exist locally. No attempt is made to pull the image. MountPropagation \u00b6 NONE \u00b6 This volume mount will not receive any subsequent mounts that are mounted to this volume or any of its subdirectories by the host. In similar fashion, no mounts created by the Container will be visible on the host. This is the default mode. This mode is equal to private mount propagation as described in the Linux kernel documentation HOST_TO_CONTAINER \u00b6 This volume mount will receive all subsequent mounts that are mounted to this volume or any of its subdirectories. In other words, if the host mounts anything inside the volume mount, the Container will see it mounted there. Similarly, if any Pod with Bidirectional mount propagation to the same volume mounts anything there, the Container with HostToContainer mount propagation will see it. This mode is equal to rslave mount propagation as described in the Linux kernel documentation BIDIRECTIONAL \u00b6 This volume mount behaves the same the HostToContainer mount. In addition, all volume mounts created by the Container will be propagated back to the host and to all Containers of all Pods that use the same volume A typical use case for this mode is a Pod with a FlexVolume or CSI driver or a Pod that needs to mount something on the host using a hostPath volume. This mode is equal to rshared mount propagation as described in the Linux kernel documentation Caution: Bidirectional mount propagation can be dangerous. It can damage the host operating system and therefore it is allowed only in privileged Containers. Familiarity with Linux kernel behavior is strongly recommended. In addition, any volume mounts created by Containers in Pods must be destroyed (unmounted) by the Containers on termination. PodManagementPolicy \u00b6 Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once. ORDERED_READY \u00b6 PARALLEL \u00b6 Protocol \u00b6 TCP \u00b6 UDP \u00b6 SCTP \u00b6 RestartPolicy \u00b6 Restart policy for all containers within the pod. ALWAYS \u00b6 Always restart the pod after it exits. ON_FAILURE \u00b6 Only restart if the pod exits with a non-zero exit code. NEVER \u00b6 Never restart the pod. ServiceType \u00b6 For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP. CLUSTER_IP \u00b6 Exposes the Service on a cluster-internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default ServiceType NODE_PORT \u00b6 Exposes the Service on each Node\u2019s IP at a static port (the NodePort). A ClusterIP Service, to which the NodePort Service routes, is automatically created. You\u2019ll be able to contact the NodePort Service, from outside the cluster, by requesting : . LOAD_BALANCER \u00b6 Exposes the Service externally using a cloud provider\u2019s load balancer. NodePort and ClusterIP Services, to which the external load balancer routes, are automatically created. EXTERNAL_NAME \u00b6 Maps the Service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value. No proxying of any kind is set up. Note: You need either kube-dns version 1.7 or CoreDNS version 0.0.8 or higher to use the ExternalName type.","title":"Java"},{"location":"reference/cdk8s-plus-17/java/#cdk8s-plus-17-java","text":"","title":"cdk8s-plus-17 (Java) "},{"location":"reference/cdk8s-plus-17/java/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s-plus-17/java/#configmap","text":"Implements: org.cdk8s.plus17.IConfigMap ConfigMap holds configuration data for pods to consume.","title":"ConfigMap "},{"location":"reference/cdk8s-plus-17/java/#deployment","text":"Implements: org.cdk8s.plus17.IPodTemplate A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below.","title":"Deployment "},{"location":"reference/cdk8s-plus-17/java/#use-case","text":"The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore.","title":"Use Case"},{"location":"reference/cdk8s-plus-17/java/#ingressv1beta1","text":"Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.","title":"IngressV1Beta1 "},{"location":"reference/cdk8s-plus-17/java/#job","text":"Implements: org.cdk8s.plus17.IPodTemplate A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel.","title":"Job "},{"location":"reference/cdk8s-plus-17/java/#pod","text":"Implements: org.cdk8s.plus17.IPodSpec Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.","title":"Pod "},{"location":"reference/cdk8s-plus-17/java/#resource","text":"Implements: org.cdk8s.plus17.IResource Base class for all Kubernetes objects in stdk8s. Represents a single resource.","title":"Resource "},{"location":"reference/cdk8s-plus-17/java/#secret","text":"Implements: org.cdk8s.plus17.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret","title":"Secret "},{"location":"reference/cdk8s-plus-17/java/#service","text":"An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods.","title":"Service "},{"location":"reference/cdk8s-plus-17/java/#serviceaccount","text":"Implements: org.cdk8s.plus17.IServiceAccount A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account","title":"ServiceAccount "},{"location":"reference/cdk8s-plus-17/java/#statefulset","text":"Implements: org.cdk8s.plus17.IPodTemplate StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed.","title":"StatefulSet "},{"location":"reference/cdk8s-plus-17/java/#using-statefulsets","text":"StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates.","title":"Using StatefulSets"},{"location":"reference/cdk8s-plus-17/java/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s-plus-17/java/#adddirectoryoptions","text":"Options for configmap.addDirectory() .","title":"AddDirectoryOptions "},{"location":"reference/cdk8s-plus-17/java/#commandprobeoptions","text":"Options for Probe.fromCommand() .","title":"CommandProbeOptions "},{"location":"reference/cdk8s-plus-17/java/#configmapprops","text":"Properties for initialization of ConfigMap .","title":"ConfigMapProps "},{"location":"reference/cdk8s-plus-17/java/#configmapvolumeoptions","text":"Options for the ConfigMap-based volume.","title":"ConfigMapVolumeOptions "},{"location":"reference/cdk8s-plus-17/java/#containerprops","text":"Properties for creating a container.","title":"ContainerProps "},{"location":"reference/cdk8s-plus-17/java/#deploymentprops","text":"Properties for initialization of Deployment .","title":"DeploymentProps "},{"location":"reference/cdk8s-plus-17/java/#emptydirvolumeoptions","text":"Options for volumes populated with an empty directory.","title":"EmptyDirVolumeOptions "},{"location":"reference/cdk8s-plus-17/java/#envvaluefromconfigmapoptions","text":"Options to specify an envionment variable value from a ConfigMap key.","title":"EnvValueFromConfigMapOptions "},{"location":"reference/cdk8s-plus-17/java/#envvaluefromprocessoptions","text":"Options to specify an environment variable value from the process environment.","title":"EnvValueFromProcessOptions "},{"location":"reference/cdk8s-plus-17/java/#envvaluefromsecretoptions","text":"Options to specify an environment variable value from a Secret.","title":"EnvValueFromSecretOptions "},{"location":"reference/cdk8s-plus-17/java/#exposeoptions","text":"Options for exposing a deployment via a service.","title":"ExposeOptions "},{"location":"reference/cdk8s-plus-17/java/#httpgetprobeoptions","text":"Options for Probe.fromHttpGet() .","title":"HttpGetProbeOptions "},{"location":"reference/cdk8s-plus-17/java/#ingressv1beta1props","text":"Properties for Ingress .","title":"IngressV1Beta1Props "},{"location":"reference/cdk8s-plus-17/java/#ingressv1beta1rule","text":"Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path.","title":"IngressV1Beta1Rule "},{"location":"reference/cdk8s-plus-17/java/#ingressv1beta1tls","text":"Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination.","title":"IngressV1Beta1Tls "},{"location":"reference/cdk8s-plus-17/java/#jobprops","text":"Properties for initialization of Job .","title":"JobProps "},{"location":"reference/cdk8s-plus-17/java/#mountoptions","text":"Options for mounts.","title":"MountOptions "},{"location":"reference/cdk8s-plus-17/java/#pathmapping","text":"Maps a string key to a path within a volume.","title":"PathMapping "},{"location":"reference/cdk8s-plus-17/java/#podprops","text":"Properties for initialization of Pod .","title":"PodProps "},{"location":"reference/cdk8s-plus-17/java/#podspecprops","text":"Properties of a PodSpec .","title":"PodSpecProps "},{"location":"reference/cdk8s-plus-17/java/#podtemplateprops","text":"Properties of a PodTemplate . Adds metadata information on top of the spec.","title":"PodTemplateProps "},{"location":"reference/cdk8s-plus-17/java/#probeoptions","text":"Probe options.","title":"ProbeOptions "},{"location":"reference/cdk8s-plus-17/java/#resourceprops","text":"Initialization properties for resources.","title":"ResourceProps "},{"location":"reference/cdk8s-plus-17/java/#secretprops","text":"","title":"SecretProps "},{"location":"reference/cdk8s-plus-17/java/#secretvalue","text":"Represents a specific value in JSON secret.","title":"SecretValue "},{"location":"reference/cdk8s-plus-17/java/#serviceaccountprops","text":"Properties for initialization of ServiceAccount . Properties for initialization of ServiceAccount .","title":"ServiceAccountProps "},{"location":"reference/cdk8s-plus-17/java/#serviceingressv1betabackendoptions","text":"Options for setting up backends for ingress rules.","title":"ServiceIngressV1BetaBackendOptions "},{"location":"reference/cdk8s-plus-17/java/#serviceport","text":"Definition of a service port.","title":"ServicePort "},{"location":"reference/cdk8s-plus-17/java/#serviceportoptions","text":"","title":"ServicePortOptions "},{"location":"reference/cdk8s-plus-17/java/#serviceprops","text":"Properties for initialization of Service .","title":"ServiceProps "},{"location":"reference/cdk8s-plus-17/java/#statefulsetprops","text":"Properties for initialization of StatefulSet .","title":"StatefulSetProps "},{"location":"reference/cdk8s-plus-17/java/#volumemount","text":"Mount a volume from the pod to the container.","title":"VolumeMount "},{"location":"reference/cdk8s-plus-17/java/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s-plus-17/java/#container","text":"A single application container that you want to run within a pod.","title":"Container "},{"location":"reference/cdk8s-plus-17/java/#envvalue","text":"Utility class for creating reading env values from various sources.","title":"EnvValue "},{"location":"reference/cdk8s-plus-17/java/#ingressv1beta1backend","text":"The backend for an ingress path.","title":"IngressV1Beta1Backend "},{"location":"reference/cdk8s-plus-17/java/#podspec","text":"Implements: org.cdk8s.plus17.IPodSpec Provides read/write capabilities ontop of a PodSpecProps .","title":"PodSpec "},{"location":"reference/cdk8s-plus-17/java/#podtemplate","text":"Implements: org.cdk8s.plus17.IPodTemplate Provides read/write capabilities ontop of a PodTemplateProps .","title":"PodTemplate "},{"location":"reference/cdk8s-plus-17/java/#probe","text":"Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.","title":"Probe "},{"location":"reference/cdk8s-plus-17/java/#volume","text":"Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes","title":"Volume "},{"location":"reference/cdk8s-plus-17/java/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s-plus-17/java/#iconfigmap","text":"Extends: org.cdk8s.plus17.IResource Implemented By: org.cdk8s.plus17.ConfigMap , org.cdk8s.plus17.IConfigMap Represents a config map.","title":"IConfigMap "},{"location":"reference/cdk8s-plus-17/java/#ipodspec","text":"Implemented By: org.cdk8s.plus17.Deployment , org.cdk8s.plus17.Job , org.cdk8s.plus17.Pod , org.cdk8s.plus17.PodSpec , org.cdk8s.plus17.PodTemplate , org.cdk8s.plus17.StatefulSet , org.cdk8s.plus17.IPodSpec , org.cdk8s.plus17.IPodTemplate Represents a resource that can be configured with a kuberenets pod spec. (e.g Deployment , Job , Pod , \u2026). Use the PodSpec class as an implementation helper.","title":"IPodSpec "},{"location":"reference/cdk8s-plus-17/java/#ipodtemplate","text":"Extends: org.cdk8s.plus17.IPodSpec Implemented By: org.cdk8s.plus17.Deployment , org.cdk8s.plus17.Job , org.cdk8s.plus17.PodTemplate , org.cdk8s.plus17.StatefulSet , org.cdk8s.plus17.IPodTemplate Represents a resource that can be configured with a kuberenets pod template. (e.g Deployment , Job , \u2026). Use the PodTemplate class as an implementation helper.","title":"IPodTemplate "},{"location":"reference/cdk8s-plus-17/java/#iresource","text":"Implemented By: org.cdk8s.plus17.ConfigMap , org.cdk8s.plus17.Deployment , org.cdk8s.plus17.IngressV1Beta1 , org.cdk8s.plus17.Job , org.cdk8s.plus17.Pod , org.cdk8s.plus17.Resource , org.cdk8s.plus17.Secret , org.cdk8s.plus17.Service , org.cdk8s.plus17.ServiceAccount , org.cdk8s.plus17.StatefulSet , org.cdk8s.plus17.IConfigMap , org.cdk8s.plus17.IResource , org.cdk8s.plus17.ISecret , org.cdk8s.plus17.IServiceAccount Represents a resource.","title":"IResource "},{"location":"reference/cdk8s-plus-17/java/#isecret","text":"Extends: org.cdk8s.plus17.IResource Implemented By: org.cdk8s.plus17.Secret , org.cdk8s.plus17.ISecret","title":"ISecret "},{"location":"reference/cdk8s-plus-17/java/#iserviceaccount","text":"Extends: org.cdk8s.plus17.IResource Implemented By: org.cdk8s.plus17.ServiceAccount , org.cdk8s.plus17.IServiceAccount","title":"IServiceAccount "},{"location":"reference/cdk8s-plus-17/java/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s-plus-17/java/#emptydirmedium","text":"The medium on which to store the volume.","title":"EmptyDirMedium "},{"location":"reference/cdk8s-plus-17/java/#imagepullpolicy","text":"","title":"ImagePullPolicy "},{"location":"reference/cdk8s-plus-17/java/#mountpropagation","text":"","title":"MountPropagation "},{"location":"reference/cdk8s-plus-17/java/#podmanagementpolicy","text":"Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.","title":"PodManagementPolicy "},{"location":"reference/cdk8s-plus-17/java/#protocol","text":"","title":"Protocol "},{"location":"reference/cdk8s-plus-17/java/#restartpolicy","text":"Restart policy for all containers within the pod.","title":"RestartPolicy "},{"location":"reference/cdk8s-plus-17/java/#servicetype","text":"For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP.","title":"ServiceType "},{"location":"reference/cdk8s-plus-17/python/","text":"cdk8s-plus-17 (Python) \u00b6 Constructs \u00b6 ConfigMap \u00b6 Implements: cdk8s_plus_17.IConfigMap ConfigMap holds configuration data for pods to consume. Initializers \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ConfigMap ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , binary_data : typing . Mapping [ str ] = None , data : typing . Mapping [ str ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binary_data Optional \u00b6 Type: typing.Mapping[ str ] BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. Using this field will require 1.10+ apiserver and kubelet. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 Type: typing.Mapping[ str ] Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . Methods \u00b6 add_binary_data \u00b6 def add_binary_data ( key : str , value : str ) key Required \u00b6 Type: str The key. value Required \u00b6 Type: str The value. add_data \u00b6 def add_data ( key : str , value : str ) key Required \u00b6 Type: str The key. value Required \u00b6 Type: str The value. add_directory \u00b6 def add_directory ( local_dir : str , exclude : typing . List [ str ] = None , key_prefix : str = None ) local_dir Required \u00b6 Type: str A path to a local directory. exclude Optional \u00b6 Type: typing.List[ str ] Default: include all files Glob patterns to exclude when adding files. key_prefix Optional \u00b6 Type: str Default: \u201c\u201d A prefix to add to all keys in the config map. add_file \u00b6 def add_file ( local_file : str , key : str = None ) local_file Required \u00b6 Type: str The path to the local file. key Optional \u00b6 Type: str The ConfigMap key (default to the file name). Static Functions \u00b6 from_config_map_name \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ConfigMap . from_config_map_name ( name : str ) name Required \u00b6 Type: str The name of the config map to import. Properties \u00b6 binary_data Required \u00b6 binary_data : typing . Mapping [ str ] Type: typing.Mapping[ str ] The binary data associated with this config map. Returns a copy. To add data records, use addBinaryData() or addData() . data Required \u00b6 data : typing . Mapping [ str ] Type: typing.Mapping[ str ] The data associated with this config map. Returns an copy. To add data records, use addData() or addBinaryData() . Deployment \u00b6 Implements: cdk8s_plus_17.IPodTemplate A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case \u00b6 The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore. Initializers \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Deployment ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , default_selector : bool = None , replicas : typing . Union [ int , float ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: typing.List[ cdk8s_plus_17.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_17.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata. default_selector Optional \u00b6 Type: bool Default: true Automatically allocates a pod selector for this deployment. If this is set to false you must define your selector through deployment.podMetadata.addLabel() and deployment.selectByLabel() . replicas Optional \u00b6 Type: typing.Union[int, float] Default: 1 Number of desired pods. Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_17.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_17.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_17.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( volume : Volume ) volume Required \u00b6 Type: cdk8s_plus_17.Volume expose \u00b6 def expose ( port : typing . Union [ int , float ], name : str = None , protocol : Protocol = None , service_type : ServiceType = None , target_port : typing . Union [ int , float ] = None ) port Required \u00b6 Type: typing.Union[int, float] The port number the service will bind to. name Optional \u00b6 Type: str Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL protocol Optional \u00b6 Type: cdk8s_plus_17.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. service_type Optional \u00b6 Type: cdk8s_plus_17.ServiceType Default: ClusterIP. The type of the exposed service. target_port Optional \u00b6 Type: typing.Union[int, float] Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. select_by_label \u00b6 def select_by_label ( key : str , value : str ) key Required \u00b6 Type: str The label key. value Required \u00b6 Type: str The label value. Properties \u00b6 containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_17.Container ] The containers belonging to the pod. Use addContainer to add containers. label_selector Required \u00b6 label_selector : typing . Mapping [ str ] Type: typing.Mapping[ str ] The labels this deployment will match against in order to select pods. Returns a a copy. Use selectByLabel() to add labels. pod_metadata Required \u00b6 pod_metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. replicas Required \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Number of desired pods. volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_17.Volume ] The volumes associated with this pod. Use addVolume to add volumes. restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_17.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_17.IServiceAccount The service account used to run this pod. IngressV1Beta1 \u00b6 Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. Initializers \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . IngressV1Beta1 ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , default_backend : IngressV1Beta1Backend = None , rules : typing . List [ IngressV1Beta1Rule ] = None , tls : typing . List [ IngressV1Beta1Tls ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. default_backend Optional \u00b6 Type: cdk8s_plus_17.IngressV1Beta1Backend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 Type: typing.List[ cdk8s_plus_17.IngressV1Beta1Rule ] Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 Type: typing.List[ cdk8s_plus_17.IngressV1Beta1Tls ] TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. Methods \u00b6 add_default_backend \u00b6 def add_default_backend ( backend : IngressV1Beta1Backend ) backend Required \u00b6 Type: cdk8s_plus_17.IngressV1Beta1Backend The backend to use for requests that do not match any rule. add_host_default_backend \u00b6 def add_host_default_backend ( host : str , backend : IngressV1Beta1Backend ) host Required \u00b6 Type: str The host name to match. backend Required \u00b6 Type: cdk8s_plus_17.IngressV1Beta1Backend The backend to route to. add_host_rule \u00b6 def add_host_rule ( host : str , path : str , backend : IngressV1Beta1Backend ) host Required \u00b6 Type: str The host name. path Required \u00b6 Type: str The HTTP path. backend Required \u00b6 Type: cdk8s_plus_17.IngressV1Beta1Backend The backend to route requests to. add_rule \u00b6 def add_rule ( path : str , backend : IngressV1Beta1Backend ) path Required \u00b6 Type: str The HTTP path. backend Required \u00b6 Type: cdk8s_plus_17.IngressV1Beta1Backend The backend to route requests to. add_rules \u00b6 def add_rules ( backend : IngressV1Beta1Backend , host : str = None , path : str = None ) backend Required \u00b6 Type: cdk8s_plus_17.IngressV1Beta1Backend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 Type: str Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 Type: str Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. add_tls \u00b6 def add_tls ( tls : typing . List [ IngressV1Beta1Tls ] ) tls Required \u00b6 Type: typing.List[ cdk8s_plus_17.IngressV1Beta1Tls ] Job \u00b6 Implements: cdk8s_plus_17.IPodTemplate A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel. Initializers \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Job ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , active_deadline : Duration = None , backoff_limit : typing . Union [ int , float ] = None , ttl_after_finished : Duration = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: typing.List[ cdk8s_plus_17.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_17.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata. active_deadline Optional \u00b6 Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoff_limit Optional \u00b6 Type: typing.Union[int, float] Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttl_after_finished Optional \u00b6 Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_17.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_17.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_17.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( volume : Volume ) volume Required \u00b6 Type: cdk8s_plus_17.Volume Properties \u00b6 containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_17.Container ] The containers belonging to the pod. Use addContainer to add containers. pod_metadata Required \u00b6 pod_metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_17.Volume ] The volumes associated with this pod. Use addVolume to add volumes. active_deadline Optional \u00b6 active_deadline : Duration Type: cdk8s.Duration Duration before job is terminated. If undefined, there is no deadline. backoff_limit Optional \u00b6 backoff_limit : typing . Union [ int , float ] Type: typing.Union[int, float] Number of retries before marking failed. restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_17.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_17.IServiceAccount The service account used to run this pod. ttl_after_finished Optional \u00b6 ttl_after_finished : Duration Type: cdk8s.Duration TTL before the job is deleted after it is finished. Pod \u00b6 Implements: cdk8s_plus_17.IPodSpec Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts. Initializers \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Pod ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: typing.List[ cdk8s_plus_17.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_17.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_17.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_17.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_17.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( volume : Volume ) volume Required \u00b6 Type: cdk8s_plus_17.Volume Properties \u00b6 containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_17.Container ] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_17.Volume ] The volumes associated with this pod. Use addVolume to add volumes. restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_17.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_17.IServiceAccount The service account used to run this pod. Resource \u00b6 Implements: cdk8s_plus_17.IResource Base class for all Kubernetes objects in stdk8s. Represents a single resource. Initializers \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Resource ( scope : Construct , id : str , node_factory : INodeFactory = None ) scope Required \u00b6 Type: constructs.Construct The scope in which to define this construct. id Required \u00b6 Type: str The scoped construct ID. Must be unique amongst siblings. If the ID includes a path separator ( / ), then it will be replaced by double dash -- . node_factory Optional \u00b6 Type: constructs.INodeFactory Default: the default Node is associated A factory for attaching Node s to the construct. Properties \u00b6 metadata Required \u00b6 metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition name Required \u00b6 name : str Type: str The name of this API object. Secret \u00b6 Implements: cdk8s_plus_17.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret Initializers \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Secret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , string_data : typing . Mapping [ str ] = None , type : str = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. string_data Optional \u00b6 Type: typing.Mapping[ str ] stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 Type: str Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. Methods \u00b6 add_string_data \u00b6 def add_string_data ( key : str , value : str ) key Required \u00b6 Type: str Key. value Required \u00b6 Type: str Value. get_string_data \u00b6 def get_string_data ( key : str ) key Required \u00b6 Type: str Key. Static Functions \u00b6 from_secret_name \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Secret . from_secret_name ( name : str ) name Required \u00b6 Type: str The name of the secret to reference. Service \u00b6 An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods. Initializers \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Service ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , cluster_i_p : str = None , external_i_ps : typing . List [ str ] = None , external_name : str = None , load_balancer_source_ranges : typing . List [ str ] = None , ports : typing . List [ ServicePort ] = None , type : ServiceType = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. cluster_i_p Optional \u00b6 Type: str Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies external_i_ps Optional \u00b6 Type: typing.List[ str ] Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. external_name Optional \u00b6 Type: str Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. load_balancer_source_ranges Optional \u00b6 Type: typing.List[ str ] A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 Type: typing.List[ cdk8s_plus_17.ServicePort ] The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 Type: cdk8s_plus_17.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types Methods \u00b6 add_deployment \u00b6 def add_deployment ( deployment : Deployment , port : typing . Union [ int , float ], name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None ) deployment Required \u00b6 Type: cdk8s_plus_17.Deployment The deployment to expose. port Required \u00b6 Type: typing.Union[int, float] The external port. name Optional \u00b6 Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 Type: typing.Union[int, float] Default: to auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 Type: cdk8s_plus_17.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. add_selector \u00b6 def add_selector ( label : str , value : str ) label Required \u00b6 Type: str The label key. value Required \u00b6 Type: str The label value. serve \u00b6 def serve ( port : typing . Union [ int , float ], name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None ) port Required \u00b6 Type: typing.Union[int, float] The port definition. name Optional \u00b6 Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 Type: typing.Union[int, float] Default: to auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 Type: cdk8s_plus_17.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. Properties \u00b6 ports Required \u00b6 ports : typing . List [ ServicePort ] Type: typing.List[ cdk8s_plus_17.ServicePort ] Ports for this service. Use serve() to expose additional service ports. selector Required \u00b6 selector : typing . Mapping [ str ] Type: typing.Mapping[ str ] Returns the labels which are used to select pods for this service. type Required \u00b6 type : ServiceType Type: cdk8s_plus_17.ServiceType Determines how the Service is exposed. cluster_i_p Optional \u00b6 cluster_i_p : str Type: str The IP address of the service and is usually assigned randomly by the master. external_name Optional \u00b6 external_name : str Type: str The externalName to be used for EXTERNAL_NAME types. ServiceAccount \u00b6 Implements: cdk8s_plus_17.IServiceAccount A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account Initializers \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ServiceAccount ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , secrets : typing . List [ ISecret ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. secrets Optional \u00b6 Type: typing.List[ cdk8s_plus_17.ISecret ] List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret Methods \u00b6 add_secret \u00b6 def add_secret ( secret : ISecret ) secret Required \u00b6 Type: cdk8s_plus_17.ISecret The secret. Static Functions \u00b6 from_service_account_name \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ServiceAccount . from_service_account_name ( name : str ) name Required \u00b6 Type: str The name of the service account resource. Properties \u00b6 secrets Required \u00b6 secrets : typing . List [ ISecret ] Type: typing.List[ cdk8s_plus_17.ISecret ] List of secrets allowed to be used by pods running using this service account. Returns a copy. To add a secret, use addSecret() . StatefulSet \u00b6 Implements: cdk8s_plus_17.IPodTemplate StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed. Using StatefulSets \u00b6 StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates. Initializers \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . StatefulSet ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , service : Service , default_selector : bool = None , pod_management_policy : PodManagementPolicy = None , replicas : typing . Union [ int , float ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: typing.List[ cdk8s_plus_17.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_17.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata. service Required \u00b6 Type: cdk8s_plus_17.Service Service to associate with the statefulset. default_selector Optional \u00b6 Type: bool Default: true Automatically allocates a pod selector for this statefulset. If this is set to false you must define your selector through statefulset.podMetadata.addLabel() and statefulset.selectByLabel() . pod_management_policy Optional \u00b6 Type: cdk8s_plus_17.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 Type: typing.Union[int, float] Default: 1 Number of desired pods. Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_17.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_17.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_17.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( volume : Volume ) volume Required \u00b6 Type: cdk8s_plus_17.Volume select_by_label \u00b6 def select_by_label ( key : str , value : str ) key Required \u00b6 Type: str The label key. value Required \u00b6 Type: str The label value. Properties \u00b6 containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_17.Container ] The containers belonging to the pod. Use addContainer to add containers. label_selector Required \u00b6 label_selector : typing . Mapping [ str ] Type: typing.Mapping[ str ] The labels this statefulset will match against in order to select pods. Returns a a copy. Use selectByLabel() to add labels. pod_management_policy Required \u00b6 pod_management_policy : PodManagementPolicy Type: cdk8s_plus_17.PodManagementPolicy Management policy to use for the set. pod_metadata Required \u00b6 pod_metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. replicas Required \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Number of desired pods. volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_17.Volume ] The volumes associated with this pod. Use addVolume to add volumes. restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_17.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_17.IServiceAccount The service account used to run this pod. Structs \u00b6 AddDirectoryOptions \u00b6 Options for configmap.addDirectory() . Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . AddDirectoryOptions ( exclude : typing . List [ str ] = None , key_prefix : str = None ) exclude Optional \u00b6 exclude : typing . List [ str ] Type: typing.List[ str ] Default: include all files Glob patterns to exclude when adding files. key_prefix Optional \u00b6 key_prefix : str Type: str Default: \u201c\u201d A prefix to add to all keys in the config map. CommandProbeOptions \u00b6 Options for Probe.fromCommand() . Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . CommandProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None ) failure_threshold Optional \u00b6 failure_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 initial_delay_seconds : Duration Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 period_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 success_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 timeout_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ConfigMapProps \u00b6 Properties for initialization of ConfigMap . Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ConfigMapProps ( metadata : ApiObjectMetadata = None , binary_data : typing . Mapping [ str ] = None , data : typing . Mapping [ str ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binary_data Optional \u00b6 binary_data : typing . Mapping [ str ] Type: typing.Mapping[ str ] BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. Using this field will require 1.10+ apiserver and kubelet. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 data : typing . Mapping [ str ] Type: typing.Mapping[ str ] Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . ConfigMapVolumeOptions \u00b6 Options for the ConfigMap-based volume. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ConfigMapVolumeOptions ( default_mode : typing . Union [ int , float ] = None , items : typing . Mapping [ PathMapping ] = None , name : str = None , optional : bool = None ) default_mode Optional \u00b6 default_mode : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 items : typing . Mapping [ PathMapping ] Type: typing.Mapping[ cdk8s_plus_17.PathMapping ] Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 name : str Type: str Default: auto-generated The volume name. optional Optional \u00b6 optional : bool Type: bool Default: undocumented Specify whether the ConfigMap or its keys must be defined. ContainerProps \u00b6 Properties for creating a container. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ContainerProps ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 image : str Type: str Docker image name. args Optional \u00b6 args : typing . List [ str ] Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 command : typing . List [ str ] Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 env : typing . Mapping [ EnvValue ] Type: typing.Mapping[ cdk8s_plus_17.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 image_pull_policy : ImagePullPolicy Type: cdk8s_plus_17.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 liveness : Probe Type: cdk8s_plus_17.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 name : str Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 readiness : Probe Type: cdk8s_plus_17.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 startup : Probe Type: cdk8s_plus_17.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 volume_mounts : typing . List [ VolumeMount ] Type: typing.List[ cdk8s_plus_17.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 working_dir : str Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. DeploymentProps \u00b6 Properties for initialization of Deployment . Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . DeploymentProps ( metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , default_selector : bool = None , replicas : typing . Union [ int , float ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_17.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_17.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata. default_selector Optional \u00b6 default_selector : bool Type: bool Default: true Automatically allocates a pod selector for this deployment. If this is set to false you must define your selector through deployment.podMetadata.addLabel() and deployment.selectByLabel() . replicas Optional \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Number of desired pods. EmptyDirVolumeOptions \u00b6 Options for volumes populated with an empty directory. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . EmptyDirVolumeOptions ( medium : EmptyDirMedium = None , size_limit : Size = None ) medium Optional \u00b6 medium : EmptyDirMedium Type: cdk8s_plus_17.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. size_limit Optional \u00b6 size_limit : Size Type: cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. EnvValueFromConfigMapOptions \u00b6 Options to specify an envionment variable value from a ConfigMap key. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . EnvValueFromConfigMapOptions ( optional : bool = None ) optional Optional \u00b6 optional : bool Type: bool Default: false Specify whether the ConfigMap or its key must be defined. EnvValueFromProcessOptions \u00b6 Options to specify an environment variable value from the process environment. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . EnvValueFromProcessOptions ( required : bool = None ) required Optional \u00b6 required : bool Type: bool Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. EnvValueFromSecretOptions \u00b6 Options to specify an environment variable value from a Secret. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . EnvValueFromSecretOptions ( optional : bool = None ) optional Optional \u00b6 optional : bool Type: bool Default: false Specify whether the Secret or its key must be defined. ExposeOptions \u00b6 Options for exposing a deployment via a service. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ExposeOptions ( name : str = None , protocol : Protocol = None , service_type : ServiceType = None , target_port : typing . Union [ int , float ] = None ) name Optional \u00b6 name : str Type: str Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_17.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. service_type Optional \u00b6 service_type : ServiceType Type: cdk8s_plus_17.ServiceType Default: ClusterIP. The type of the exposed service. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. HttpGetProbeOptions \u00b6 Options for Probe.fromHttpGet() . Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . HttpGetProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None , port : typing . Union [ int , float ] = None ) failure_threshold Optional \u00b6 failure_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 initial_delay_seconds : Duration Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 period_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 success_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 timeout_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to use when sending the GET request. IngressV1Beta1Props \u00b6 Properties for Ingress . Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . IngressV1Beta1Props ( metadata : ApiObjectMetadata = None , default_backend : IngressV1Beta1Backend = None , rules : typing . List [ IngressV1Beta1Rule ] = None , tls : typing . List [ IngressV1Beta1Tls ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. default_backend Optional \u00b6 default_backend : IngressV1Beta1Backend Type: cdk8s_plus_17.IngressV1Beta1Backend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 rules : typing . List [ IngressV1Beta1Rule ] Type: typing.List[ cdk8s_plus_17.IngressV1Beta1Rule ] Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 tls : typing . List [ IngressV1Beta1Tls ] Type: typing.List[ cdk8s_plus_17.IngressV1Beta1Tls ] TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. IngressV1Beta1Rule \u00b6 Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . IngressV1Beta1Rule ( backend : IngressV1Beta1Backend , host : str = None , path : str = None ) backend Required \u00b6 backend : IngressV1Beta1Backend Type: cdk8s_plus_17.IngressV1Beta1Backend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 host : str Type: str Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 path : str Type: str Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. IngressV1Beta1Tls \u00b6 Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . IngressV1Beta1Tls ( hosts : typing . List [ str ] = None , secret : ISecret = None ) hosts Optional \u00b6 hosts : typing . List [ str ] Type: typing.List[ str ] Default: If unspecified, it defaults to the wildcard host setting for the loadbalancer controller fulfilling this Ingress. Hosts are a list of hosts included in the TLS certificate. The values in this list must match the name/s used in the TLS Secret. secret Optional \u00b6 secret : ISecret Type: cdk8s_plus_17.ISecret Default: If unspecified, it allows SSL routing based on SNI hostname. Secret is the secret that contains the certificate and key used to terminate SSL traffic on 443. If the SNI host in a listener conflicts with the \u201cHost\u201d header field used by an IngressRule, the SNI host is used for termination and value of the Host header is used for routing. JobProps \u00b6 Properties for initialization of Job . Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . JobProps ( metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , active_deadline : Duration = None , backoff_limit : typing . Union [ int , float ] = None , ttl_after_finished : Duration = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_17.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_17.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata. active_deadline Optional \u00b6 active_deadline : Duration Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoff_limit Optional \u00b6 backoff_limit : typing . Union [ int , float ] Type: typing.Union[int, float] Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttl_after_finished Optional \u00b6 ttl_after_finished : Duration Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. MountOptions \u00b6 Options for mounts. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . MountOptions ( propagation : MountPropagation = None , read_only : bool = None , sub_path : str = None , sub_path_expr : str = None ) propagation Optional \u00b6 propagation : MountPropagation Type: cdk8s_plus_17.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. This field is beta in 1.10. read_only Optional \u00b6 read_only : bool Type: bool Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. sub_path Optional \u00b6 sub_path : str Type: str Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). sub_path_expr Optional \u00b6 sub_path_expr : str Type: str Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). SubPathExpr and SubPath are mutually exclusive. This field is beta in 1.15. subPathExpr and subPath are mutually exclusive. This field is beta in 1.15. PathMapping \u00b6 Maps a string key to a path within a volume. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . PathMapping ( path : str , mode : typing . Union [ int , float ] = None ) path Required \u00b6 path : str Type: str The relative path of the file to map the key to. May not be an absolute path. May not contain the path element \u2018..\u2019. May not start with the string \u2018..\u2019. mode Optional \u00b6 mode : typing . Union [ int , float ] Type: typing.Union[int, float] Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. PodProps \u00b6 Properties for initialization of Pod . Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . PodProps ( metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_17.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_17.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodSpecProps \u00b6 Properties of a PodSpec . Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . PodSpecProps ( containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_17.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_17.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodTemplateProps \u00b6 Properties of a PodTemplate . Adds metadata information on top of the spec. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . PodTemplateProps ( containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None ) containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_17.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_17.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata. ProbeOptions \u00b6 Probe options. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None ) failure_threshold Optional \u00b6 failure_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 initial_delay_seconds : Duration Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 period_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 success_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 timeout_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ResourceProps \u00b6 Initialization properties for resources. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ResourceProps ( metadata : ApiObjectMetadata = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. SecretProps \u00b6 Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . SecretProps ( metadata : ApiObjectMetadata = None , string_data : typing . Mapping [ str ] = None , type : str = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. string_data Optional \u00b6 string_data : typing . Mapping [ str ] Type: typing.Mapping[ str ] stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 type : str Type: str Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. SecretValue \u00b6 Represents a specific value in JSON secret. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . SecretValue ( key : str , secret : ISecret ) key Required \u00b6 key : str Type: str The JSON key. secret Required \u00b6 secret : ISecret Type: cdk8s_plus_17.ISecret The secret. ServiceAccountProps \u00b6 Properties for initialization of ServiceAccount . Properties for initialization of ServiceAccount . Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ServiceAccountProps ( metadata : ApiObjectMetadata = None , secrets : typing . List [ ISecret ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. secrets Optional \u00b6 secrets : typing . List [ ISecret ] Type: typing.List[ cdk8s_plus_17.ISecret ] List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret ServiceIngressV1BetaBackendOptions \u00b6 Options for setting up backends for ingress rules. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ServiceIngressV1BetaBackendOptions ( port : typing . Union [ int , float ] = None ) port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. - If the service exposes multiple ports, this option must be specified. - If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. ServicePort \u00b6 Definition of a service port. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ServicePort ( name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None , port : typing . Union [ int , float ] ) name Optional \u00b6 name : str Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 node_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: to auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_17.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. port Required \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] The port number the service will bind to. ServicePortOptions \u00b6 Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ServicePortOptions ( name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None ) name Optional \u00b6 name : str Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 node_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: to auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_17.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. ServiceProps \u00b6 Properties for initialization of Service . Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . ServiceProps ( metadata : ApiObjectMetadata = None , cluster_i_p : str = None , external_i_ps : typing . List [ str ] = None , external_name : str = None , load_balancer_source_ranges : typing . List [ str ] = None , ports : typing . List [ ServicePort ] = None , type : ServiceType = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. cluster_i_p Optional \u00b6 cluster_i_p : str Type: str Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies external_i_ps Optional \u00b6 external_i_ps : typing . List [ str ] Type: typing.List[ str ] Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. external_name Optional \u00b6 external_name : str Type: str Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. load_balancer_source_ranges Optional \u00b6 load_balancer_source_ranges : typing . List [ str ] Type: typing.List[ str ] A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 ports : typing . List [ ServicePort ] Type: typing.List[ cdk8s_plus_17.ServicePort ] The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 type : ServiceType Type: cdk8s_plus_17.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types StatefulSetProps \u00b6 Properties for initialization of StatefulSet . Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . StatefulSetProps ( metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , service : Service , default_selector : bool = None , pod_management_policy : PodManagementPolicy = None , replicas : typing . Union [ int , float ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_17.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_17.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata. service Required \u00b6 service : Service Type: cdk8s_plus_17.Service Service to associate with the statefulset. default_selector Optional \u00b6 default_selector : bool Type: bool Default: true Automatically allocates a pod selector for this statefulset. If this is set to false you must define your selector through statefulset.podMetadata.addLabel() and statefulset.selectByLabel() . pod_management_policy Optional \u00b6 pod_management_policy : PodManagementPolicy Type: cdk8s_plus_17.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Number of desired pods. VolumeMount \u00b6 Mount a volume from the pod to the container. Initializer \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . VolumeMount ( propagation : MountPropagation = None , read_only : bool = None , sub_path : str = None , sub_path_expr : str = None , path : str , volume : Volume ) propagation Optional \u00b6 propagation : MountPropagation Type: cdk8s_plus_17.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. This field is beta in 1.10. read_only Optional \u00b6 read_only : bool Type: bool Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. sub_path Optional \u00b6 sub_path : str Type: str Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). sub_path_expr Optional \u00b6 sub_path_expr : str Type: str Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). SubPathExpr and SubPath are mutually exclusive. This field is beta in 1.15. subPathExpr and subPath are mutually exclusive. This field is beta in 1.15. path Required \u00b6 path : str Type: str Path within the container at which the volume should be mounted. Must not contain \u2018:\u2019. volume Required \u00b6 volume : Volume Type: cdk8s_plus_17.Volume The volume to mount. Classes \u00b6 Container \u00b6 A single application container that you want to run within a pod. Initializers \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_17.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_17.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_17.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. Methods \u00b6 add_env \u00b6 def add_env ( name : str , value : EnvValue ) name Required \u00b6 Type: str The variable name. value Required \u00b6 Type: cdk8s_plus_17.EnvValue The variable value. mount \u00b6 def mount ( path : str , volume : Volume , propagation : MountPropagation = None , read_only : bool = None , sub_path : str = None , sub_path_expr : str = None ) path Required \u00b6 Type: str The desired path in the container. volume Required \u00b6 Type: cdk8s_plus_17.Volume The volume to mount. propagation Optional \u00b6 Type: cdk8s_plus_17.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. This field is beta in 1.10. read_only Optional \u00b6 Type: bool Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. sub_path Optional \u00b6 Type: str Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). sub_path_expr Optional \u00b6 Type: str Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). SubPathExpr and SubPath are mutually exclusive. This field is beta in 1.15. subPathExpr and subPath are mutually exclusive. This field is beta in 1.15. Properties \u00b6 env Required \u00b6 env : typing . Mapping [ EnvValue ] Type: typing.Mapping[ cdk8s_plus_17.EnvValue ] The environment variables for this container. Returns a copy. To add environment variables use addEnv() . image Required \u00b6 image : str Type: str The container image. image_pull_policy Required \u00b6 image_pull_policy : ImagePullPolicy Type: cdk8s_plus_17.ImagePullPolicy Image pull policy for this container. mounts Required \u00b6 mounts : typing . List [ VolumeMount ] Type: typing.List[ cdk8s_plus_17.VolumeMount ] Volume mounts configured for this container. name Required \u00b6 name : str Type: str The name of the container. args Optional \u00b6 args : typing . List [ str ] Type: typing.List[ str ] Arguments to the entrypoint. command Optional \u00b6 command : typing . List [ str ] Type: typing.List[ str ] Entrypoint array (the command to execute when the container starts). port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] The port this container exposes. working_dir Optional \u00b6 working_dir : str Type: str The working directory inside the container. EnvValue \u00b6 Utility class for creating reading env values from various sources. Static Functions \u00b6 from_config_map \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . EnvValue . from_config_map ( config_map : IConfigMap , key : str , optional : bool = None ) config_map Required \u00b6 Type: cdk8s_plus_17.IConfigMap The config map. key Required \u00b6 Type: str The key to extract the value from. optional Optional \u00b6 Type: bool Default: false Specify whether the ConfigMap or its key must be defined. from_process \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . EnvValue . from_process ( key : str , required : bool = None ) key Required \u00b6 Type: str The key to read. required Optional \u00b6 Type: bool Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. from_secret_value \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . EnvValue . from_secret_value ( key : str , secret : ISecret , optional : bool = None ) key Required \u00b6 Type: str The JSON key. secret Required \u00b6 Type: cdk8s_plus_17.ISecret The secret. optional Optional \u00b6 Type: bool Default: false Specify whether the Secret or its key must be defined. from_value \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . EnvValue . from_value ( value : str ) value Required \u00b6 Type: str The value. Properties \u00b6 value Optional \u00b6 value : typing . Any Type: typing.Any value_from Optional \u00b6 value_from : typing . Any Type: typing.Any IngressV1Beta1Backend \u00b6 The backend for an ingress path. Static Functions \u00b6 from_service \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . IngressV1Beta1Backend . from_service ( service : Service , port : typing . Union [ int , float ] = None ) service Required \u00b6 Type: cdk8s_plus_17.Service The service object. port Optional \u00b6 Type: typing.Union[int, float] Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. - If the service exposes multiple ports, this option must be specified. - If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. PodSpec \u00b6 Implements: cdk8s_plus_17.IPodSpec Provides read/write capabilities ontop of a PodSpecProps . Initializers \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . PodSpec ( containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) containers Optional \u00b6 Type: typing.List[ cdk8s_plus_17.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_17.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_17.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_17.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_17.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( volume : Volume ) volume Required \u00b6 Type: cdk8s_plus_17.Volume Properties \u00b6 containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_17.Container ] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_17.Volume ] The volumes associated with this pod. Use addVolume to add volumes. restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_17.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_17.IServiceAccount The service account used to run this pod. PodTemplate \u00b6 Implements: cdk8s_plus_17.IPodTemplate Provides read/write capabilities ontop of a PodTemplateProps . Initializers \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . PodTemplate ( containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None ) containers Optional \u00b6 Type: typing.List[ cdk8s_plus_17.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_17.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata. Properties \u00b6 pod_metadata Required \u00b6 pod_metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. Probe \u00b6 Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic. Initializers \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Probe () Static Functions \u00b6 from_command \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Probe . from_command ( command : typing . List [ str ], failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None ) command Required \u00b6 Type: typing.List[ str ] The command to execute. failure_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes from_http_get \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Probe . from_http_get ( path : str , failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None , port : typing . Union [ int , float ] = None ) path Required \u00b6 Type: str The URL path to hit. failure_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to use when sending the GET request. Volume \u00b6 Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes Initializers \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Volume ( name : str , config : typing . Any ) name Required \u00b6 Type: str config Required \u00b6 Type: typing.Any Static Functions \u00b6 from_config_map \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Volume . from_config_map ( config_map : IConfigMap , default_mode : typing . Union [ int , float ] = None , items : typing . Mapping [ PathMapping ] = None , name : str = None , optional : bool = None ) config_map Required \u00b6 Type: cdk8s_plus_17.IConfigMap The config map to use to populate the volume. default_mode Optional \u00b6 Type: typing.Union[int, float] Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_17.PathMapping ] Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 Type: str Default: auto-generated The volume name. optional Optional \u00b6 Type: bool Default: undocumented Specify whether the ConfigMap or its keys must be defined. from_empty_dir \u00b6 import cdk8s_plus_17 cdk8s_plus_17 . Volume . from_empty_dir ( name : str , medium : EmptyDirMedium = None , size_limit : Size = None ) name Required \u00b6 Type: str medium Optional \u00b6 Type: cdk8s_plus_17.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. size_limit Optional \u00b6 Type: cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. Properties \u00b6 name Required \u00b6 name : str Type: str Protocols \u00b6 IConfigMap \u00b6 Extends: cdk8s_plus_17.IResource Implemented By: cdk8s_plus_17.ConfigMap , cdk8s_plus_17.IConfigMap Represents a config map. Properties \u00b6 name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IPodSpec \u00b6 Implemented By: cdk8s_plus_17.Deployment , cdk8s_plus_17.Job , cdk8s_plus_17.Pod , cdk8s_plus_17.PodSpec , cdk8s_plus_17.PodTemplate , cdk8s_plus_17.StatefulSet , cdk8s_plus_17.IPodSpec , cdk8s_plus_17.IPodTemplate Represents a resource that can be configured with a kuberenets pod spec. (e.g Deployment , Job , Pod , \u2026). Use the PodSpec class as an implementation helper. Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_17.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_17.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_17.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_17.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( volume : Volume ) volume Required \u00b6 Type: cdk8s_plus_17.Volume The volume. Properties \u00b6 containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_17.Container ] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_17.Volume ] The volumes associated with this pod. Use addVolume to add volumes. restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_17.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_17.IServiceAccount The service account used to run this pod. IPodTemplate \u00b6 Extends: cdk8s_plus_17.IPodSpec Implemented By: cdk8s_plus_17.Deployment , cdk8s_plus_17.Job , cdk8s_plus_17.PodTemplate , cdk8s_plus_17.StatefulSet , cdk8s_plus_17.IPodTemplate Represents a resource that can be configured with a kuberenets pod template. (e.g Deployment , Job , \u2026). Use the PodTemplate class as an implementation helper. Properties \u00b6 containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_17.Container ] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_17.Volume ] The volumes associated with this pod. Use addVolume to add volumes. restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_17.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_17.IServiceAccount The service account used to run this pod. pod_metadata Required \u00b6 pod_metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. IResource \u00b6 Implemented By: cdk8s_plus_17.ConfigMap , cdk8s_plus_17.Deployment , cdk8s_plus_17.IngressV1Beta1 , cdk8s_plus_17.Job , cdk8s_plus_17.Pod , cdk8s_plus_17.Resource , cdk8s_plus_17.Secret , cdk8s_plus_17.Service , cdk8s_plus_17.ServiceAccount , cdk8s_plus_17.StatefulSet , cdk8s_plus_17.IConfigMap , cdk8s_plus_17.IResource , cdk8s_plus_17.ISecret , cdk8s_plus_17.IServiceAccount Represents a resource. Properties \u00b6 name Required \u00b6 name : str Type: str The Kubernetes name of this resource. ISecret \u00b6 Extends: cdk8s_plus_17.IResource Implemented By: cdk8s_plus_17.Secret , cdk8s_plus_17.ISecret Properties \u00b6 name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IServiceAccount \u00b6 Extends: cdk8s_plus_17.IResource Implemented By: cdk8s_plus_17.ServiceAccount , cdk8s_plus_17.IServiceAccount Properties \u00b6 name Required \u00b6 name : str Type: str The Kubernetes name of this resource. Enums \u00b6 EmptyDirMedium \u00b6 The medium on which to store the volume. DEFAULT \u00b6 The default volume of the backing node. MEMORY \u00b6 Mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. ImagePullPolicy \u00b6 ALWAYS \u00b6 Every time the kubelet launches a container, the kubelet queries the container image registry to resolve the name to an image digest. If the kubelet has a container image with that exact digest cached locally, the kubelet uses its cached image; otherwise, the kubelet downloads (pulls) the image with the resolved digest, and uses that image to launch the container. Default is Always if ImagePullPolicy is omitted and either the image tag is :latest or the image tag is omitted. IF_NOT_PRESENT \u00b6 The image is pulled only if it is not already present locally. Default is IfNotPresent if ImagePullPolicy is omitted and the image tag is present but not :latest NEVER \u00b6 The image is assumed to exist locally. No attempt is made to pull the image. MountPropagation \u00b6 NONE \u00b6 This volume mount will not receive any subsequent mounts that are mounted to this volume or any of its subdirectories by the host. In similar fashion, no mounts created by the Container will be visible on the host. This is the default mode. This mode is equal to private mount propagation as described in the Linux kernel documentation HOST_TO_CONTAINER \u00b6 This volume mount will receive all subsequent mounts that are mounted to this volume or any of its subdirectories. In other words, if the host mounts anything inside the volume mount, the Container will see it mounted there. Similarly, if any Pod with Bidirectional mount propagation to the same volume mounts anything there, the Container with HostToContainer mount propagation will see it. This mode is equal to rslave mount propagation as described in the Linux kernel documentation BIDIRECTIONAL \u00b6 This volume mount behaves the same the HostToContainer mount. In addition, all volume mounts created by the Container will be propagated back to the host and to all Containers of all Pods that use the same volume A typical use case for this mode is a Pod with a FlexVolume or CSI driver or a Pod that needs to mount something on the host using a hostPath volume. This mode is equal to rshared mount propagation as described in the Linux kernel documentation Caution: Bidirectional mount propagation can be dangerous. It can damage the host operating system and therefore it is allowed only in privileged Containers. Familiarity with Linux kernel behavior is strongly recommended. In addition, any volume mounts created by Containers in Pods must be destroyed (unmounted) by the Containers on termination. PodManagementPolicy \u00b6 Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once. ORDERED_READY \u00b6 PARALLEL \u00b6 Protocol \u00b6 TCP \u00b6 UDP \u00b6 SCTP \u00b6 RestartPolicy \u00b6 Restart policy for all containers within the pod. ALWAYS \u00b6 Always restart the pod after it exits. ON_FAILURE \u00b6 Only restart if the pod exits with a non-zero exit code. NEVER \u00b6 Never restart the pod. ServiceType \u00b6 For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP. CLUSTER_IP \u00b6 Exposes the Service on a cluster-internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default ServiceType NODE_PORT \u00b6 Exposes the Service on each Node\u2019s IP at a static port (the NodePort). A ClusterIP Service, to which the NodePort Service routes, is automatically created. You\u2019ll be able to contact the NodePort Service, from outside the cluster, by requesting : . LOAD_BALANCER \u00b6 Exposes the Service externally using a cloud provider\u2019s load balancer. NodePort and ClusterIP Services, to which the external load balancer routes, are automatically created. EXTERNAL_NAME \u00b6 Maps the Service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value. No proxying of any kind is set up. Note: You need either kube-dns version 1.7 or CoreDNS version 0.0.8 or higher to use the ExternalName type.","title":"Python"},{"location":"reference/cdk8s-plus-17/python/#cdk8s-plus-17-python","text":"","title":"cdk8s-plus-17 (Python) "},{"location":"reference/cdk8s-plus-17/python/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s-plus-17/python/#configmap","text":"Implements: cdk8s_plus_17.IConfigMap ConfigMap holds configuration data for pods to consume.","title":"ConfigMap "},{"location":"reference/cdk8s-plus-17/python/#deployment","text":"Implements: cdk8s_plus_17.IPodTemplate A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below.","title":"Deployment "},{"location":"reference/cdk8s-plus-17/python/#use-case","text":"The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore.","title":"Use Case"},{"location":"reference/cdk8s-plus-17/python/#ingressv1beta1","text":"Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.","title":"IngressV1Beta1 "},{"location":"reference/cdk8s-plus-17/python/#job","text":"Implements: cdk8s_plus_17.IPodTemplate A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel.","title":"Job "},{"location":"reference/cdk8s-plus-17/python/#pod","text":"Implements: cdk8s_plus_17.IPodSpec Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.","title":"Pod "},{"location":"reference/cdk8s-plus-17/python/#resource","text":"Implements: cdk8s_plus_17.IResource Base class for all Kubernetes objects in stdk8s. Represents a single resource.","title":"Resource "},{"location":"reference/cdk8s-plus-17/python/#secret","text":"Implements: cdk8s_plus_17.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret","title":"Secret "},{"location":"reference/cdk8s-plus-17/python/#service","text":"An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods.","title":"Service "},{"location":"reference/cdk8s-plus-17/python/#serviceaccount","text":"Implements: cdk8s_plus_17.IServiceAccount A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account","title":"ServiceAccount "},{"location":"reference/cdk8s-plus-17/python/#statefulset","text":"Implements: cdk8s_plus_17.IPodTemplate StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed.","title":"StatefulSet "},{"location":"reference/cdk8s-plus-17/python/#using-statefulsets","text":"StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates.","title":"Using StatefulSets"},{"location":"reference/cdk8s-plus-17/python/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s-plus-17/python/#adddirectoryoptions","text":"Options for configmap.addDirectory() .","title":"AddDirectoryOptions "},{"location":"reference/cdk8s-plus-17/python/#commandprobeoptions","text":"Options for Probe.fromCommand() .","title":"CommandProbeOptions "},{"location":"reference/cdk8s-plus-17/python/#configmapprops","text":"Properties for initialization of ConfigMap .","title":"ConfigMapProps "},{"location":"reference/cdk8s-plus-17/python/#configmapvolumeoptions","text":"Options for the ConfigMap-based volume.","title":"ConfigMapVolumeOptions "},{"location":"reference/cdk8s-plus-17/python/#containerprops","text":"Properties for creating a container.","title":"ContainerProps "},{"location":"reference/cdk8s-plus-17/python/#deploymentprops","text":"Properties for initialization of Deployment .","title":"DeploymentProps "},{"location":"reference/cdk8s-plus-17/python/#emptydirvolumeoptions","text":"Options for volumes populated with an empty directory.","title":"EmptyDirVolumeOptions "},{"location":"reference/cdk8s-plus-17/python/#envvaluefromconfigmapoptions","text":"Options to specify an envionment variable value from a ConfigMap key.","title":"EnvValueFromConfigMapOptions "},{"location":"reference/cdk8s-plus-17/python/#envvaluefromprocessoptions","text":"Options to specify an environment variable value from the process environment.","title":"EnvValueFromProcessOptions "},{"location":"reference/cdk8s-plus-17/python/#envvaluefromsecretoptions","text":"Options to specify an environment variable value from a Secret.","title":"EnvValueFromSecretOptions "},{"location":"reference/cdk8s-plus-17/python/#exposeoptions","text":"Options for exposing a deployment via a service.","title":"ExposeOptions "},{"location":"reference/cdk8s-plus-17/python/#httpgetprobeoptions","text":"Options for Probe.fromHttpGet() .","title":"HttpGetProbeOptions "},{"location":"reference/cdk8s-plus-17/python/#ingressv1beta1props","text":"Properties for Ingress .","title":"IngressV1Beta1Props "},{"location":"reference/cdk8s-plus-17/python/#ingressv1beta1rule","text":"Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path.","title":"IngressV1Beta1Rule "},{"location":"reference/cdk8s-plus-17/python/#ingressv1beta1tls","text":"Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination.","title":"IngressV1Beta1Tls "},{"location":"reference/cdk8s-plus-17/python/#jobprops","text":"Properties for initialization of Job .","title":"JobProps "},{"location":"reference/cdk8s-plus-17/python/#mountoptions","text":"Options for mounts.","title":"MountOptions "},{"location":"reference/cdk8s-plus-17/python/#pathmapping","text":"Maps a string key to a path within a volume.","title":"PathMapping "},{"location":"reference/cdk8s-plus-17/python/#podprops","text":"Properties for initialization of Pod .","title":"PodProps "},{"location":"reference/cdk8s-plus-17/python/#podspecprops","text":"Properties of a PodSpec .","title":"PodSpecProps "},{"location":"reference/cdk8s-plus-17/python/#podtemplateprops","text":"Properties of a PodTemplate . Adds metadata information on top of the spec.","title":"PodTemplateProps "},{"location":"reference/cdk8s-plus-17/python/#probeoptions","text":"Probe options.","title":"ProbeOptions "},{"location":"reference/cdk8s-plus-17/python/#resourceprops","text":"Initialization properties for resources.","title":"ResourceProps "},{"location":"reference/cdk8s-plus-17/python/#secretprops","text":"","title":"SecretProps "},{"location":"reference/cdk8s-plus-17/python/#secretvalue","text":"Represents a specific value in JSON secret.","title":"SecretValue "},{"location":"reference/cdk8s-plus-17/python/#serviceaccountprops","text":"Properties for initialization of ServiceAccount . Properties for initialization of ServiceAccount .","title":"ServiceAccountProps "},{"location":"reference/cdk8s-plus-17/python/#serviceingressv1betabackendoptions","text":"Options for setting up backends for ingress rules.","title":"ServiceIngressV1BetaBackendOptions "},{"location":"reference/cdk8s-plus-17/python/#serviceport","text":"Definition of a service port.","title":"ServicePort "},{"location":"reference/cdk8s-plus-17/python/#serviceportoptions","text":"","title":"ServicePortOptions "},{"location":"reference/cdk8s-plus-17/python/#serviceprops","text":"Properties for initialization of Service .","title":"ServiceProps "},{"location":"reference/cdk8s-plus-17/python/#statefulsetprops","text":"Properties for initialization of StatefulSet .","title":"StatefulSetProps "},{"location":"reference/cdk8s-plus-17/python/#volumemount","text":"Mount a volume from the pod to the container.","title":"VolumeMount "},{"location":"reference/cdk8s-plus-17/python/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s-plus-17/python/#container","text":"A single application container that you want to run within a pod.","title":"Container "},{"location":"reference/cdk8s-plus-17/python/#envvalue","text":"Utility class for creating reading env values from various sources.","title":"EnvValue "},{"location":"reference/cdk8s-plus-17/python/#ingressv1beta1backend","text":"The backend for an ingress path.","title":"IngressV1Beta1Backend "},{"location":"reference/cdk8s-plus-17/python/#podspec","text":"Implements: cdk8s_plus_17.IPodSpec Provides read/write capabilities ontop of a PodSpecProps .","title":"PodSpec "},{"location":"reference/cdk8s-plus-17/python/#podtemplate","text":"Implements: cdk8s_plus_17.IPodTemplate Provides read/write capabilities ontop of a PodTemplateProps .","title":"PodTemplate "},{"location":"reference/cdk8s-plus-17/python/#probe","text":"Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.","title":"Probe "},{"location":"reference/cdk8s-plus-17/python/#volume","text":"Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes","title":"Volume "},{"location":"reference/cdk8s-plus-17/python/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s-plus-17/python/#iconfigmap","text":"Extends: cdk8s_plus_17.IResource Implemented By: cdk8s_plus_17.ConfigMap , cdk8s_plus_17.IConfigMap Represents a config map.","title":"IConfigMap "},{"location":"reference/cdk8s-plus-17/python/#ipodspec","text":"Implemented By: cdk8s_plus_17.Deployment , cdk8s_plus_17.Job , cdk8s_plus_17.Pod , cdk8s_plus_17.PodSpec , cdk8s_plus_17.PodTemplate , cdk8s_plus_17.StatefulSet , cdk8s_plus_17.IPodSpec , cdk8s_plus_17.IPodTemplate Represents a resource that can be configured with a kuberenets pod spec. (e.g Deployment , Job , Pod , \u2026). Use the PodSpec class as an implementation helper.","title":"IPodSpec "},{"location":"reference/cdk8s-plus-17/python/#ipodtemplate","text":"Extends: cdk8s_plus_17.IPodSpec Implemented By: cdk8s_plus_17.Deployment , cdk8s_plus_17.Job , cdk8s_plus_17.PodTemplate , cdk8s_plus_17.StatefulSet , cdk8s_plus_17.IPodTemplate Represents a resource that can be configured with a kuberenets pod template. (e.g Deployment , Job , \u2026). Use the PodTemplate class as an implementation helper.","title":"IPodTemplate "},{"location":"reference/cdk8s-plus-17/python/#iresource","text":"Implemented By: cdk8s_plus_17.ConfigMap , cdk8s_plus_17.Deployment , cdk8s_plus_17.IngressV1Beta1 , cdk8s_plus_17.Job , cdk8s_plus_17.Pod , cdk8s_plus_17.Resource , cdk8s_plus_17.Secret , cdk8s_plus_17.Service , cdk8s_plus_17.ServiceAccount , cdk8s_plus_17.StatefulSet , cdk8s_plus_17.IConfigMap , cdk8s_plus_17.IResource , cdk8s_plus_17.ISecret , cdk8s_plus_17.IServiceAccount Represents a resource.","title":"IResource "},{"location":"reference/cdk8s-plus-17/python/#isecret","text":"Extends: cdk8s_plus_17.IResource Implemented By: cdk8s_plus_17.Secret , cdk8s_plus_17.ISecret","title":"ISecret "},{"location":"reference/cdk8s-plus-17/python/#iserviceaccount","text":"Extends: cdk8s_plus_17.IResource Implemented By: cdk8s_plus_17.ServiceAccount , cdk8s_plus_17.IServiceAccount","title":"IServiceAccount "},{"location":"reference/cdk8s-plus-17/python/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s-plus-17/python/#emptydirmedium","text":"The medium on which to store the volume.","title":"EmptyDirMedium "},{"location":"reference/cdk8s-plus-17/python/#imagepullpolicy","text":"","title":"ImagePullPolicy "},{"location":"reference/cdk8s-plus-17/python/#mountpropagation","text":"","title":"MountPropagation "},{"location":"reference/cdk8s-plus-17/python/#podmanagementpolicy","text":"Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.","title":"PodManagementPolicy "},{"location":"reference/cdk8s-plus-17/python/#protocol","text":"","title":"Protocol "},{"location":"reference/cdk8s-plus-17/python/#restartpolicy","text":"Restart policy for all containers within the pod.","title":"RestartPolicy "},{"location":"reference/cdk8s-plus-17/python/#servicetype","text":"For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP.","title":"ServiceType "},{"location":"reference/cdk8s-plus-17/typescript/","text":"cdk8s-plus-17 (TypeScript) \u00b6 Constructs \u00b6 ConfigMap \u00b6 Implements: cdk8s-plus-17.IConfigMap ConfigMap holds configuration data for pods to consume. Initializers \u00b6 import { ConfigMap } from 'cdk8s-plus-17' new ConfigMap ( scope : Construct , id : string , props? : ConfigMapProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-17.ConfigMapProps Methods \u00b6 addBinaryData \u00b6 public addBinaryData ( key : string , value : string ) key Required \u00b6 Type: string The key. value Required \u00b6 Type: string The value. addData \u00b6 public addData ( key : string , value : string ) key Required \u00b6 Type: string The key. value Required \u00b6 Type: string The value. addDirectory \u00b6 public addDirectory ( localDir : string , options? : AddDirectoryOptions ) localDir Required \u00b6 Type: string A path to a local directory. options Optional \u00b6 Type: cdk8s-plus-17.AddDirectoryOptions Options. addFile \u00b6 public addFile ( localFile : string , key? : string ) localFile Required \u00b6 Type: string The path to the local file. key Optional \u00b6 Type: string The ConfigMap key (default to the file name). Static Functions \u00b6 fromConfigMapName \u00b6 import { ConfigMap } from 'cdk8s-plus-17' ConfigMap . fromConfigMapName ( name : string ) name Required \u00b6 Type: string The name of the config map to import. Properties \u00b6 binaryData Required \u00b6 public readonly binaryData : {[ key : string ] : string }; Type: {[ key: string ]: string } The binary data associated with this config map. Returns a copy. To add data records, use addBinaryData() or addData() . data Required \u00b6 public readonly data : {[ key : string ] : string }; Type: {[ key: string ]: string } The data associated with this config map. Returns an copy. To add data records, use addData() or addBinaryData() . Deployment \u00b6 Implements: cdk8s-plus-17.IPodTemplate A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case \u00b6 The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore. Initializers \u00b6 import { Deployment } from 'cdk8s-plus-17' new Deployment ( scope : Construct , id : string , props? : DeploymentProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-17.DeploymentProps Methods \u00b6 addContainer \u00b6 public addContainer ( container : ContainerProps ) container Required \u00b6 Type: cdk8s-plus-17.ContainerProps addVolume \u00b6 public addVolume ( volume : Volume ) volume Required \u00b6 Type: cdk8s-plus-17.Volume expose \u00b6 public expose ( port : number , options? : ExposeOptions ) port Required \u00b6 Type: number The port number the service will bind to. options Optional \u00b6 Type: cdk8s-plus-17.ExposeOptions Options to determine details of the service and port exposed. selectByLabel \u00b6 public selectByLabel ( key : string , value : string ) key Required \u00b6 Type: string The label key. value Required \u00b6 Type: string The label value. Properties \u00b6 containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-17.Container [] The containers belonging to the pod. Use addContainer to add containers. labelSelector Required \u00b6 public readonly labelSelector : {[ key : string ] : string }; Type: {[ key: string ]: string } The labels this deployment will match against in order to select pods. Returns a a copy. Use selectByLabel() to add labels. podMetadata Required \u00b6 public readonly podMetadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. replicas Required \u00b6 public readonly replicas : number ; Type: number Number of desired pods. volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-17.Volume [] The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-17.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-17.IServiceAccount The service account used to run this pod. IngressV1Beta1 \u00b6 Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. Initializers \u00b6 import { IngressV1Beta1 } from 'cdk8s-plus-17' new IngressV1Beta1 ( scope : Construct , id : string , props? : IngressV1Beta1Props ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-17.IngressV1Beta1Props Methods \u00b6 addDefaultBackend \u00b6 public addDefaultBackend ( backend : IngressV1Beta1Backend ) backend Required \u00b6 Type: cdk8s-plus-17.IngressV1Beta1Backend The backend to use for requests that do not match any rule. addHostDefaultBackend \u00b6 public addHostDefaultBackend ( host : string , backend : IngressV1Beta1Backend ) host Required \u00b6 Type: string The host name to match. backend Required \u00b6 Type: cdk8s-plus-17.IngressV1Beta1Backend The backend to route to. addHostRule \u00b6 public addHostRule ( host : string , path : string , backend : IngressV1Beta1Backend ) host Required \u00b6 Type: string The host name. path Required \u00b6 Type: string The HTTP path. backend Required \u00b6 Type: cdk8s-plus-17.IngressV1Beta1Backend The backend to route requests to. addRule \u00b6 public addRule ( path : string , backend : IngressV1Beta1Backend ) path Required \u00b6 Type: string The HTTP path. backend Required \u00b6 Type: cdk8s-plus-17.IngressV1Beta1Backend The backend to route requests to. addRules \u00b6 public addRules ( rules : IngressV1Beta1Rule ) rules Required \u00b6 Type: cdk8s-plus-17.IngressV1Beta1Rule The rules to add. addTls \u00b6 public addTls ( tls : IngressV1Beta1Tls []) tls Required \u00b6 Type: cdk8s-plus-17.IngressV1Beta1Tls [] Job \u00b6 Implements: cdk8s-plus-17.IPodTemplate A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel. Initializers \u00b6 import { Job } from 'cdk8s-plus-17' new Job ( scope : Construct , id : string , props? : JobProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-17.JobProps Methods \u00b6 addContainer \u00b6 public addContainer ( container : ContainerProps ) container Required \u00b6 Type: cdk8s-plus-17.ContainerProps addVolume \u00b6 public addVolume ( volume : Volume ) volume Required \u00b6 Type: cdk8s-plus-17.Volume Properties \u00b6 containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-17.Container [] The containers belonging to the pod. Use addContainer to add containers. podMetadata Required \u00b6 public readonly podMetadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-17.Volume [] The volumes associated with this pod. Use addVolume to add volumes. activeDeadline Optional \u00b6 public readonly activeDeadline : Duration ; Type: cdk8s.Duration Duration before job is terminated. If undefined, there is no deadline. backoffLimit Optional \u00b6 public readonly backoffLimit : number ; Type: number Number of retries before marking failed. restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-17.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-17.IServiceAccount The service account used to run this pod. ttlAfterFinished Optional \u00b6 public readonly ttlAfterFinished : Duration ; Type: cdk8s.Duration TTL before the job is deleted after it is finished. Pod \u00b6 Implements: cdk8s-plus-17.IPodSpec Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts. Initializers \u00b6 import { Pod } from 'cdk8s-plus-17' new Pod ( scope : Construct , id : string , props? : PodProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-17.PodProps Methods \u00b6 addContainer \u00b6 public addContainer ( container : ContainerProps ) container Required \u00b6 Type: cdk8s-plus-17.ContainerProps addVolume \u00b6 public addVolume ( volume : Volume ) volume Required \u00b6 Type: cdk8s-plus-17.Volume Properties \u00b6 containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-17.Container [] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-17.Volume [] The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-17.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-17.IServiceAccount The service account used to run this pod. Resource \u00b6 Implements: cdk8s-plus-17.IResource Base class for all Kubernetes objects in stdk8s. Represents a single resource. Initializers \u00b6 import { Resource } from 'cdk8s-plus-17' new Resource ( scope : Construct , id : string , options? : ConstructOptions ) scope Required \u00b6 Type: constructs.Construct The scope in which to define this construct. id Required \u00b6 Type: string The scoped construct ID. Must be unique amongst siblings. If the ID includes a path separator ( / ), then it will be replaced by double dash -- . options Optional \u00b6 Type: constructs.ConstructOptions Options. Properties \u00b6 metadata Required \u00b6 public readonly metadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition name Required \u00b6 public readonly name : string ; Type: string The name of this API object. Secret \u00b6 Implements: cdk8s-plus-17.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret Initializers \u00b6 import { Secret } from 'cdk8s-plus-17' new Secret ( scope : Construct , id : string , props? : SecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-17.SecretProps Methods \u00b6 addStringData \u00b6 public addStringData ( key : string , value : string ) key Required \u00b6 Type: string Key. value Required \u00b6 Type: string Value. getStringData \u00b6 public getStringData ( key : string ) key Required \u00b6 Type: string Key. Static Functions \u00b6 fromSecretName \u00b6 import { Secret } from 'cdk8s-plus-17' Secret . fromSecretName ( name : string ) name Required \u00b6 Type: string The name of the secret to reference. Service \u00b6 An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods. Initializers \u00b6 import { Service } from 'cdk8s-plus-17' new Service ( scope : Construct , id : string , props? : ServiceProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-17.ServiceProps Methods \u00b6 addDeployment \u00b6 public addDeployment ( deployment : Deployment , port : number , options? : ServicePortOptions ) deployment Required \u00b6 Type: cdk8s-plus-17.Deployment The deployment to expose. port Required \u00b6 Type: number The external port. options Optional \u00b6 Type: cdk8s-plus-17.ServicePortOptions Optional settings for the port. addSelector \u00b6 public addSelector ( label : string , value : string ) label Required \u00b6 Type: string The label key. value Required \u00b6 Type: string The label value. serve \u00b6 public serve ( port : number , options? : ServicePortOptions ) port Required \u00b6 Type: number The port definition. options Optional \u00b6 Type: cdk8s-plus-17.ServicePortOptions Properties \u00b6 ports Required \u00b6 public readonly ports : ServicePort []; Type: cdk8s-plus-17.ServicePort [] Ports for this service. Use serve() to expose additional service ports. selector Required \u00b6 public readonly selector : {[ key : string ] : string }; Type: {[ key: string ]: string } Returns the labels which are used to select pods for this service. type Required \u00b6 public readonly type : ServiceType ; Type: cdk8s-plus-17.ServiceType Determines how the Service is exposed. clusterIP Optional \u00b6 public readonly clusterIP : string ; Type: string The IP address of the service and is usually assigned randomly by the master. externalName Optional \u00b6 public readonly externalName : string ; Type: string The externalName to be used for EXTERNAL_NAME types. ServiceAccount \u00b6 Implements: cdk8s-plus-17.IServiceAccount A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account Initializers \u00b6 import { ServiceAccount } from 'cdk8s-plus-17' new ServiceAccount ( scope : Construct , id : string , props? : ServiceAccountProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-17.ServiceAccountProps Methods \u00b6 addSecret \u00b6 public addSecret ( secret : ISecret ) secret Required \u00b6 Type: cdk8s-plus-17.ISecret The secret. Static Functions \u00b6 fromServiceAccountName \u00b6 import { ServiceAccount } from 'cdk8s-plus-17' ServiceAccount . fromServiceAccountName ( name : string ) name Required \u00b6 Type: string The name of the service account resource. Properties \u00b6 secrets Required \u00b6 public readonly secrets : ISecret []; Type: cdk8s-plus-17.ISecret [] List of secrets allowed to be used by pods running using this service account. Returns a copy. To add a secret, use addSecret() . StatefulSet \u00b6 Implements: cdk8s-plus-17.IPodTemplate StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed. Using StatefulSets \u00b6 StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates. Initializers \u00b6 import { StatefulSet } from 'cdk8s-plus-17' new StatefulSet ( scope : Construct , id : string , props : StatefulSetProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-17.StatefulSetProps Methods \u00b6 addContainer \u00b6 public addContainer ( container : ContainerProps ) container Required \u00b6 Type: cdk8s-plus-17.ContainerProps addVolume \u00b6 public addVolume ( volume : Volume ) volume Required \u00b6 Type: cdk8s-plus-17.Volume selectByLabel \u00b6 public selectByLabel ( key : string , value : string ) key Required \u00b6 Type: string The label key. value Required \u00b6 Type: string The label value. Properties \u00b6 containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-17.Container [] The containers belonging to the pod. Use addContainer to add containers. labelSelector Required \u00b6 public readonly labelSelector : {[ key : string ] : string }; Type: {[ key: string ]: string } The labels this statefulset will match against in order to select pods. Returns a a copy. Use selectByLabel() to add labels. podManagementPolicy Required \u00b6 public readonly podManagementPolicy : PodManagementPolicy ; Type: cdk8s-plus-17.PodManagementPolicy Management policy to use for the set. podMetadata Required \u00b6 public readonly podMetadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. replicas Required \u00b6 public readonly replicas : number ; Type: number Number of desired pods. volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-17.Volume [] The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-17.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-17.IServiceAccount The service account used to run this pod. Structs \u00b6 AddDirectoryOptions \u00b6 Options for configmap.addDirectory() . Initializer \u00b6 import { AddDirectoryOptions } from 'cdk8s-plus-17' const addDirectoryOptions : AddDirectoryOptions = { ... } exclude Optional \u00b6 public readonly exclude : string []; Type: string [] Default: include all files Glob patterns to exclude when adding files. keyPrefix Optional \u00b6 public readonly keyPrefix : string ; Type: string Default: \u201c\u201d A prefix to add to all keys in the config map. CommandProbeOptions \u00b6 Options for Probe.fromCommand() . Initializer \u00b6 import { CommandProbeOptions } from 'cdk8s-plus-17' const commandProbeOptions : CommandProbeOptions = { ... } failureThreshold Optional \u00b6 public readonly failureThreshold : number ; Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public readonly initialDelaySeconds : Duration ; Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public readonly periodSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public readonly successThreshold : number ; Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public readonly timeoutSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ConfigMapProps \u00b6 Properties for initialization of ConfigMap . Initializer \u00b6 import { ConfigMapProps } from 'cdk8s-plus-17' const configMapProps : ConfigMapProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binaryData Optional \u00b6 public readonly binaryData : {[ key : string ] : string }; Type: {[ key: string ]: string } BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. Using this field will require 1.10+ apiserver and kubelet. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 public readonly data : {[ key : string ] : string }; Type: {[ key: string ]: string } Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . ConfigMapVolumeOptions \u00b6 Options for the ConfigMap-based volume. Initializer \u00b6 import { ConfigMapVolumeOptions } from 'cdk8s-plus-17' const configMapVolumeOptions : ConfigMapVolumeOptions = { ... } defaultMode Optional \u00b6 public readonly defaultMode : number ; Type: number Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 public readonly items : {[ key : string ] : PathMapping }; Type: {[ key: string ]: cdk8s-plus-17.PathMapping } Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 public readonly name : string ; Type: string Default: auto-generated The volume name. optional Optional \u00b6 public readonly optional : boolean ; Type: boolean Default: undocumented Specify whether the ConfigMap or its keys must be defined. ContainerProps \u00b6 Properties for creating a container. Initializer \u00b6 import { ContainerProps } from 'cdk8s-plus-17' const containerProps : ContainerProps = { ... } image Required \u00b6 public readonly image : string ; Type: string Docker image name. args Optional \u00b6 public readonly args : string []; Type: string [] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 public readonly command : string []; Type: string [] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 public readonly env : {[ key : string ] : EnvValue }; Type: {[ key: string ]: cdk8s-plus-17.EnvValue } Default: No environment variables. List of environment variables to set in the container. Cannot be updated. imagePullPolicy Optional \u00b6 public readonly imagePullPolicy : ImagePullPolicy ; Type: cdk8s-plus-17.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 public readonly liveness : Probe ; Type: cdk8s-plus-17.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 public readonly name : string ; Type: string Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 public readonly port : number ; Type: number Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 public readonly readiness : Probe ; Type: cdk8s-plus-17.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 public readonly startup : Probe ; Type: cdk8s-plus-17.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volumeMounts Optional \u00b6 public readonly volumeMounts : VolumeMount []; Type: cdk8s-plus-17.VolumeMount [] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. workingDir Optional \u00b6 public readonly workingDir : string ; Type: string Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. DeploymentProps \u00b6 Properties for initialization of Deployment . Initializer \u00b6 import { DeploymentProps } from 'cdk8s-plus-17' const deploymentProps : DeploymentProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-17.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-17.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata. defaultSelector Optional \u00b6 public readonly defaultSelector : boolean ; Type: boolean Default: true Automatically allocates a pod selector for this deployment. If this is set to false you must define your selector through deployment.podMetadata.addLabel() and deployment.selectByLabel() . replicas Optional \u00b6 public readonly replicas : number ; Type: number Default: 1 Number of desired pods. EmptyDirVolumeOptions \u00b6 Options for volumes populated with an empty directory. Initializer \u00b6 import { EmptyDirVolumeOptions } from 'cdk8s-plus-17' const emptyDirVolumeOptions : EmptyDirVolumeOptions = { ... } medium Optional \u00b6 public readonly medium : EmptyDirMedium ; Type: cdk8s-plus-17.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. sizeLimit Optional \u00b6 public readonly sizeLimit : Size ; Type: cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. EnvValueFromConfigMapOptions \u00b6 Options to specify an envionment variable value from a ConfigMap key. Initializer \u00b6 import { EnvValueFromConfigMapOptions } from 'cdk8s-plus-17' const envValueFromConfigMapOptions : EnvValueFromConfigMapOptions = { ... } optional Optional \u00b6 public readonly optional : boolean ; Type: boolean Default: false Specify whether the ConfigMap or its key must be defined. EnvValueFromProcessOptions \u00b6 Options to specify an environment variable value from the process environment. Initializer \u00b6 import { EnvValueFromProcessOptions } from 'cdk8s-plus-17' const envValueFromProcessOptions : EnvValueFromProcessOptions = { ... } required Optional \u00b6 public readonly required : boolean ; Type: boolean Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. EnvValueFromSecretOptions \u00b6 Options to specify an environment variable value from a Secret. Initializer \u00b6 import { EnvValueFromSecretOptions } from 'cdk8s-plus-17' const envValueFromSecretOptions : EnvValueFromSecretOptions = { ... } optional Optional \u00b6 public readonly optional : boolean ; Type: boolean Default: false Specify whether the Secret or its key must be defined. ExposeOptions \u00b6 Options for exposing a deployment via a service. Initializer \u00b6 import { ExposeOptions } from 'cdk8s-plus-17' const exposeOptions : ExposeOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-17.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. serviceType Optional \u00b6 public readonly serviceType : ServiceType ; Type: cdk8s-plus-17.ServiceType Default: ClusterIP. The type of the exposed service. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. HttpGetProbeOptions \u00b6 Options for Probe.fromHttpGet() . Initializer \u00b6 import { HttpGetProbeOptions } from 'cdk8s-plus-17' const httpGetProbeOptions : HttpGetProbeOptions = { ... } failureThreshold Optional \u00b6 public readonly failureThreshold : number ; Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public readonly initialDelaySeconds : Duration ; Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public readonly periodSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public readonly successThreshold : number ; Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public readonly timeoutSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 public readonly port : number ; Type: number Default: defaults to container.port . The TCP port to use when sending the GET request. IngressV1Beta1Props \u00b6 Properties for Ingress . Initializer \u00b6 import { IngressV1Beta1Props } from 'cdk8s-plus-17' const ingressV1Beta1Props : IngressV1Beta1Props = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. defaultBackend Optional \u00b6 public readonly defaultBackend : IngressV1Beta1Backend ; Type: cdk8s-plus-17.IngressV1Beta1Backend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 public readonly rules : IngressV1Beta1Rule []; Type: cdk8s-plus-17.IngressV1Beta1Rule [] Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 public readonly tls : IngressV1Beta1Tls []; Type: cdk8s-plus-17.IngressV1Beta1Tls [] TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. IngressV1Beta1Rule \u00b6 Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path. Initializer \u00b6 import { IngressV1Beta1Rule } from 'cdk8s-plus-17' const ingressV1Beta1Rule : IngressV1Beta1Rule = { ... } backend Required \u00b6 public readonly backend : IngressV1Beta1Backend ; Type: cdk8s-plus-17.IngressV1Beta1Backend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 public readonly host : string ; Type: string Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 public readonly path : string ; Type: string Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. IngressV1Beta1Tls \u00b6 Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination. Initializer \u00b6 import { IngressV1Beta1Tls } from 'cdk8s-plus-17' const ingressV1Beta1Tls : IngressV1Beta1Tls = { ... } hosts Optional \u00b6 public readonly hosts : string []; Type: string [] Default: If unspecified, it defaults to the wildcard host setting for the loadbalancer controller fulfilling this Ingress. Hosts are a list of hosts included in the TLS certificate. The values in this list must match the name/s used in the TLS Secret. secret Optional \u00b6 public readonly secret : ISecret ; Type: cdk8s-plus-17.ISecret Default: If unspecified, it allows SSL routing based on SNI hostname. Secret is the secret that contains the certificate and key used to terminate SSL traffic on 443. If the SNI host in a listener conflicts with the \u201cHost\u201d header field used by an IngressRule, the SNI host is used for termination and value of the Host header is used for routing. JobProps \u00b6 Properties for initialization of Job . Initializer \u00b6 import { JobProps } from 'cdk8s-plus-17' const jobProps : JobProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-17.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-17.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata. activeDeadline Optional \u00b6 public readonly activeDeadline : Duration ; Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 public readonly backoffLimit : number ; Type: number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 public readonly ttlAfterFinished : Duration ; Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. MountOptions \u00b6 Options for mounts. Initializer \u00b6 import { MountOptions } from 'cdk8s-plus-17' const mountOptions : MountOptions = { ... } propagation Optional \u00b6 public readonly propagation : MountPropagation ; Type: cdk8s-plus-17.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. This field is beta in 1.10. readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public readonly subPath : string ; Type: string Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public readonly subPathExpr : string ; Type: string Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). SubPathExpr and SubPath are mutually exclusive. This field is beta in 1.15. subPathExpr and subPath are mutually exclusive. This field is beta in 1.15. PathMapping \u00b6 Maps a string key to a path within a volume. Initializer \u00b6 import { PathMapping } from 'cdk8s-plus-17' const pathMapping : PathMapping = { ... } path Required \u00b6 public readonly path : string ; Type: string The relative path of the file to map the key to. May not be an absolute path. May not contain the path element \u2018..\u2019. May not start with the string \u2018..\u2019. mode Optional \u00b6 public readonly mode : number ; Type: number Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. PodProps \u00b6 Properties for initialization of Pod . Initializer \u00b6 import { PodProps } from 'cdk8s-plus-17' const podProps : PodProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-17.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-17.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodSpecProps \u00b6 Properties of a PodSpec . Initializer \u00b6 import { PodSpecProps } from 'cdk8s-plus-17' const podSpecProps : PodSpecProps = { ... } containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-17.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-17.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodTemplateProps \u00b6 Properties of a PodTemplate . Adds metadata information on top of the spec. Initializer \u00b6 import { PodTemplateProps } from 'cdk8s-plus-17' const podTemplateProps : PodTemplateProps = { ... } containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-17.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-17.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata. ProbeOptions \u00b6 Probe options. Initializer \u00b6 import { ProbeOptions } from 'cdk8s-plus-17' const probeOptions : ProbeOptions = { ... } failureThreshold Optional \u00b6 public readonly failureThreshold : number ; Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public readonly initialDelaySeconds : Duration ; Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public readonly periodSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public readonly successThreshold : number ; Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public readonly timeoutSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ResourceProps \u00b6 Initialization properties for resources. Initializer \u00b6 import { ResourceProps } from 'cdk8s-plus-17' const resourceProps : ResourceProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. SecretProps \u00b6 Initializer \u00b6 import { SecretProps } from 'cdk8s-plus-17' const secretProps : SecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. stringData Optional \u00b6 public readonly stringData : {[ key : string ] : string }; Type: {[ key: string ]: string } stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 public readonly type : string ; Type: string Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. SecretValue \u00b6 Represents a specific value in JSON secret. Initializer \u00b6 import { SecretValue } from 'cdk8s-plus-17' const secretValue : SecretValue = { ... } key Required \u00b6 public readonly key : string ; Type: string The JSON key. secret Required \u00b6 public readonly secret : ISecret ; Type: cdk8s-plus-17.ISecret The secret. ServiceAccountProps \u00b6 Properties for initialization of ServiceAccount . Properties for initialization of ServiceAccount . Initializer \u00b6 import { ServiceAccountProps } from 'cdk8s-plus-17' const serviceAccountProps : ServiceAccountProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. secrets Optional \u00b6 public readonly secrets : ISecret []; Type: cdk8s-plus-17.ISecret [] List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret ServiceIngressV1BetaBackendOptions \u00b6 Options for setting up backends for ingress rules. Initializer \u00b6 import { ServiceIngressV1BetaBackendOptions } from 'cdk8s-plus-17' const serviceIngressV1BetaBackendOptions : ServiceIngressV1BetaBackendOptions = { ... } port Optional \u00b6 public readonly port : number ; Type: number Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. - If the service exposes multiple ports, this option must be specified. - If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. ServicePort \u00b6 Definition of a service port. Initializer \u00b6 import { ServicePort } from 'cdk8s-plus-17' const servicePort : ServicePort = { ... } name Optional \u00b6 public readonly name : string ; Type: string The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public readonly nodePort : number ; Type: number Default: to auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-17.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The value of port will be used. The port number the service will redirect to. port Required \u00b6 public readonly port : number ; Type: number The port number the service will bind to. ServicePortOptions \u00b6 Initializer \u00b6 import { ServicePortOptions } from 'cdk8s-plus-17' const servicePortOptions : ServicePortOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public readonly nodePort : number ; Type: number Default: to auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-17.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The value of port will be used. The port number the service will redirect to. ServiceProps \u00b6 Properties for initialization of Service . Initializer \u00b6 import { ServiceProps } from 'cdk8s-plus-17' const serviceProps : ServiceProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. clusterIP Optional \u00b6 public readonly clusterIP : string ; Type: string Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies externalIPs Optional \u00b6 public readonly externalIPs : string []; Type: string [] Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. externalName Optional \u00b6 public readonly externalName : string ; Type: string Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. loadBalancerSourceRanges Optional \u00b6 public readonly loadBalancerSourceRanges : string []; Type: string [] A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 public readonly ports : ServicePort []; Type: cdk8s-plus-17.ServicePort [] The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 public readonly type : ServiceType ; Type: cdk8s-plus-17.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types StatefulSetProps \u00b6 Properties for initialization of StatefulSet . Initializer \u00b6 import { StatefulSetProps } from 'cdk8s-plus-17' const statefulSetProps : StatefulSetProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-17.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-17.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-17.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-17.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata. service Required \u00b6 public readonly service : Service ; Type: cdk8s-plus-17.Service Service to associate with the statefulset. defaultSelector Optional \u00b6 public readonly defaultSelector : boolean ; Type: boolean Default: true Automatically allocates a pod selector for this statefulset. If this is set to false you must define your selector through statefulset.podMetadata.addLabel() and statefulset.selectByLabel() . podManagementPolicy Optional \u00b6 public readonly podManagementPolicy : PodManagementPolicy ; Type: cdk8s-plus-17.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 public readonly replicas : number ; Type: number Default: 1 Number of desired pods. VolumeMount \u00b6 Mount a volume from the pod to the container. Initializer \u00b6 import { VolumeMount } from 'cdk8s-plus-17' const volumeMount : VolumeMount = { ... } propagation Optional \u00b6 public readonly propagation : MountPropagation ; Type: cdk8s-plus-17.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. This field is beta in 1.10. readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public readonly subPath : string ; Type: string Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public readonly subPathExpr : string ; Type: string Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). SubPathExpr and SubPath are mutually exclusive. This field is beta in 1.15. subPathExpr and subPath are mutually exclusive. This field is beta in 1.15. path Required \u00b6 public readonly path : string ; Type: string Path within the container at which the volume should be mounted. Must not contain \u2018:\u2019. volume Required \u00b6 public readonly volume : Volume ; Type: cdk8s-plus-17.Volume The volume to mount. Classes \u00b6 Container \u00b6 A single application container that you want to run within a pod. Initializers \u00b6 import { Container } from 'cdk8s-plus-17' new Container ( props : ContainerProps ) props Required \u00b6 Type: cdk8s-plus-17.ContainerProps Methods \u00b6 addEnv \u00b6 public addEnv ( name : string , value : EnvValue ) name Required \u00b6 Type: string The variable name. value Required \u00b6 Type: cdk8s-plus-17.EnvValue The variable value. mount \u00b6 public mount ( path : string , volume : Volume , options? : MountOptions ) path Required \u00b6 Type: string The desired path in the container. volume Required \u00b6 Type: cdk8s-plus-17.Volume The volume to mount. options Optional \u00b6 Type: cdk8s-plus-17.MountOptions Properties \u00b6 env Required \u00b6 public readonly env : {[ key : string ] : EnvValue }; Type: {[ key: string ]: cdk8s-plus-17.EnvValue } The environment variables for this container. Returns a copy. To add environment variables use addEnv() . image Required \u00b6 public readonly image : string ; Type: string The container image. imagePullPolicy Required \u00b6 public readonly imagePullPolicy : ImagePullPolicy ; Type: cdk8s-plus-17.ImagePullPolicy Image pull policy for this container. mounts Required \u00b6 public readonly mounts : VolumeMount []; Type: cdk8s-plus-17.VolumeMount [] Volume mounts configured for this container. name Required \u00b6 public readonly name : string ; Type: string The name of the container. args Optional \u00b6 public readonly args : string []; Type: string [] Arguments to the entrypoint. command Optional \u00b6 public readonly command : string []; Type: string [] Entrypoint array (the command to execute when the container starts). port Optional \u00b6 public readonly port : number ; Type: number The port this container exposes. workingDir Optional \u00b6 public readonly workingDir : string ; Type: string The working directory inside the container. EnvValue \u00b6 Utility class for creating reading env values from various sources. Static Functions \u00b6 fromConfigMap \u00b6 import { EnvValue } from 'cdk8s-plus-17' EnvValue . fromConfigMap ( configMap : IConfigMap , key : string , options? : EnvValueFromConfigMapOptions ) configMap Required \u00b6 Type: cdk8s-plus-17.IConfigMap The config map. key Required \u00b6 Type: string The key to extract the value from. options Optional \u00b6 Type: cdk8s-plus-17.EnvValueFromConfigMapOptions Additional options. fromProcess \u00b6 import { EnvValue } from 'cdk8s-plus-17' EnvValue . fromProcess ( key : string , options? : EnvValueFromProcessOptions ) key Required \u00b6 Type: string The key to read. options Optional \u00b6 Type: cdk8s-plus-17.EnvValueFromProcessOptions Additional options. fromSecretValue \u00b6 import { EnvValue } from 'cdk8s-plus-17' EnvValue . fromSecretValue ( secretValue : SecretValue , options? : EnvValueFromSecretOptions ) secretValue Required \u00b6 Type: cdk8s-plus-17.SecretValue The secret value (secrent + key). options Optional \u00b6 Type: cdk8s-plus-17.EnvValueFromSecretOptions Additional options. fromValue \u00b6 import { EnvValue } from 'cdk8s-plus-17' EnvValue . fromValue ( value : string ) value Required \u00b6 Type: string The value. Properties \u00b6 value Optional \u00b6 public readonly value : any ; Type: any valueFrom Optional \u00b6 public readonly valueFrom : any ; Type: any IngressV1Beta1Backend \u00b6 The backend for an ingress path. Static Functions \u00b6 fromService \u00b6 import { IngressV1Beta1Backend } from 'cdk8s-plus-17' IngressV1Beta1Backend . fromService ( service : Service , options? : ServiceIngressV1BetaBackendOptions ) service Required \u00b6 Type: cdk8s-plus-17.Service The service object. options Optional \u00b6 Type: cdk8s-plus-17.ServiceIngressV1BetaBackendOptions PodSpec \u00b6 Implements: cdk8s-plus-17.IPodSpec Provides read/write capabilities ontop of a PodSpecProps . Initializers \u00b6 import { PodSpec } from 'cdk8s-plus-17' new PodSpec ( props? : PodSpecProps ) props Optional \u00b6 Type: cdk8s-plus-17.PodSpecProps Methods \u00b6 addContainer \u00b6 public addContainer ( container : ContainerProps ) container Required \u00b6 Type: cdk8s-plus-17.ContainerProps addVolume \u00b6 public addVolume ( volume : Volume ) volume Required \u00b6 Type: cdk8s-plus-17.Volume Properties \u00b6 containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-17.Container [] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-17.Volume [] The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-17.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-17.IServiceAccount The service account used to run this pod. PodTemplate \u00b6 Implements: cdk8s-plus-17.IPodTemplate Provides read/write capabilities ontop of a PodTemplateProps . Initializers \u00b6 import { PodTemplate } from 'cdk8s-plus-17' new PodTemplate ( props? : PodTemplateProps ) props Optional \u00b6 Type: cdk8s-plus-17.PodTemplateProps Properties \u00b6 podMetadata Required \u00b6 public readonly podMetadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. Probe \u00b6 Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic. Initializers \u00b6 import { Probe } from 'cdk8s-plus-17' new Probe () Static Functions \u00b6 fromCommand \u00b6 import { Probe } from 'cdk8s-plus-17' Probe . fromCommand ( command : string [], options? : CommandProbeOptions ) command Required \u00b6 Type: string [] The command to execute. options Optional \u00b6 Type: cdk8s-plus-17.CommandProbeOptions Options. fromHttpGet \u00b6 import { Probe } from 'cdk8s-plus-17' Probe . fromHttpGet ( path : string , options? : HttpGetProbeOptions ) path Required \u00b6 Type: string The URL path to hit. options Optional \u00b6 Type: cdk8s-plus-17.HttpGetProbeOptions Options. Volume \u00b6 Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes Initializers \u00b6 import { Volume } from 'cdk8s-plus-17' new Volume ( name : string , config : any ) name Required \u00b6 Type: string config Required \u00b6 Type: any Static Functions \u00b6 fromConfigMap \u00b6 import { Volume } from 'cdk8s-plus-17' Volume . fromConfigMap ( configMap : IConfigMap , options? : ConfigMapVolumeOptions ) configMap Required \u00b6 Type: cdk8s-plus-17.IConfigMap The config map to use to populate the volume. options Optional \u00b6 Type: cdk8s-plus-17.ConfigMapVolumeOptions Options. fromEmptyDir \u00b6 import { Volume } from 'cdk8s-plus-17' Volume . fromEmptyDir ( name : string , options? : EmptyDirVolumeOptions ) name Required \u00b6 Type: string options Optional \u00b6 Type: cdk8s-plus-17.EmptyDirVolumeOptions Additional options. Properties \u00b6 name Required \u00b6 public readonly name : string ; Type: string Protocols \u00b6 IConfigMap \u00b6 Extends: cdk8s-plus-17.IResource Implemented By: cdk8s-plus-17.ConfigMap , cdk8s-plus-17.IConfigMap Represents a config map. Properties \u00b6 name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IPodSpec \u00b6 Implemented By: cdk8s-plus-17.Deployment , cdk8s-plus-17.Job , cdk8s-plus-17.Pod , cdk8s-plus-17.PodSpec , cdk8s-plus-17.PodTemplate , cdk8s-plus-17.StatefulSet , cdk8s-plus-17.IPodSpec , cdk8s-plus-17.IPodTemplate Represents a resource that can be configured with a kuberenets pod spec. (e.g Deployment , Job , Pod , \u2026). Use the PodSpec class as an implementation helper. Methods \u00b6 addContainer \u00b6 public addContainer ( container : ContainerProps ) container Required \u00b6 Type: cdk8s-plus-17.ContainerProps The container. addVolume \u00b6 public addVolume ( volume : Volume ) volume Required \u00b6 Type: cdk8s-plus-17.Volume The volume. Properties \u00b6 containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-17.Container [] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-17.Volume [] The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-17.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-17.IServiceAccount The service account used to run this pod. IPodTemplate \u00b6 Extends: cdk8s-plus-17.IPodSpec Implemented By: cdk8s-plus-17.Deployment , cdk8s-plus-17.Job , cdk8s-plus-17.PodTemplate , cdk8s-plus-17.StatefulSet , cdk8s-plus-17.IPodTemplate Represents a resource that can be configured with a kuberenets pod template. (e.g Deployment , Job , \u2026). Use the PodTemplate class as an implementation helper. Properties \u00b6 containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-17.Container [] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-17.Volume [] The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-17.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-17.IServiceAccount The service account used to run this pod. podMetadata Required \u00b6 public readonly podMetadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. IResource \u00b6 Implemented By: cdk8s-plus-17.ConfigMap , cdk8s-plus-17.Deployment , cdk8s-plus-17.IngressV1Beta1 , cdk8s-plus-17.Job , cdk8s-plus-17.Pod , cdk8s-plus-17.Resource , cdk8s-plus-17.Secret , cdk8s-plus-17.Service , cdk8s-plus-17.ServiceAccount , cdk8s-plus-17.StatefulSet , cdk8s-plus-17.IConfigMap , cdk8s-plus-17.IResource , cdk8s-plus-17.ISecret , cdk8s-plus-17.IServiceAccount Represents a resource. Properties \u00b6 name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. ISecret \u00b6 Extends: cdk8s-plus-17.IResource Implemented By: cdk8s-plus-17.Secret , cdk8s-plus-17.ISecret Properties \u00b6 name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IServiceAccount \u00b6 Extends: cdk8s-plus-17.IResource Implemented By: cdk8s-plus-17.ServiceAccount , cdk8s-plus-17.IServiceAccount Properties \u00b6 name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. Enums \u00b6 EmptyDirMedium \u00b6 The medium on which to store the volume. DEFAULT \u00b6 The default volume of the backing node. MEMORY \u00b6 Mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. ImagePullPolicy \u00b6 ALWAYS \u00b6 Every time the kubelet launches a container, the kubelet queries the container image registry to resolve the name to an image digest. If the kubelet has a container image with that exact digest cached locally, the kubelet uses its cached image; otherwise, the kubelet downloads (pulls) the image with the resolved digest, and uses that image to launch the container. Default is Always if ImagePullPolicy is omitted and either the image tag is :latest or the image tag is omitted. IF_NOT_PRESENT \u00b6 The image is pulled only if it is not already present locally. Default is IfNotPresent if ImagePullPolicy is omitted and the image tag is present but not :latest NEVER \u00b6 The image is assumed to exist locally. No attempt is made to pull the image. MountPropagation \u00b6 NONE \u00b6 This volume mount will not receive any subsequent mounts that are mounted to this volume or any of its subdirectories by the host. In similar fashion, no mounts created by the Container will be visible on the host. This is the default mode. This mode is equal to private mount propagation as described in the Linux kernel documentation HOST_TO_CONTAINER \u00b6 This volume mount will receive all subsequent mounts that are mounted to this volume or any of its subdirectories. In other words, if the host mounts anything inside the volume mount, the Container will see it mounted there. Similarly, if any Pod with Bidirectional mount propagation to the same volume mounts anything there, the Container with HostToContainer mount propagation will see it. This mode is equal to rslave mount propagation as described in the Linux kernel documentation BIDIRECTIONAL \u00b6 This volume mount behaves the same the HostToContainer mount. In addition, all volume mounts created by the Container will be propagated back to the host and to all Containers of all Pods that use the same volume A typical use case for this mode is a Pod with a FlexVolume or CSI driver or a Pod that needs to mount something on the host using a hostPath volume. This mode is equal to rshared mount propagation as described in the Linux kernel documentation Caution: Bidirectional mount propagation can be dangerous. It can damage the host operating system and therefore it is allowed only in privileged Containers. Familiarity with Linux kernel behavior is strongly recommended. In addition, any volume mounts created by Containers in Pods must be destroyed (unmounted) by the Containers on termination. PodManagementPolicy \u00b6 Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once. ORDERED_READY \u00b6 PARALLEL \u00b6 Protocol \u00b6 TCP \u00b6 UDP \u00b6 SCTP \u00b6 RestartPolicy \u00b6 Restart policy for all containers within the pod. ALWAYS \u00b6 Always restart the pod after it exits. ON_FAILURE \u00b6 Only restart if the pod exits with a non-zero exit code. NEVER \u00b6 Never restart the pod. ServiceType \u00b6 For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP. CLUSTER_IP \u00b6 Exposes the Service on a cluster-internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default ServiceType NODE_PORT \u00b6 Exposes the Service on each Node\u2019s IP at a static port (the NodePort). A ClusterIP Service, to which the NodePort Service routes, is automatically created. You\u2019ll be able to contact the NodePort Service, from outside the cluster, by requesting : . LOAD_BALANCER \u00b6 Exposes the Service externally using a cloud provider\u2019s load balancer. NodePort and ClusterIP Services, to which the external load balancer routes, are automatically created. EXTERNAL_NAME \u00b6 Maps the Service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value. No proxying of any kind is set up. Note: You need either kube-dns version 1.7 or CoreDNS version 0.0.8 or higher to use the ExternalName type.","title":"TypeScript"},{"location":"reference/cdk8s-plus-17/typescript/#cdk8s-plus-17-typescript","text":"","title":"cdk8s-plus-17 (TypeScript) "},{"location":"reference/cdk8s-plus-17/typescript/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s-plus-17/typescript/#configmap","text":"Implements: cdk8s-plus-17.IConfigMap ConfigMap holds configuration data for pods to consume.","title":"ConfigMap "},{"location":"reference/cdk8s-plus-17/typescript/#deployment","text":"Implements: cdk8s-plus-17.IPodTemplate A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below.","title":"Deployment "},{"location":"reference/cdk8s-plus-17/typescript/#use-case","text":"The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore.","title":"Use Case"},{"location":"reference/cdk8s-plus-17/typescript/#ingressv1beta1","text":"Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.","title":"IngressV1Beta1 "},{"location":"reference/cdk8s-plus-17/typescript/#job","text":"Implements: cdk8s-plus-17.IPodTemplate A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel.","title":"Job "},{"location":"reference/cdk8s-plus-17/typescript/#pod","text":"Implements: cdk8s-plus-17.IPodSpec Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.","title":"Pod "},{"location":"reference/cdk8s-plus-17/typescript/#resource","text":"Implements: cdk8s-plus-17.IResource Base class for all Kubernetes objects in stdk8s. Represents a single resource.","title":"Resource "},{"location":"reference/cdk8s-plus-17/typescript/#secret","text":"Implements: cdk8s-plus-17.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret","title":"Secret "},{"location":"reference/cdk8s-plus-17/typescript/#service","text":"An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods.","title":"Service "},{"location":"reference/cdk8s-plus-17/typescript/#serviceaccount","text":"Implements: cdk8s-plus-17.IServiceAccount A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account","title":"ServiceAccount "},{"location":"reference/cdk8s-plus-17/typescript/#statefulset","text":"Implements: cdk8s-plus-17.IPodTemplate StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed.","title":"StatefulSet "},{"location":"reference/cdk8s-plus-17/typescript/#using-statefulsets","text":"StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates.","title":"Using StatefulSets"},{"location":"reference/cdk8s-plus-17/typescript/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s-plus-17/typescript/#adddirectoryoptions","text":"Options for configmap.addDirectory() .","title":"AddDirectoryOptions "},{"location":"reference/cdk8s-plus-17/typescript/#commandprobeoptions","text":"Options for Probe.fromCommand() .","title":"CommandProbeOptions "},{"location":"reference/cdk8s-plus-17/typescript/#configmapprops","text":"Properties for initialization of ConfigMap .","title":"ConfigMapProps "},{"location":"reference/cdk8s-plus-17/typescript/#configmapvolumeoptions","text":"Options for the ConfigMap-based volume.","title":"ConfigMapVolumeOptions "},{"location":"reference/cdk8s-plus-17/typescript/#containerprops","text":"Properties for creating a container.","title":"ContainerProps "},{"location":"reference/cdk8s-plus-17/typescript/#deploymentprops","text":"Properties for initialization of Deployment .","title":"DeploymentProps "},{"location":"reference/cdk8s-plus-17/typescript/#emptydirvolumeoptions","text":"Options for volumes populated with an empty directory.","title":"EmptyDirVolumeOptions "},{"location":"reference/cdk8s-plus-17/typescript/#envvaluefromconfigmapoptions","text":"Options to specify an envionment variable value from a ConfigMap key.","title":"EnvValueFromConfigMapOptions "},{"location":"reference/cdk8s-plus-17/typescript/#envvaluefromprocessoptions","text":"Options to specify an environment variable value from the process environment.","title":"EnvValueFromProcessOptions "},{"location":"reference/cdk8s-plus-17/typescript/#envvaluefromsecretoptions","text":"Options to specify an environment variable value from a Secret.","title":"EnvValueFromSecretOptions "},{"location":"reference/cdk8s-plus-17/typescript/#exposeoptions","text":"Options for exposing a deployment via a service.","title":"ExposeOptions "},{"location":"reference/cdk8s-plus-17/typescript/#httpgetprobeoptions","text":"Options for Probe.fromHttpGet() .","title":"HttpGetProbeOptions "},{"location":"reference/cdk8s-plus-17/typescript/#ingressv1beta1props","text":"Properties for Ingress .","title":"IngressV1Beta1Props "},{"location":"reference/cdk8s-plus-17/typescript/#ingressv1beta1rule","text":"Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path.","title":"IngressV1Beta1Rule "},{"location":"reference/cdk8s-plus-17/typescript/#ingressv1beta1tls","text":"Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination.","title":"IngressV1Beta1Tls "},{"location":"reference/cdk8s-plus-17/typescript/#jobprops","text":"Properties for initialization of Job .","title":"JobProps "},{"location":"reference/cdk8s-plus-17/typescript/#mountoptions","text":"Options for mounts.","title":"MountOptions "},{"location":"reference/cdk8s-plus-17/typescript/#pathmapping","text":"Maps a string key to a path within a volume.","title":"PathMapping "},{"location":"reference/cdk8s-plus-17/typescript/#podprops","text":"Properties for initialization of Pod .","title":"PodProps "},{"location":"reference/cdk8s-plus-17/typescript/#podspecprops","text":"Properties of a PodSpec .","title":"PodSpecProps "},{"location":"reference/cdk8s-plus-17/typescript/#podtemplateprops","text":"Properties of a PodTemplate . Adds metadata information on top of the spec.","title":"PodTemplateProps "},{"location":"reference/cdk8s-plus-17/typescript/#probeoptions","text":"Probe options.","title":"ProbeOptions "},{"location":"reference/cdk8s-plus-17/typescript/#resourceprops","text":"Initialization properties for resources.","title":"ResourceProps "},{"location":"reference/cdk8s-plus-17/typescript/#secretprops","text":"","title":"SecretProps "},{"location":"reference/cdk8s-plus-17/typescript/#secretvalue","text":"Represents a specific value in JSON secret.","title":"SecretValue "},{"location":"reference/cdk8s-plus-17/typescript/#serviceaccountprops","text":"Properties for initialization of ServiceAccount . Properties for initialization of ServiceAccount .","title":"ServiceAccountProps "},{"location":"reference/cdk8s-plus-17/typescript/#serviceingressv1betabackendoptions","text":"Options for setting up backends for ingress rules.","title":"ServiceIngressV1BetaBackendOptions "},{"location":"reference/cdk8s-plus-17/typescript/#serviceport","text":"Definition of a service port.","title":"ServicePort "},{"location":"reference/cdk8s-plus-17/typescript/#serviceportoptions","text":"","title":"ServicePortOptions "},{"location":"reference/cdk8s-plus-17/typescript/#serviceprops","text":"Properties for initialization of Service .","title":"ServiceProps "},{"location":"reference/cdk8s-plus-17/typescript/#statefulsetprops","text":"Properties for initialization of StatefulSet .","title":"StatefulSetProps "},{"location":"reference/cdk8s-plus-17/typescript/#volumemount","text":"Mount a volume from the pod to the container.","title":"VolumeMount "},{"location":"reference/cdk8s-plus-17/typescript/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s-plus-17/typescript/#container","text":"A single application container that you want to run within a pod.","title":"Container "},{"location":"reference/cdk8s-plus-17/typescript/#envvalue","text":"Utility class for creating reading env values from various sources.","title":"EnvValue "},{"location":"reference/cdk8s-plus-17/typescript/#ingressv1beta1backend","text":"The backend for an ingress path.","title":"IngressV1Beta1Backend "},{"location":"reference/cdk8s-plus-17/typescript/#podspec","text":"Implements: cdk8s-plus-17.IPodSpec Provides read/write capabilities ontop of a PodSpecProps .","title":"PodSpec "},{"location":"reference/cdk8s-plus-17/typescript/#podtemplate","text":"Implements: cdk8s-plus-17.IPodTemplate Provides read/write capabilities ontop of a PodTemplateProps .","title":"PodTemplate "},{"location":"reference/cdk8s-plus-17/typescript/#probe","text":"Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.","title":"Probe "},{"location":"reference/cdk8s-plus-17/typescript/#volume","text":"Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes","title":"Volume "},{"location":"reference/cdk8s-plus-17/typescript/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s-plus-17/typescript/#iconfigmap","text":"Extends: cdk8s-plus-17.IResource Implemented By: cdk8s-plus-17.ConfigMap , cdk8s-plus-17.IConfigMap Represents a config map.","title":"IConfigMap "},{"location":"reference/cdk8s-plus-17/typescript/#ipodspec","text":"Implemented By: cdk8s-plus-17.Deployment , cdk8s-plus-17.Job , cdk8s-plus-17.Pod , cdk8s-plus-17.PodSpec , cdk8s-plus-17.PodTemplate , cdk8s-plus-17.StatefulSet , cdk8s-plus-17.IPodSpec , cdk8s-plus-17.IPodTemplate Represents a resource that can be configured with a kuberenets pod spec. (e.g Deployment , Job , Pod , \u2026). Use the PodSpec class as an implementation helper.","title":"IPodSpec "},{"location":"reference/cdk8s-plus-17/typescript/#ipodtemplate","text":"Extends: cdk8s-plus-17.IPodSpec Implemented By: cdk8s-plus-17.Deployment , cdk8s-plus-17.Job , cdk8s-plus-17.PodTemplate , cdk8s-plus-17.StatefulSet , cdk8s-plus-17.IPodTemplate Represents a resource that can be configured with a kuberenets pod template. (e.g Deployment , Job , \u2026). Use the PodTemplate class as an implementation helper.","title":"IPodTemplate "},{"location":"reference/cdk8s-plus-17/typescript/#iresource","text":"Implemented By: cdk8s-plus-17.ConfigMap , cdk8s-plus-17.Deployment , cdk8s-plus-17.IngressV1Beta1 , cdk8s-plus-17.Job , cdk8s-plus-17.Pod , cdk8s-plus-17.Resource , cdk8s-plus-17.Secret , cdk8s-plus-17.Service , cdk8s-plus-17.ServiceAccount , cdk8s-plus-17.StatefulSet , cdk8s-plus-17.IConfigMap , cdk8s-plus-17.IResource , cdk8s-plus-17.ISecret , cdk8s-plus-17.IServiceAccount Represents a resource.","title":"IResource "},{"location":"reference/cdk8s-plus-17/typescript/#isecret","text":"Extends: cdk8s-plus-17.IResource Implemented By: cdk8s-plus-17.Secret , cdk8s-plus-17.ISecret","title":"ISecret "},{"location":"reference/cdk8s-plus-17/typescript/#iserviceaccount","text":"Extends: cdk8s-plus-17.IResource Implemented By: cdk8s-plus-17.ServiceAccount , cdk8s-plus-17.IServiceAccount","title":"IServiceAccount "},{"location":"reference/cdk8s-plus-17/typescript/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s-plus-17/typescript/#emptydirmedium","text":"The medium on which to store the volume.","title":"EmptyDirMedium "},{"location":"reference/cdk8s-plus-17/typescript/#imagepullpolicy","text":"","title":"ImagePullPolicy "},{"location":"reference/cdk8s-plus-17/typescript/#mountpropagation","text":"","title":"MountPropagation "},{"location":"reference/cdk8s-plus-17/typescript/#podmanagementpolicy","text":"Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.","title":"PodManagementPolicy "},{"location":"reference/cdk8s-plus-17/typescript/#protocol","text":"","title":"Protocol "},{"location":"reference/cdk8s-plus-17/typescript/#restartpolicy","text":"Restart policy for all containers within the pod.","title":"RestartPolicy "},{"location":"reference/cdk8s-plus-17/typescript/#servicetype","text":"For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP.","title":"ServiceType "},{"location":"reference/cdk8s-plus-20/go/","text":"cdk8s-plus-20 (Go) \u00b6 For Go API reference, please visit https://pkg.go.dev/github.com/cdk8s-team/cdk8s-plus-go/cdk8splus20 .","title":"Go"},{"location":"reference/cdk8s-plus-20/go/#cdk8s-plus-20-go","text":"For Go API reference, please visit https://pkg.go.dev/github.com/cdk8s-team/cdk8s-plus-go/cdk8splus20 .","title":"cdk8s-plus-20 (Go) "},{"location":"reference/cdk8s-plus-20/java/","text":"cdk8s-plus-20 (Java) \u00b6 Constructs \u00b6 ConfigMap \u00b6 Implements: org.cdk8s.plus20.IConfigMap ConfigMap holds configuration data for pods to consume. Initializers \u00b6 import org.cdk8s.plus20.ConfigMap ; ConfigMap . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .binaryData(java.util.Map<java.lang.String, java.lang.String>) // .data(java.util.Map<java.lang.String, java.lang.String>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binaryData Optional \u00b6 Type: java.util.Map java.lang.String > BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. Using this field will require 1.10+ apiserver and kubelet. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 Type: java.util.Map java.lang.String > Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . Methods \u00b6 addBinaryData \u00b6 public addBinaryData ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String The key. value Required \u00b6 Type: java.lang.String The value. addData \u00b6 public addData ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String The key. value Required \u00b6 Type: java.lang.String The value. addDirectory \u00b6 public addDirectory ( java . lang . String localDir ) public addDirectory ( java . lang . String localDir , AddDirectoryOptions options ) localDir Required \u00b6 Type: java.lang.String A path to a local directory. options Optional \u00b6 Type: org.cdk8s.plus20.AddDirectoryOptions Options. addFile \u00b6 public addFile ( java . lang . String localFile ) public addFile ( java . lang . String localFile , java . lang . String key ) localFile Required \u00b6 Type: java.lang.String The path to the local file. key Optional \u00b6 Type: java.lang.String The ConfigMap key (default to the file name). Static Functions \u00b6 fromConfigMapName \u00b6 import org.cdk8s.plus20.ConfigMap ; ConfigMap . fromConfigMapName ( java . lang . String name ) name Required \u00b6 Type: java.lang.String The name of the config map to import. Properties \u00b6 binaryData Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getBinaryData (); Type: java.util.Map java.lang.String > The binary data associated with this config map. Returns a copy. To add data records, use addBinaryData() or addData() . data Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getData (); Type: java.util.Map java.lang.String > The data associated with this config map. Returns an copy. To add data records, use addData() or addBinaryData() . Deployment \u00b6 Implements: org.cdk8s.plus20.IPodTemplate A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case \u00b6 The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore. Initializers \u00b6 import org.cdk8s.plus20.Deployment ; Deployment . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .defaultSelector(java.lang.Boolean) // .replicas(java.lang.Number) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 Type: org.cdk8s.plus20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 Type: org.cdk8s.plus20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata. defaultSelector Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod selector for this deployment. If this is set to false you must define your selector through deployment.podMetadata.addLabel() and deployment.selectByLabel() . replicas Optional \u00b6 Type: java.lang.Number Default: 1 Number of desired pods. Methods \u00b6 addContainer \u00b6 public addContainer ( ContainerProps container ) container Required \u00b6 Type: org.cdk8s.plus20.ContainerProps addVolume \u00b6 public addVolume ( Volume volume ) volume Required \u00b6 Type: org.cdk8s.plus20.Volume exposeViaIngress \u00b6 public exposeViaIngress ( java . lang . String path ) public exposeViaIngress ( java . lang . String path , ExposeDeploymentViaIngressOptions options ) path Required \u00b6 Type: java.lang.String The ingress path to register under. options Optional \u00b6 Type: org.cdk8s.plus20.ExposeDeploymentViaIngressOptions Additional options. exposeViaService \u00b6 public exposeViaService () public exposeViaService ( ExposeDeploymentViaServiceOptions options ) options Optional \u00b6 Type: org.cdk8s.plus20.ExposeDeploymentViaServiceOptions Options to determine details of the service and port exposed. selectByLabel \u00b6 public selectByLabel ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String The label key. value Required \u00b6 Type: java.lang.String The label value. Properties \u00b6 containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus20.Container > The containers belonging to the pod. Use addContainer to add containers. labelSelector Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getLabelSelector (); Type: java.util.Map java.lang.String > The labels this deployment will match against in order to select pods. Returns a a copy. Use selectByLabel() to add labels. podMetadata Required \u00b6 public ApiObjectMetadataDefinition getPodMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. replicas Required \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Number of desired pods. volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus20.Volume > The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus20.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus20.IServiceAccount The service account used to run this pod. IngressV1Beta1 \u00b6 Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. Initializers \u00b6 import org.cdk8s.plus20.IngressV1Beta1 ; IngressV1Beta1 . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .defaultBackend(IngressV1Beta1Backend) // .rules(java.util.List<IngressV1Beta1Rule>) // .tls(java.util.List<IngressV1Beta1Tls>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. defaultBackend Optional \u00b6 Type: org.cdk8s.plus20.IngressV1Beta1Backend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.IngressV1Beta1Rule > Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.IngressV1Beta1Tls > TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. Methods \u00b6 addDefaultBackend \u00b6 public addDefaultBackend ( IngressV1Beta1Backend backend ) backend Required \u00b6 Type: org.cdk8s.plus20.IngressV1Beta1Backend The backend to use for requests that do not match any rule. addHostDefaultBackend \u00b6 public addHostDefaultBackend ( java . lang . String host , IngressV1Beta1Backend backend ) host Required \u00b6 Type: java.lang.String The host name to match. backend Required \u00b6 Type: org.cdk8s.plus20.IngressV1Beta1Backend The backend to route to. addHostRule \u00b6 public addHostRule ( java . lang . String host , java . lang . String path , IngressV1Beta1Backend backend ) host Required \u00b6 Type: java.lang.String The host name. path Required \u00b6 Type: java.lang.String The HTTP path. backend Required \u00b6 Type: org.cdk8s.plus20.IngressV1Beta1Backend The backend to route requests to. addRule \u00b6 public addRule ( java . lang . String path , IngressV1Beta1Backend backend ) path Required \u00b6 Type: java.lang.String The HTTP path. backend Required \u00b6 Type: org.cdk8s.plus20.IngressV1Beta1Backend The backend to route requests to. addRules \u00b6 public addRules ( IngressV1Beta1Rule rules ) rules Required \u00b6 Type: org.cdk8s.plus20.IngressV1Beta1Rule The rules to add. addTls \u00b6 public addTls ( java . util . List < IngressV1Beta1Tls > tls ) tls Required \u00b6 Type: java.util.List< org.cdk8s.plus20.IngressV1Beta1Tls > Job \u00b6 Implements: org.cdk8s.plus20.IPodTemplate A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel. Initializers \u00b6 import org.cdk8s.plus20.Job ; Job . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .activeDeadline(Duration) // .backoffLimit(java.lang.Number) // .ttlAfterFinished(Duration) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 Type: org.cdk8s.plus20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 Type: org.cdk8s.plus20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata. activeDeadline Optional \u00b6 Type: org.cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 Type: java.lang.Number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 Type: org.cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. Methods \u00b6 addContainer \u00b6 public addContainer ( ContainerProps container ) container Required \u00b6 Type: org.cdk8s.plus20.ContainerProps addVolume \u00b6 public addVolume ( Volume volume ) volume Required \u00b6 Type: org.cdk8s.plus20.Volume Properties \u00b6 containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus20.Container > The containers belonging to the pod. Use addContainer to add containers. podMetadata Required \u00b6 public ApiObjectMetadataDefinition getPodMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus20.Volume > The volumes associated with this pod. Use addVolume to add volumes. activeDeadline Optional \u00b6 public Duration getActiveDeadline (); Type: org.cdk8s.Duration Duration before job is terminated. If undefined, there is no deadline. backoffLimit Optional \u00b6 public java . lang . Number getBackoffLimit (); Type: java.lang.Number Number of retries before marking failed. restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus20.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus20.IServiceAccount The service account used to run this pod. ttlAfterFinished Optional \u00b6 public Duration getTtlAfterFinished (); Type: org.cdk8s.Duration TTL before the job is deleted after it is finished. Pod \u00b6 Implements: org.cdk8s.plus20.IPodSpec Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts. Initializers \u00b6 import org.cdk8s.plus20.Pod ; Pod . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 Type: org.cdk8s.plus20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 Type: org.cdk8s.plus20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Methods \u00b6 addContainer \u00b6 public addContainer ( ContainerProps container ) container Required \u00b6 Type: org.cdk8s.plus20.ContainerProps addVolume \u00b6 public addVolume ( Volume volume ) volume Required \u00b6 Type: org.cdk8s.plus20.Volume Properties \u00b6 containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus20.Container > The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus20.Volume > The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus20.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus20.IServiceAccount The service account used to run this pod. Resource \u00b6 Implements: org.cdk8s.plus20.IResource Base class for all Kubernetes objects in stdk8s. Represents a single resource. Initializers \u00b6 import org.cdk8s.plus20.Resource ; Resource . Builder . create ( Construct scope , java . lang . String id ) // .nodeFactory(INodeFactory) . build (); scope Required \u00b6 Type: software.constructs.Construct The scope in which to define this construct. id Required \u00b6 Type: java.lang.String The scoped construct ID. Must be unique amongst siblings. If the ID includes a path separator ( / ), then it will be replaced by double dash -- . nodeFactory Optional \u00b6 Type: software.constructs.INodeFactory Default: the default Node is associated A factory for attaching Node s to the construct. Properties \u00b6 metadata Required \u00b6 public ApiObjectMetadataDefinition getMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this API object. Secret \u00b6 Implements: org.cdk8s.plus20.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret Initializers \u00b6 import org.cdk8s.plus20.Secret ; Secret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .stringData(java.util.Map<java.lang.String, java.lang.String>) // .type(java.lang.String) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. stringData Optional \u00b6 Type: java.util.Map java.lang.String > stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 Type: java.lang.String Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. Methods \u00b6 addStringData \u00b6 public addStringData ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String Key. value Required \u00b6 Type: java.lang.String Value. getStringData \u00b6 public getStringData ( java . lang . String key ) key Required \u00b6 Type: java.lang.String Key. Static Functions \u00b6 fromSecretName \u00b6 import org.cdk8s.plus20.Secret ; Secret . fromSecretName ( java . lang . String name ) name Required \u00b6 Type: java.lang.String The name of the secret to reference. Service \u00b6 An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods. Initializers \u00b6 import org.cdk8s.plus20.Service ; Service . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .clusterIP(java.lang.String) // .externalIPs(java.util.List<java.lang.String>) // .externalName(java.lang.String) // .loadBalancerSourceRanges(java.util.List<java.lang.String>) // .ports(java.util.List<ServicePort>) // .type(ServiceType) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. clusterIP Optional \u00b6 Type: java.lang.String Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies externalIPs Optional \u00b6 Type: java.util.List< java.lang.String > Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. externalName Optional \u00b6 Type: java.lang.String Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. loadBalancerSourceRanges Optional \u00b6 Type: java.util.List< java.lang.String > A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.ServicePort > The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 Type: org.cdk8s.plus20.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types Methods \u00b6 addDeployment \u00b6 public addDeployment ( Deployment deployment ) public addDeployment ( Deployment deployment , AddDeploymentOptions options ) deployment Required \u00b6 Type: org.cdk8s.plus20.Deployment The deployment to expose. options Optional \u00b6 Type: org.cdk8s.plus20.AddDeploymentOptions Optional settings for the port. addSelector \u00b6 public addSelector ( java . lang . String label , java . lang . String value ) label Required \u00b6 Type: java.lang.String The label key. value Required \u00b6 Type: java.lang.String The label value. exposeViaIngress \u00b6 public exposeViaIngress ( java . lang . String path ) public exposeViaIngress ( java . lang . String path , ExposeServiceViaIngressOptions options ) path Required \u00b6 Type: java.lang.String The path to expose the service under. options Optional \u00b6 Type: org.cdk8s.plus20.ExposeServiceViaIngressOptions Additional options. serve \u00b6 public serve ( java . lang . Number port ) public serve ( java . lang . Number port , ServicePortOptions options ) port Required \u00b6 Type: java.lang.Number The port definition. options Optional \u00b6 Type: org.cdk8s.plus20.ServicePortOptions Properties \u00b6 ports Required \u00b6 public java . util . List < ServicePort > getPorts (); Type: java.util.List< org.cdk8s.plus20.ServicePort > Ports for this service. Use serve() to expose additional service ports. selector Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getSelector (); Type: java.util.Map java.lang.String > Returns the labels which are used to select pods for this service. type Required \u00b6 public ServiceType getType (); Type: org.cdk8s.plus20.ServiceType Determines how the Service is exposed. clusterIP Optional \u00b6 public java . lang . String getClusterIP (); Type: java.lang.String The IP address of the service and is usually assigned randomly by the master. externalName Optional \u00b6 public java . lang . String getExternalName (); Type: java.lang.String The externalName to be used for EXTERNAL_NAME types. ServiceAccount \u00b6 Implements: org.cdk8s.plus20.IServiceAccount A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account Initializers \u00b6 import org.cdk8s.plus20.ServiceAccount ; ServiceAccount . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .secrets(java.util.List<ISecret>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. secrets Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.ISecret > List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret Methods \u00b6 addSecret \u00b6 public addSecret ( ISecret secret ) secret Required \u00b6 Type: org.cdk8s.plus20.ISecret The secret. Static Functions \u00b6 fromServiceAccountName \u00b6 import org.cdk8s.plus20.ServiceAccount ; ServiceAccount . fromServiceAccountName ( java . lang . String name ) name Required \u00b6 Type: java.lang.String The name of the service account resource. Properties \u00b6 secrets Required \u00b6 public java . util . List < ISecret > getSecrets (); Type: java.util.List< org.cdk8s.plus20.ISecret > List of secrets allowed to be used by pods running using this service account. Returns a copy. To add a secret, use addSecret() . StatefulSet \u00b6 Implements: org.cdk8s.plus20.IPodTemplate StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed. Using StatefulSets \u00b6 StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates. Initializers \u00b6 import org.cdk8s.plus20.StatefulSet ; StatefulSet . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) . service ( Service ) // .defaultSelector(java.lang.Boolean) // .podManagementPolicy(PodManagementPolicy) // .replicas(java.lang.Number) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 Type: org.cdk8s.plus20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 Type: org.cdk8s.plus20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata. service Required \u00b6 Type: org.cdk8s.plus20.Service Service to associate with the statefulset. defaultSelector Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod selector for this statefulset. If this is set to false you must define your selector through statefulset.podMetadata.addLabel() and statefulset.selectByLabel() . podManagementPolicy Optional \u00b6 Type: org.cdk8s.plus20.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 Type: java.lang.Number Default: 1 Number of desired pods. Methods \u00b6 addContainer \u00b6 public addContainer ( ContainerProps container ) container Required \u00b6 Type: org.cdk8s.plus20.ContainerProps addVolume \u00b6 public addVolume ( Volume volume ) volume Required \u00b6 Type: org.cdk8s.plus20.Volume selectByLabel \u00b6 public selectByLabel ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String The label key. value Required \u00b6 Type: java.lang.String The label value. Properties \u00b6 containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus20.Container > The containers belonging to the pod. Use addContainer to add containers. labelSelector Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getLabelSelector (); Type: java.util.Map java.lang.String > The labels this statefulset will match against in order to select pods. Returns a a copy. Use selectByLabel() to add labels. podManagementPolicy Required \u00b6 public PodManagementPolicy getPodManagementPolicy (); Type: org.cdk8s.plus20.PodManagementPolicy Management policy to use for the set. podMetadata Required \u00b6 public ApiObjectMetadataDefinition getPodMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. replicas Required \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Number of desired pods. volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus20.Volume > The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus20.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus20.IServiceAccount The service account used to run this pod. Structs \u00b6 AddDeploymentOptions \u00b6 Options to add a deployment to a service. Initializer \u00b6 import org.cdk8s.plus20.AddDeploymentOptions ; AddDeploymentOptions . builder () // .name(java.lang.String) // .nodePort(java.lang.Number) // .protocol(Protocol) // .targetPort(java.lang.Number) // .port(java.lang.Number) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public java . lang . Number getNodePort (); Type: java.lang.Number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus20.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The value of port will be used. The port number the service will redirect to. port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: Copied from the first container of the deployment. The port number the service will bind to. AddDirectoryOptions \u00b6 Options for configmap.addDirectory() . Initializer \u00b6 import org.cdk8s.plus20.AddDirectoryOptions ; AddDirectoryOptions . builder () // .exclude(java.util.List<java.lang.String>) // .keyPrefix(java.lang.String) . build (); exclude Optional \u00b6 public java . util . List < java . lang . String > getExclude (); Type: java.util.List< java.lang.String > Default: include all files Glob patterns to exclude when adding files. keyPrefix Optional \u00b6 public java . lang . String getKeyPrefix (); Type: java.lang.String Default: \u201c\u201d A prefix to add to all keys in the config map. CommandProbeOptions \u00b6 Options for Probe.fromCommand() . Initializer \u00b6 import org.cdk8s.plus20.CommandProbeOptions ; CommandProbeOptions . builder () // .failureThreshold(java.lang.Number) // .initialDelaySeconds(Duration) // .periodSeconds(Duration) // .successThreshold(java.lang.Number) // .timeoutSeconds(Duration) . build (); failureThreshold Optional \u00b6 public java . lang . Number getFailureThreshold (); Type: java.lang.Number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public Duration getInitialDelaySeconds (); Type: org.cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public Duration getPeriodSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public java . lang . Number getSuccessThreshold (); Type: java.lang.Number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public Duration getTimeoutSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ConfigMapProps \u00b6 Properties for initialization of ConfigMap . Initializer \u00b6 import org.cdk8s.plus20.ConfigMapProps ; ConfigMapProps . builder () // .metadata(ApiObjectMetadata) // .binaryData(java.util.Map<java.lang.String, java.lang.String>) // .data(java.util.Map<java.lang.String, java.lang.String>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binaryData Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getBinaryData (); Type: java.util.Map java.lang.String > BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. Using this field will require 1.10+ apiserver and kubelet. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getData (); Type: java.util.Map java.lang.String > Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . ConfigMapVolumeOptions \u00b6 Options for the ConfigMap-based volume. Initializer \u00b6 import org.cdk8s.plus20.ConfigMapVolumeOptions ; ConfigMapVolumeOptions . builder () // .defaultMode(java.lang.Number) // .items(java.util.Map<java.lang.String, PathMapping>) // .name(java.lang.String) // .optional(java.lang.Boolean) . build (); defaultMode Optional \u00b6 public java . lang . Number getDefaultMode (); Type: java.lang.Number Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 public java . util . Map < java . lang . String , PathMapping > getItems (); Type: java.util.Map \u0002klzzwxh:3315\u0003 > Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto-generated The volume name. optional Optional \u00b6 public java . lang . Boolean getOptional (); Type: java.lang.Boolean Default: undocumented Specify whether the ConfigMap or its keys must be defined. ContainerProps \u00b6 Properties for creating a container. Initializer \u00b6 import org.cdk8s.plus20.ContainerProps ; ContainerProps . builder () . image ( java . lang . String ) // .args(java.util.List<java.lang.String>) // .command(java.util.List<java.lang.String>) // .env(java.util.Map<java.lang.String, EnvValue>) // .imagePullPolicy(ImagePullPolicy) // .liveness(Probe) // .name(java.lang.String) // .port(java.lang.Number) // .readiness(Probe) // .startup(Probe) // .volumeMounts(java.util.List<VolumeMount>) // .workingDir(java.lang.String) . build (); image Required \u00b6 public java . lang . String getImage (); Type: java.lang.String Docker image name. args Optional \u00b6 public java . util . List < java . lang . String > getArgs (); Type: java.util.List< java.lang.String > Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 public java . util . List < java . lang . String > getCommand (); Type: java.util.List< java.lang.String > Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 public java . util . Map < java . lang . String , EnvValue > getEnv (); Type: java.util.Map \u0002klzzwxh:3296\u0003 > Default: No environment variables. List of environment variables to set in the container. Cannot be updated. imagePullPolicy Optional \u00b6 public ImagePullPolicy getImagePullPolicy (); Type: org.cdk8s.plus20.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 public Probe getLiveness (); Type: org.cdk8s.plus20.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 public Probe getReadiness (); Type: org.cdk8s.plus20.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 public Probe getStartup (); Type: org.cdk8s.plus20.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volumeMounts Optional \u00b6 public java . util . List < VolumeMount > getVolumeMounts (); Type: java.util.List< org.cdk8s.plus20.VolumeMount > Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. workingDir Optional \u00b6 public java . lang . String getWorkingDir (); Type: java.lang.String Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. DeploymentProps \u00b6 Properties for initialization of Deployment . Initializer \u00b6 import org.cdk8s.plus20.DeploymentProps ; DeploymentProps . builder () // .metadata(ApiObjectMetadata) // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .defaultSelector(java.lang.Boolean) // .replicas(java.lang.Number) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus20.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus20.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata. defaultSelector Optional \u00b6 public java . lang . Boolean getDefaultSelector (); Type: java.lang.Boolean Default: true Automatically allocates a pod selector for this deployment. If this is set to false you must define your selector through deployment.podMetadata.addLabel() and deployment.selectByLabel() . replicas Optional \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Default: 1 Number of desired pods. EmptyDirVolumeOptions \u00b6 Options for volumes populated with an empty directory. Initializer \u00b6 import org.cdk8s.plus20.EmptyDirVolumeOptions ; EmptyDirVolumeOptions . builder () // .medium(EmptyDirMedium) // .sizeLimit(Size) . build (); medium Optional \u00b6 public EmptyDirMedium getMedium (); Type: org.cdk8s.plus20.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. sizeLimit Optional \u00b6 public Size getSizeLimit (); Type: org.cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. EnvValueFromConfigMapOptions \u00b6 Options to specify an envionment variable value from a ConfigMap key. Initializer \u00b6 import org.cdk8s.plus20.EnvValueFromConfigMapOptions ; EnvValueFromConfigMapOptions . builder () // .optional(java.lang.Boolean) . build (); optional Optional \u00b6 public java . lang . Boolean getOptional (); Type: java.lang.Boolean Default: false Specify whether the ConfigMap or its key must be defined. EnvValueFromProcessOptions \u00b6 Options to specify an environment variable value from the process environment. Initializer \u00b6 import org.cdk8s.plus20.EnvValueFromProcessOptions ; EnvValueFromProcessOptions . builder () // .required(java.lang.Boolean) . build (); required Optional \u00b6 public java . lang . Boolean getRequired (); Type: java.lang.Boolean Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. EnvValueFromSecretOptions \u00b6 Options to specify an environment variable value from a Secret. Initializer \u00b6 import org.cdk8s.plus20.EnvValueFromSecretOptions ; EnvValueFromSecretOptions . builder () // .optional(java.lang.Boolean) . build (); optional Optional \u00b6 public java . lang . Boolean getOptional (); Type: java.lang.Boolean Default: false Specify whether the Secret or its key must be defined. ExposeDeploymentViaIngressOptions \u00b6 Options for exposing a deployment via an ingress. Initializer \u00b6 import org.cdk8s.plus20.ExposeDeploymentViaIngressOptions ; ExposeDeploymentViaIngressOptions . builder () // .name(java.lang.String) // .port(java.lang.Number) // .protocol(Protocol) // .serviceType(ServiceType) // .targetPort(java.lang.Number) // .ingress(IngressV1Beta1) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus20.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. serviceType Optional \u00b6 public ServiceType getServiceType (); Type: org.cdk8s.plus20.ServiceType Default: ClusterIP. The type of the exposed service. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ingress Optional \u00b6 public IngressV1Beta1 getIngress (); Type: org.cdk8s.plus20.IngressV1Beta1 Default: An ingress will be automatically created. The ingress to add rules to. ExposeDeploymentViaServiceOptions \u00b6 Options for exposing a deployment via a service. Initializer \u00b6 import org.cdk8s.plus20.ExposeDeploymentViaServiceOptions ; ExposeDeploymentViaServiceOptions . builder () // .name(java.lang.String) // .port(java.lang.Number) // .protocol(Protocol) // .serviceType(ServiceType) // .targetPort(java.lang.Number) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus20.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. serviceType Optional \u00b6 public ServiceType getServiceType (); Type: org.cdk8s.plus20.ServiceType Default: ClusterIP. The type of the exposed service. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ExposeServiceViaIngressOptions \u00b6 Options for exposing a service using an ingress. Initializer \u00b6 import org.cdk8s.plus20.ExposeServiceViaIngressOptions ; ExposeServiceViaIngressOptions . builder () // .ingress(IngressV1Beta1) . build (); ingress Optional \u00b6 public IngressV1Beta1 getIngress (); Type: org.cdk8s.plus20.IngressV1Beta1 Default: An ingress will be automatically created. The ingress to add rules to. HttpGetProbeOptions \u00b6 Options for Probe.fromHttpGet() . Initializer \u00b6 import org.cdk8s.plus20.HttpGetProbeOptions ; HttpGetProbeOptions . builder () // .failureThreshold(java.lang.Number) // .initialDelaySeconds(Duration) // .periodSeconds(Duration) // .successThreshold(java.lang.Number) // .timeoutSeconds(Duration) // .port(java.lang.Number) . build (); failureThreshold Optional \u00b6 public java . lang . Number getFailureThreshold (); Type: java.lang.Number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public Duration getInitialDelaySeconds (); Type: org.cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public Duration getPeriodSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public java . lang . Number getSuccessThreshold (); Type: java.lang.Number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public Duration getTimeoutSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: defaults to container.port . The TCP port to use when sending the GET request. IngressV1Beta1Props \u00b6 Properties for Ingress . Initializer \u00b6 import org.cdk8s.plus20.IngressV1Beta1Props ; IngressV1Beta1Props . builder () // .metadata(ApiObjectMetadata) // .defaultBackend(IngressV1Beta1Backend) // .rules(java.util.List<IngressV1Beta1Rule>) // .tls(java.util.List<IngressV1Beta1Tls>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. defaultBackend Optional \u00b6 public IngressV1Beta1Backend getDefaultBackend (); Type: org.cdk8s.plus20.IngressV1Beta1Backend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 public java . util . List < IngressV1Beta1Rule > getRules (); Type: java.util.List< org.cdk8s.plus20.IngressV1Beta1Rule > Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 public java . util . List < IngressV1Beta1Tls > getTls (); Type: java.util.List< org.cdk8s.plus20.IngressV1Beta1Tls > TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. IngressV1Beta1Rule \u00b6 Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path. Initializer \u00b6 import org.cdk8s.plus20.IngressV1Beta1Rule ; IngressV1Beta1Rule . builder () . backend ( IngressV1Beta1Backend ) // .host(java.lang.String) // .path(java.lang.String) . build (); backend Required \u00b6 public IngressV1Beta1Backend getBackend (); Type: org.cdk8s.plus20.IngressV1Beta1Backend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 public java . lang . String getHost (); Type: java.lang.String Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 public java . lang . String getPath (); Type: java.lang.String Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. IngressV1Beta1Tls \u00b6 Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination. Initializer \u00b6 import org.cdk8s.plus20.IngressV1Beta1Tls ; IngressV1Beta1Tls . builder () // .hosts(java.util.List<java.lang.String>) // .secret(ISecret) . build (); hosts Optional \u00b6 public java . util . List < java . lang . String > getHosts (); Type: java.util.List< java.lang.String > Default: If unspecified, it defaults to the wildcard host setting for the loadbalancer controller fulfilling this Ingress. Hosts are a list of hosts included in the TLS certificate. The values in this list must match the name/s used in the TLS Secret. secret Optional \u00b6 public ISecret getSecret (); Type: org.cdk8s.plus20.ISecret Default: If unspecified, it allows SSL routing based on SNI hostname. Secret is the secret that contains the certificate and key used to terminate SSL traffic on 443. If the SNI host in a listener conflicts with the \u201cHost\u201d header field used by an IngressRule, the SNI host is used for termination and value of the Host header is used for routing. JobProps \u00b6 Properties for initialization of Job . Initializer \u00b6 import org.cdk8s.plus20.JobProps ; JobProps . builder () // .metadata(ApiObjectMetadata) // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .activeDeadline(Duration) // .backoffLimit(java.lang.Number) // .ttlAfterFinished(Duration) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus20.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus20.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata. activeDeadline Optional \u00b6 public Duration getActiveDeadline (); Type: org.cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 public java . lang . Number getBackoffLimit (); Type: java.lang.Number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 public Duration getTtlAfterFinished (); Type: org.cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. MountOptions \u00b6 Options for mounts. Initializer \u00b6 import org.cdk8s.plus20.MountOptions ; MountOptions . builder () // .propagation(MountPropagation) // .readOnly(java.lang.Boolean) // .subPath(java.lang.String) // .subPathExpr(java.lang.String) . build (); propagation Optional \u00b6 public MountPropagation getPropagation (); Type: org.cdk8s.plus20.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. This field is beta in 1.10. readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public java . lang . String getSubPath (); Type: java.lang.String Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public java . lang . String getSubPathExpr (); Type: java.lang.String Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). SubPathExpr and SubPath are mutually exclusive. This field is beta in 1.15. subPathExpr and subPath are mutually exclusive. This field is beta in 1.15. PathMapping \u00b6 Maps a string key to a path within a volume. Initializer \u00b6 import org.cdk8s.plus20.PathMapping ; PathMapping . builder () . path ( java . lang . String ) // .mode(java.lang.Number) . build (); path Required \u00b6 public java . lang . String getPath (); Type: java.lang.String The relative path of the file to map the key to. May not be an absolute path. May not contain the path element \u2018..\u2019. May not start with the string \u2018..\u2019. mode Optional \u00b6 public java . lang . Number getMode (); Type: java.lang.Number Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. PodProps \u00b6 Properties for initialization of Pod . Initializer \u00b6 import org.cdk8s.plus20.PodProps ; PodProps . builder () // .metadata(ApiObjectMetadata) // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus20.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus20.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodSpecProps \u00b6 Properties of a PodSpec . Initializer \u00b6 import org.cdk8s.plus20.PodSpecProps ; PodSpecProps . builder () // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus20.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus20.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodTemplateProps \u00b6 Properties of a PodTemplate . Adds metadata information on top of the spec. Initializer \u00b6 import org.cdk8s.plus20.PodTemplateProps ; PodTemplateProps . builder () // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) . build (); containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus20.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus20.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata. ProbeOptions \u00b6 Probe options. Initializer \u00b6 import org.cdk8s.plus20.ProbeOptions ; ProbeOptions . builder () // .failureThreshold(java.lang.Number) // .initialDelaySeconds(Duration) // .periodSeconds(Duration) // .successThreshold(java.lang.Number) // .timeoutSeconds(Duration) . build (); failureThreshold Optional \u00b6 public java . lang . Number getFailureThreshold (); Type: java.lang.Number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public Duration getInitialDelaySeconds (); Type: org.cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public Duration getPeriodSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public java . lang . Number getSuccessThreshold (); Type: java.lang.Number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public Duration getTimeoutSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ResourceProps \u00b6 Initialization properties for resources. Initializer \u00b6 import org.cdk8s.plus20.ResourceProps ; ResourceProps . builder () // .metadata(ApiObjectMetadata) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. SecretProps \u00b6 Initializer \u00b6 import org.cdk8s.plus20.SecretProps ; SecretProps . builder () // .metadata(ApiObjectMetadata) // .stringData(java.util.Map<java.lang.String, java.lang.String>) // .type(java.lang.String) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. stringData Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getStringData (); Type: java.util.Map java.lang.String > stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 public java . lang . String getType (); Type: java.lang.String Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. SecretValue \u00b6 Represents a specific value in JSON secret. Initializer \u00b6 import org.cdk8s.plus20.SecretValue ; SecretValue . builder () . key ( java . lang . String ) . secret ( ISecret ) . build (); key Required \u00b6 public java . lang . String getKey (); Type: java.lang.String The JSON key. secret Required \u00b6 public ISecret getSecret (); Type: org.cdk8s.plus20.ISecret The secret. ServiceAccountProps \u00b6 Properties for initialization of ServiceAccount . Properties for initialization of ServiceAccount . Initializer \u00b6 import org.cdk8s.plus20.ServiceAccountProps ; ServiceAccountProps . builder () // .metadata(ApiObjectMetadata) // .secrets(java.util.List<ISecret>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. secrets Optional \u00b6 public java . util . List < ISecret > getSecrets (); Type: java.util.List< org.cdk8s.plus20.ISecret > List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret ServiceIngressV1BetaBackendOptions \u00b6 Options for setting up backends for ingress rules. Initializer \u00b6 import org.cdk8s.plus20.ServiceIngressV1BetaBackendOptions ; ServiceIngressV1BetaBackendOptions . builder () // .port(java.lang.Number) . build (); port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. If the service exposes multiple ports, this option must be specified. If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. ServicePort \u00b6 Definition of a service port. Initializer \u00b6 import org.cdk8s.plus20.ServicePort ; ServicePort . builder () // .name(java.lang.String) // .nodePort(java.lang.Number) // .protocol(Protocol) // .targetPort(java.lang.Number) . port ( java . lang . Number ) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public java . lang . Number getNodePort (); Type: java.lang.Number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus20.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The value of port will be used. The port number the service will redirect to. port Required \u00b6 public java . lang . Number getPort (); Type: java.lang.Number The port number the service will bind to. ServicePortOptions \u00b6 Initializer \u00b6 import org.cdk8s.plus20.ServicePortOptions ; ServicePortOptions . builder () // .name(java.lang.String) // .nodePort(java.lang.Number) // .protocol(Protocol) // .targetPort(java.lang.Number) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public java . lang . Number getNodePort (); Type: java.lang.Number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus20.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The value of port will be used. The port number the service will redirect to. ServiceProps \u00b6 Properties for initialization of Service . Initializer \u00b6 import org.cdk8s.plus20.ServiceProps ; ServiceProps . builder () // .metadata(ApiObjectMetadata) // .clusterIP(java.lang.String) // .externalIPs(java.util.List<java.lang.String>) // .externalName(java.lang.String) // .loadBalancerSourceRanges(java.util.List<java.lang.String>) // .ports(java.util.List<ServicePort>) // .type(ServiceType) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. clusterIP Optional \u00b6 public java . lang . String getClusterIP (); Type: java.lang.String Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies externalIPs Optional \u00b6 public java . util . List < java . lang . String > getExternalIPs (); Type: java.util.List< java.lang.String > Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. externalName Optional \u00b6 public java . lang . String getExternalName (); Type: java.lang.String Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. loadBalancerSourceRanges Optional \u00b6 public java . util . List < java . lang . String > getLoadBalancerSourceRanges (); Type: java.util.List< java.lang.String > A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 public java . util . List < ServicePort > getPorts (); Type: java.util.List< org.cdk8s.plus20.ServicePort > The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 public ServiceType getType (); Type: org.cdk8s.plus20.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types StatefulSetProps \u00b6 Properties for initialization of StatefulSet . Initializer \u00b6 import org.cdk8s.plus20.StatefulSetProps ; StatefulSetProps . builder () // .metadata(ApiObjectMetadata) // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) . service ( Service ) // .defaultSelector(java.lang.Boolean) // .podManagementPolicy(PodManagementPolicy) // .replicas(java.lang.Number) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus20.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus20.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata. service Required \u00b6 public Service getService (); Type: org.cdk8s.plus20.Service Service to associate with the statefulset. defaultSelector Optional \u00b6 public java . lang . Boolean getDefaultSelector (); Type: java.lang.Boolean Default: true Automatically allocates a pod selector for this statefulset. If this is set to false you must define your selector through statefulset.podMetadata.addLabel() and statefulset.selectByLabel() . podManagementPolicy Optional \u00b6 public PodManagementPolicy getPodManagementPolicy (); Type: org.cdk8s.plus20.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Default: 1 Number of desired pods. VolumeMount \u00b6 Mount a volume from the pod to the container. Initializer \u00b6 import org.cdk8s.plus20.VolumeMount ; VolumeMount . builder () // .propagation(MountPropagation) // .readOnly(java.lang.Boolean) // .subPath(java.lang.String) // .subPathExpr(java.lang.String) . path ( java . lang . String ) . volume ( Volume ) . build (); propagation Optional \u00b6 public MountPropagation getPropagation (); Type: org.cdk8s.plus20.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. This field is beta in 1.10. readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public java . lang . String getSubPath (); Type: java.lang.String Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public java . lang . String getSubPathExpr (); Type: java.lang.String Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). SubPathExpr and SubPath are mutually exclusive. This field is beta in 1.15. subPathExpr and subPath are mutually exclusive. This field is beta in 1.15. path Required \u00b6 public java . lang . String getPath (); Type: java.lang.String Path within the container at which the volume should be mounted. Must not contain \u2018:\u2019. volume Required \u00b6 public Volume getVolume (); Type: org.cdk8s.plus20.Volume The volume to mount. Classes \u00b6 Container \u00b6 A single application container that you want to run within a pod. Initializers \u00b6 import org.cdk8s.plus20.Container ; Container . Builder . create () . image ( java . lang . String ) // .args(java.util.List<java.lang.String>) // .command(java.util.List<java.lang.String>) // .env(java.util.Map<java.lang.String, EnvValue>) // .imagePullPolicy(ImagePullPolicy) // .liveness(Probe) // .name(java.lang.String) // .port(java.lang.Number) // .readiness(Probe) // .startup(Probe) // .volumeMounts(java.util.List<VolumeMount>) // .workingDir(java.lang.String) . build (); image Required \u00b6 Type: java.lang.String Docker image name. args Optional \u00b6 Type: java.util.List< java.lang.String > Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: java.util.List< java.lang.String > Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: java.util.Map \u0002klzzwxh:2868\u0003 > Default: No environment variables. List of environment variables to set in the container. Cannot be updated. imagePullPolicy Optional \u00b6 Type: org.cdk8s.plus20.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: org.cdk8s.plus20.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: java.lang.String Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: java.lang.Number Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: org.cdk8s.plus20.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: org.cdk8s.plus20.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volumeMounts Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.VolumeMount > Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. workingDir Optional \u00b6 Type: java.lang.String Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. Methods \u00b6 addEnv \u00b6 public addEnv ( java . lang . String name , EnvValue value ) name Required \u00b6 Type: java.lang.String The variable name. value Required \u00b6 Type: org.cdk8s.plus20.EnvValue The variable value. mount \u00b6 public mount ( java . lang . String path , Volume volume ) public mount ( java . lang . String path , Volume volume , MountOptions options ) path Required \u00b6 Type: java.lang.String The desired path in the container. volume Required \u00b6 Type: org.cdk8s.plus20.Volume The volume to mount. options Optional \u00b6 Type: org.cdk8s.plus20.MountOptions Properties \u00b6 env Required \u00b6 public java . util . Map < java . lang . String , EnvValue > getEnv (); Type: java.util.Map \u0002klzzwxh:2823\u0003 > The environment variables for this container. Returns a copy. To add environment variables use addEnv() . image Required \u00b6 public java . lang . String getImage (); Type: java.lang.String The container image. imagePullPolicy Required \u00b6 public ImagePullPolicy getImagePullPolicy (); Type: org.cdk8s.plus20.ImagePullPolicy Image pull policy for this container. mounts Required \u00b6 public java . util . List < VolumeMount > getMounts (); Type: java.util.List< org.cdk8s.plus20.VolumeMount > Volume mounts configured for this container. name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The name of the container. args Optional \u00b6 public java . util . List < java . lang . String > getArgs (); Type: java.util.List< java.lang.String > Arguments to the entrypoint. command Optional \u00b6 public java . util . List < java . lang . String > getCommand (); Type: java.util.List< java.lang.String > Entrypoint array (the command to execute when the container starts). port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number The port this container exposes. workingDir Optional \u00b6 public java . lang . String getWorkingDir (); Type: java.lang.String The working directory inside the container. EnvValue \u00b6 Utility class for creating reading env values from various sources. Static Functions \u00b6 fromConfigMap \u00b6 import org.cdk8s.plus20.EnvValue ; EnvValue . fromConfigMap ( IConfigMap configMap , java . lang . String key ) EnvValue . fromConfigMap ( IConfigMap configMap , java . lang . String key , EnvValueFromConfigMapOptions options ) configMap Required \u00b6 Type: org.cdk8s.plus20.IConfigMap The config map. key Required \u00b6 Type: java.lang.String The key to extract the value from. options Optional \u00b6 Type: org.cdk8s.plus20.EnvValueFromConfigMapOptions Additional options. fromProcess \u00b6 import org.cdk8s.plus20.EnvValue ; EnvValue . fromProcess ( java . lang . String key ) EnvValue . fromProcess ( java . lang . String key , EnvValueFromProcessOptions options ) key Required \u00b6 Type: java.lang.String The key to read. options Optional \u00b6 Type: org.cdk8s.plus20.EnvValueFromProcessOptions Additional options. fromSecretValue \u00b6 import org.cdk8s.plus20.EnvValue ; EnvValue . fromSecretValue ( SecretValue secretValue ) EnvValue . fromSecretValue ( SecretValue secretValue , EnvValueFromSecretOptions options ) secretValue Required \u00b6 Type: org.cdk8s.plus20.SecretValue The secret value (secrent + key). options Optional \u00b6 Type: org.cdk8s.plus20.EnvValueFromSecretOptions Additional options. fromValue \u00b6 import org.cdk8s.plus20.EnvValue ; EnvValue . fromValue ( java . lang . String value ) value Required \u00b6 Type: java.lang.String The value. Properties \u00b6 value Optional \u00b6 public java . lang . Object getValue (); Type: java.lang.Object valueFrom Optional \u00b6 public java . lang . Object getValueFrom (); Type: java.lang.Object IngressV1Beta1Backend \u00b6 The backend for an ingress path. Static Functions \u00b6 fromService \u00b6 import org.cdk8s.plus20.IngressV1Beta1Backend ; IngressV1Beta1Backend . fromService ( Service service ) IngressV1Beta1Backend . fromService ( Service service , ServiceIngressV1BetaBackendOptions options ) service Required \u00b6 Type: org.cdk8s.plus20.Service The service object. options Optional \u00b6 Type: org.cdk8s.plus20.ServiceIngressV1BetaBackendOptions PodSpec \u00b6 Implements: org.cdk8s.plus20.IPodSpec Provides read/write capabilities ontop of a PodSpecProps . Initializers \u00b6 import org.cdk8s.plus20.PodSpec ; PodSpec . Builder . create () // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 Type: org.cdk8s.plus20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 Type: org.cdk8s.plus20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Methods \u00b6 addContainer \u00b6 public addContainer ( ContainerProps container ) container Required \u00b6 Type: org.cdk8s.plus20.ContainerProps addVolume \u00b6 public addVolume ( Volume volume ) volume Required \u00b6 Type: org.cdk8s.plus20.Volume Properties \u00b6 containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus20.Container > The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus20.Volume > The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus20.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus20.IServiceAccount The service account used to run this pod. PodTemplate \u00b6 Implements: org.cdk8s.plus20.IPodTemplate Provides read/write capabilities ontop of a PodTemplateProps . Initializers \u00b6 import org.cdk8s.plus20.PodTemplate ; PodTemplate . Builder . create () // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) . build (); containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 Type: org.cdk8s.plus20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 Type: org.cdk8s.plus20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus20.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata. Properties \u00b6 podMetadata Required \u00b6 public ApiObjectMetadataDefinition getPodMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. Probe \u00b6 Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic. Initializers \u00b6 import org.cdk8s.plus20.Probe ; new Probe (); Static Functions \u00b6 fromCommand \u00b6 import org.cdk8s.plus20.Probe ; Probe . fromCommand ( java . util . List < java . lang . String > command ) Probe . fromCommand ( java . util . List < java . lang . String > command , CommandProbeOptions options ) command Required \u00b6 Type: java.util.List< java.lang.String > The command to execute. options Optional \u00b6 Type: org.cdk8s.plus20.CommandProbeOptions Options. fromHttpGet \u00b6 import org.cdk8s.plus20.Probe ; Probe . fromHttpGet ( java . lang . String path ) Probe . fromHttpGet ( java . lang . String path , HttpGetProbeOptions options ) path Required \u00b6 Type: java.lang.String The URL path to hit. options Optional \u00b6 Type: org.cdk8s.plus20.HttpGetProbeOptions Options. Volume \u00b6 Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes Initializers \u00b6 import org.cdk8s.plus20.Volume ; new Volume ( java . lang . String name , java . lang . Object config ); name Required \u00b6 Type: java.lang.String config Required \u00b6 Type: java.lang.Object Static Functions \u00b6 fromConfigMap \u00b6 import org.cdk8s.plus20.Volume ; Volume . fromConfigMap ( IConfigMap configMap ) Volume . fromConfigMap ( IConfigMap configMap , ConfigMapVolumeOptions options ) configMap Required \u00b6 Type: org.cdk8s.plus20.IConfigMap The config map to use to populate the volume. options Optional \u00b6 Type: org.cdk8s.plus20.ConfigMapVolumeOptions Options. fromEmptyDir \u00b6 import org.cdk8s.plus20.Volume ; Volume . fromEmptyDir ( java . lang . String name ) Volume . fromEmptyDir ( java . lang . String name , EmptyDirVolumeOptions options ) name Required \u00b6 Type: java.lang.String options Optional \u00b6 Type: org.cdk8s.plus20.EmptyDirVolumeOptions Additional options. Properties \u00b6 name Required \u00b6 public java . lang . String getName (); Type: java.lang.String Protocols \u00b6 IConfigMap \u00b6 Extends: org.cdk8s.plus20.IResource Implemented By: org.cdk8s.plus20.ConfigMap , org.cdk8s.plus20.IConfigMap Represents a config map. Properties \u00b6 name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IPodSpec \u00b6 Implemented By: org.cdk8s.plus20.Deployment , org.cdk8s.plus20.Job , org.cdk8s.plus20.Pod , org.cdk8s.plus20.PodSpec , org.cdk8s.plus20.PodTemplate , org.cdk8s.plus20.StatefulSet , org.cdk8s.plus20.IPodSpec , org.cdk8s.plus20.IPodTemplate Represents a resource that can be configured with a kuberenets pod spec. (e.g Deployment , Job , Pod , \u2026). Use the PodSpec class as an implementation helper. Methods \u00b6 addContainer \u00b6 public addContainer ( ContainerProps container ) container Required \u00b6 Type: org.cdk8s.plus20.ContainerProps The container. addVolume \u00b6 public addVolume ( Volume volume ) volume Required \u00b6 Type: org.cdk8s.plus20.Volume The volume. Properties \u00b6 containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus20.Container > The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus20.Volume > The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus20.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus20.IServiceAccount The service account used to run this pod. IPodTemplate \u00b6 Extends: org.cdk8s.plus20.IPodSpec Implemented By: org.cdk8s.plus20.Deployment , org.cdk8s.plus20.Job , org.cdk8s.plus20.PodTemplate , org.cdk8s.plus20.StatefulSet , org.cdk8s.plus20.IPodTemplate Represents a resource that can be configured with a kuberenets pod template. (e.g Deployment , Job , \u2026). Use the PodTemplate class as an implementation helper. Properties \u00b6 containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus20.Container > The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus20.Volume > The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus20.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus20.IServiceAccount The service account used to run this pod. podMetadata Required \u00b6 public ApiObjectMetadataDefinition getPodMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. IResource \u00b6 Implemented By: org.cdk8s.plus20.ConfigMap , org.cdk8s.plus20.Deployment , org.cdk8s.plus20.IngressV1Beta1 , org.cdk8s.plus20.Job , org.cdk8s.plus20.Pod , org.cdk8s.plus20.Resource , org.cdk8s.plus20.Secret , org.cdk8s.plus20.Service , org.cdk8s.plus20.ServiceAccount , org.cdk8s.plus20.StatefulSet , org.cdk8s.plus20.IConfigMap , org.cdk8s.plus20.IResource , org.cdk8s.plus20.ISecret , org.cdk8s.plus20.IServiceAccount Represents a resource. Properties \u00b6 name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. ISecret \u00b6 Extends: org.cdk8s.plus20.IResource Implemented By: org.cdk8s.plus20.Secret , org.cdk8s.plus20.ISecret Properties \u00b6 name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IServiceAccount \u00b6 Extends: org.cdk8s.plus20.IResource Implemented By: org.cdk8s.plus20.ServiceAccount , org.cdk8s.plus20.IServiceAccount Properties \u00b6 name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. Enums \u00b6 EmptyDirMedium \u00b6 The medium on which to store the volume. DEFAULT \u00b6 The default volume of the backing node. MEMORY \u00b6 Mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. ImagePullPolicy \u00b6 ALWAYS \u00b6 Every time the kubelet launches a container, the kubelet queries the container image registry to resolve the name to an image digest. If the kubelet has a container image with that exact digest cached locally, the kubelet uses its cached image; otherwise, the kubelet downloads (pulls) the image with the resolved digest, and uses that image to launch the container. Default is Always if ImagePullPolicy is omitted and either the image tag is :latest or the image tag is omitted. IF_NOT_PRESENT \u00b6 The image is pulled only if it is not already present locally. Default is IfNotPresent if ImagePullPolicy is omitted and the image tag is present but not :latest NEVER \u00b6 The image is assumed to exist locally. No attempt is made to pull the image. MountPropagation \u00b6 NONE \u00b6 This volume mount will not receive any subsequent mounts that are mounted to this volume or any of its subdirectories by the host. In similar fashion, no mounts created by the Container will be visible on the host. This is the default mode. This mode is equal to private mount propagation as described in the Linux kernel documentation HOST_TO_CONTAINER \u00b6 This volume mount will receive all subsequent mounts that are mounted to this volume or any of its subdirectories. In other words, if the host mounts anything inside the volume mount, the Container will see it mounted there. Similarly, if any Pod with Bidirectional mount propagation to the same volume mounts anything there, the Container with HostToContainer mount propagation will see it. This mode is equal to rslave mount propagation as described in the Linux kernel documentation BIDIRECTIONAL \u00b6 This volume mount behaves the same the HostToContainer mount. In addition, all volume mounts created by the Container will be propagated back to the host and to all Containers of all Pods that use the same volume A typical use case for this mode is a Pod with a FlexVolume or CSI driver or a Pod that needs to mount something on the host using a hostPath volume. This mode is equal to rshared mount propagation as described in the Linux kernel documentation Caution: Bidirectional mount propagation can be dangerous. It can damage the host operating system and therefore it is allowed only in privileged Containers. Familiarity with Linux kernel behavior is strongly recommended. In addition, any volume mounts created by Containers in Pods must be destroyed (unmounted) by the Containers on termination. PodManagementPolicy \u00b6 Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once. ORDERED_READY \u00b6 PARALLEL \u00b6 Protocol \u00b6 TCP \u00b6 UDP \u00b6 SCTP \u00b6 RestartPolicy \u00b6 Restart policy for all containers within the pod. ALWAYS \u00b6 Always restart the pod after it exits. ON_FAILURE \u00b6 Only restart if the pod exits with a non-zero exit code. NEVER \u00b6 Never restart the pod. ServiceType \u00b6 For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP. CLUSTER_IP \u00b6 Exposes the Service on a cluster-internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default ServiceType NODE_PORT \u00b6 Exposes the Service on each Node\u2019s IP at a static port (the NodePort). A ClusterIP Service, to which the NodePort Service routes, is automatically created. You\u2019ll be able to contact the NodePort Service, from outside the cluster, by requesting : . LOAD_BALANCER \u00b6 Exposes the Service externally using a cloud provider\u2019s load balancer. NodePort and ClusterIP Services, to which the external load balancer routes, are automatically created. EXTERNAL_NAME \u00b6 Maps the Service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value. No proxying of any kind is set up. Note: You need either kube-dns version 1.7 or CoreDNS version 0.0.8 or higher to use the ExternalName type.","title":"Java"},{"location":"reference/cdk8s-plus-20/java/#cdk8s-plus-20-java","text":"","title":"cdk8s-plus-20 (Java) "},{"location":"reference/cdk8s-plus-20/java/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s-plus-20/java/#configmap","text":"Implements: org.cdk8s.plus20.IConfigMap ConfigMap holds configuration data for pods to consume.","title":"ConfigMap "},{"location":"reference/cdk8s-plus-20/java/#deployment","text":"Implements: org.cdk8s.plus20.IPodTemplate A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below.","title":"Deployment "},{"location":"reference/cdk8s-plus-20/java/#use-case","text":"The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore.","title":"Use Case"},{"location":"reference/cdk8s-plus-20/java/#ingressv1beta1","text":"Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.","title":"IngressV1Beta1 "},{"location":"reference/cdk8s-plus-20/java/#job","text":"Implements: org.cdk8s.plus20.IPodTemplate A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel.","title":"Job "},{"location":"reference/cdk8s-plus-20/java/#pod","text":"Implements: org.cdk8s.plus20.IPodSpec Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.","title":"Pod "},{"location":"reference/cdk8s-plus-20/java/#resource","text":"Implements: org.cdk8s.plus20.IResource Base class for all Kubernetes objects in stdk8s. Represents a single resource.","title":"Resource "},{"location":"reference/cdk8s-plus-20/java/#secret","text":"Implements: org.cdk8s.plus20.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret","title":"Secret "},{"location":"reference/cdk8s-plus-20/java/#service","text":"An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods.","title":"Service "},{"location":"reference/cdk8s-plus-20/java/#serviceaccount","text":"Implements: org.cdk8s.plus20.IServiceAccount A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account","title":"ServiceAccount "},{"location":"reference/cdk8s-plus-20/java/#statefulset","text":"Implements: org.cdk8s.plus20.IPodTemplate StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed.","title":"StatefulSet "},{"location":"reference/cdk8s-plus-20/java/#using-statefulsets","text":"StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates.","title":"Using StatefulSets"},{"location":"reference/cdk8s-plus-20/java/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s-plus-20/java/#adddeploymentoptions","text":"Options to add a deployment to a service.","title":"AddDeploymentOptions "},{"location":"reference/cdk8s-plus-20/java/#adddirectoryoptions","text":"Options for configmap.addDirectory() .","title":"AddDirectoryOptions "},{"location":"reference/cdk8s-plus-20/java/#commandprobeoptions","text":"Options for Probe.fromCommand() .","title":"CommandProbeOptions "},{"location":"reference/cdk8s-plus-20/java/#configmapprops","text":"Properties for initialization of ConfigMap .","title":"ConfigMapProps "},{"location":"reference/cdk8s-plus-20/java/#configmapvolumeoptions","text":"Options for the ConfigMap-based volume.","title":"ConfigMapVolumeOptions "},{"location":"reference/cdk8s-plus-20/java/#containerprops","text":"Properties for creating a container.","title":"ContainerProps "},{"location":"reference/cdk8s-plus-20/java/#deploymentprops","text":"Properties for initialization of Deployment .","title":"DeploymentProps "},{"location":"reference/cdk8s-plus-20/java/#emptydirvolumeoptions","text":"Options for volumes populated with an empty directory.","title":"EmptyDirVolumeOptions "},{"location":"reference/cdk8s-plus-20/java/#envvaluefromconfigmapoptions","text":"Options to specify an envionment variable value from a ConfigMap key.","title":"EnvValueFromConfigMapOptions "},{"location":"reference/cdk8s-plus-20/java/#envvaluefromprocessoptions","text":"Options to specify an environment variable value from the process environment.","title":"EnvValueFromProcessOptions "},{"location":"reference/cdk8s-plus-20/java/#envvaluefromsecretoptions","text":"Options to specify an environment variable value from a Secret.","title":"EnvValueFromSecretOptions "},{"location":"reference/cdk8s-plus-20/java/#exposedeploymentviaingressoptions","text":"Options for exposing a deployment via an ingress.","title":"ExposeDeploymentViaIngressOptions "},{"location":"reference/cdk8s-plus-20/java/#exposedeploymentviaserviceoptions","text":"Options for exposing a deployment via a service.","title":"ExposeDeploymentViaServiceOptions "},{"location":"reference/cdk8s-plus-20/java/#exposeserviceviaingressoptions","text":"Options for exposing a service using an ingress.","title":"ExposeServiceViaIngressOptions "},{"location":"reference/cdk8s-plus-20/java/#httpgetprobeoptions","text":"Options for Probe.fromHttpGet() .","title":"HttpGetProbeOptions "},{"location":"reference/cdk8s-plus-20/java/#ingressv1beta1props","text":"Properties for Ingress .","title":"IngressV1Beta1Props "},{"location":"reference/cdk8s-plus-20/java/#ingressv1beta1rule","text":"Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path.","title":"IngressV1Beta1Rule "},{"location":"reference/cdk8s-plus-20/java/#ingressv1beta1tls","text":"Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination.","title":"IngressV1Beta1Tls "},{"location":"reference/cdk8s-plus-20/java/#jobprops","text":"Properties for initialization of Job .","title":"JobProps "},{"location":"reference/cdk8s-plus-20/java/#mountoptions","text":"Options for mounts.","title":"MountOptions "},{"location":"reference/cdk8s-plus-20/java/#pathmapping","text":"Maps a string key to a path within a volume.","title":"PathMapping "},{"location":"reference/cdk8s-plus-20/java/#podprops","text":"Properties for initialization of Pod .","title":"PodProps "},{"location":"reference/cdk8s-plus-20/java/#podspecprops","text":"Properties of a PodSpec .","title":"PodSpecProps "},{"location":"reference/cdk8s-plus-20/java/#podtemplateprops","text":"Properties of a PodTemplate . Adds metadata information on top of the spec.","title":"PodTemplateProps "},{"location":"reference/cdk8s-plus-20/java/#probeoptions","text":"Probe options.","title":"ProbeOptions "},{"location":"reference/cdk8s-plus-20/java/#resourceprops","text":"Initialization properties for resources.","title":"ResourceProps "},{"location":"reference/cdk8s-plus-20/java/#secretprops","text":"","title":"SecretProps "},{"location":"reference/cdk8s-plus-20/java/#secretvalue","text":"Represents a specific value in JSON secret.","title":"SecretValue "},{"location":"reference/cdk8s-plus-20/java/#serviceaccountprops","text":"Properties for initialization of ServiceAccount . Properties for initialization of ServiceAccount .","title":"ServiceAccountProps "},{"location":"reference/cdk8s-plus-20/java/#serviceingressv1betabackendoptions","text":"Options for setting up backends for ingress rules.","title":"ServiceIngressV1BetaBackendOptions "},{"location":"reference/cdk8s-plus-20/java/#serviceport","text":"Definition of a service port.","title":"ServicePort "},{"location":"reference/cdk8s-plus-20/java/#serviceportoptions","text":"","title":"ServicePortOptions "},{"location":"reference/cdk8s-plus-20/java/#serviceprops","text":"Properties for initialization of Service .","title":"ServiceProps "},{"location":"reference/cdk8s-plus-20/java/#statefulsetprops","text":"Properties for initialization of StatefulSet .","title":"StatefulSetProps "},{"location":"reference/cdk8s-plus-20/java/#volumemount","text":"Mount a volume from the pod to the container.","title":"VolumeMount "},{"location":"reference/cdk8s-plus-20/java/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s-plus-20/java/#container","text":"A single application container that you want to run within a pod.","title":"Container "},{"location":"reference/cdk8s-plus-20/java/#envvalue","text":"Utility class for creating reading env values from various sources.","title":"EnvValue "},{"location":"reference/cdk8s-plus-20/java/#ingressv1beta1backend","text":"The backend for an ingress path.","title":"IngressV1Beta1Backend "},{"location":"reference/cdk8s-plus-20/java/#podspec","text":"Implements: org.cdk8s.plus20.IPodSpec Provides read/write capabilities ontop of a PodSpecProps .","title":"PodSpec "},{"location":"reference/cdk8s-plus-20/java/#podtemplate","text":"Implements: org.cdk8s.plus20.IPodTemplate Provides read/write capabilities ontop of a PodTemplateProps .","title":"PodTemplate "},{"location":"reference/cdk8s-plus-20/java/#probe","text":"Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.","title":"Probe "},{"location":"reference/cdk8s-plus-20/java/#volume","text":"Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes","title":"Volume "},{"location":"reference/cdk8s-plus-20/java/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s-plus-20/java/#iconfigmap","text":"Extends: org.cdk8s.plus20.IResource Implemented By: org.cdk8s.plus20.ConfigMap , org.cdk8s.plus20.IConfigMap Represents a config map.","title":"IConfigMap "},{"location":"reference/cdk8s-plus-20/java/#ipodspec","text":"Implemented By: org.cdk8s.plus20.Deployment , org.cdk8s.plus20.Job , org.cdk8s.plus20.Pod , org.cdk8s.plus20.PodSpec , org.cdk8s.plus20.PodTemplate , org.cdk8s.plus20.StatefulSet , org.cdk8s.plus20.IPodSpec , org.cdk8s.plus20.IPodTemplate Represents a resource that can be configured with a kuberenets pod spec. (e.g Deployment , Job , Pod , \u2026). Use the PodSpec class as an implementation helper.","title":"IPodSpec "},{"location":"reference/cdk8s-plus-20/java/#ipodtemplate","text":"Extends: org.cdk8s.plus20.IPodSpec Implemented By: org.cdk8s.plus20.Deployment , org.cdk8s.plus20.Job , org.cdk8s.plus20.PodTemplate , org.cdk8s.plus20.StatefulSet , org.cdk8s.plus20.IPodTemplate Represents a resource that can be configured with a kuberenets pod template. (e.g Deployment , Job , \u2026). Use the PodTemplate class as an implementation helper.","title":"IPodTemplate "},{"location":"reference/cdk8s-plus-20/java/#iresource","text":"Implemented By: org.cdk8s.plus20.ConfigMap , org.cdk8s.plus20.Deployment , org.cdk8s.plus20.IngressV1Beta1 , org.cdk8s.plus20.Job , org.cdk8s.plus20.Pod , org.cdk8s.plus20.Resource , org.cdk8s.plus20.Secret , org.cdk8s.plus20.Service , org.cdk8s.plus20.ServiceAccount , org.cdk8s.plus20.StatefulSet , org.cdk8s.plus20.IConfigMap , org.cdk8s.plus20.IResource , org.cdk8s.plus20.ISecret , org.cdk8s.plus20.IServiceAccount Represents a resource.","title":"IResource "},{"location":"reference/cdk8s-plus-20/java/#isecret","text":"Extends: org.cdk8s.plus20.IResource Implemented By: org.cdk8s.plus20.Secret , org.cdk8s.plus20.ISecret","title":"ISecret "},{"location":"reference/cdk8s-plus-20/java/#iserviceaccount","text":"Extends: org.cdk8s.plus20.IResource Implemented By: org.cdk8s.plus20.ServiceAccount , org.cdk8s.plus20.IServiceAccount","title":"IServiceAccount "},{"location":"reference/cdk8s-plus-20/java/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s-plus-20/java/#emptydirmedium","text":"The medium on which to store the volume.","title":"EmptyDirMedium "},{"location":"reference/cdk8s-plus-20/java/#imagepullpolicy","text":"","title":"ImagePullPolicy "},{"location":"reference/cdk8s-plus-20/java/#mountpropagation","text":"","title":"MountPropagation "},{"location":"reference/cdk8s-plus-20/java/#podmanagementpolicy","text":"Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.","title":"PodManagementPolicy "},{"location":"reference/cdk8s-plus-20/java/#protocol","text":"","title":"Protocol "},{"location":"reference/cdk8s-plus-20/java/#restartpolicy","text":"Restart policy for all containers within the pod.","title":"RestartPolicy "},{"location":"reference/cdk8s-plus-20/java/#servicetype","text":"For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP.","title":"ServiceType "},{"location":"reference/cdk8s-plus-20/python/","text":"cdk8s-plus-20 (Python) \u00b6 Constructs \u00b6 ConfigMap \u00b6 Implements: cdk8s_plus_20.IConfigMap ConfigMap holds configuration data for pods to consume. Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ConfigMap ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , binary_data : typing . Mapping [ str ] = None , data : typing . Mapping [ str ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binary_data Optional \u00b6 Type: typing.Mapping[ str ] BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. Using this field will require 1.10+ apiserver and kubelet. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 Type: typing.Mapping[ str ] Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . Methods \u00b6 add_binary_data \u00b6 def add_binary_data ( key : str , value : str ) key Required \u00b6 Type: str The key. value Required \u00b6 Type: str The value. add_data \u00b6 def add_data ( key : str , value : str ) key Required \u00b6 Type: str The key. value Required \u00b6 Type: str The value. add_directory \u00b6 def add_directory ( local_dir : str , exclude : typing . List [ str ] = None , key_prefix : str = None ) local_dir Required \u00b6 Type: str A path to a local directory. exclude Optional \u00b6 Type: typing.List[ str ] Default: include all files Glob patterns to exclude when adding files. key_prefix Optional \u00b6 Type: str Default: \u201c\u201d A prefix to add to all keys in the config map. add_file \u00b6 def add_file ( local_file : str , key : str = None ) local_file Required \u00b6 Type: str The path to the local file. key Optional \u00b6 Type: str The ConfigMap key (default to the file name). Static Functions \u00b6 from_config_map_name \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ConfigMap . from_config_map_name ( name : str ) name Required \u00b6 Type: str The name of the config map to import. Properties \u00b6 binary_data Required \u00b6 binary_data : typing . Mapping [ str ] Type: typing.Mapping[ str ] The binary data associated with this config map. Returns a copy. To add data records, use addBinaryData() or addData() . data Required \u00b6 data : typing . Mapping [ str ] Type: typing.Mapping[ str ] The data associated with this config map. Returns an copy. To add data records, use addData() or addBinaryData() . Deployment \u00b6 Implements: cdk8s_plus_20.IPodTemplate A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case \u00b6 The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore. Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Deployment ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , default_selector : bool = None , replicas : typing . Union [ int , float ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: typing.List[ cdk8s_plus_20.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_20.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata. default_selector Optional \u00b6 Type: bool Default: true Automatically allocates a pod selector for this deployment. If this is set to false you must define your selector through deployment.podMetadata.addLabel() and deployment.selectByLabel() . replicas Optional \u00b6 Type: typing.Union[int, float] Default: 1 Number of desired pods. Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_20.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_20.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_20.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_20.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_20.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_20.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( volume : Volume ) volume Required \u00b6 Type: cdk8s_plus_20.Volume expose_via_ingress \u00b6 def expose_via_ingress ( path : str , name : str = None , port : typing . Union [ int , float ] = None , protocol : Protocol = None , service_type : ServiceType = None , target_port : typing . Union [ int , float ] = None , ingress : IngressV1Beta1 = None ) path Required \u00b6 Type: str The ingress path to register under. name Optional \u00b6 Type: str Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 Type: typing.Union[int, float] Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 Type: cdk8s_plus_20.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. service_type Optional \u00b6 Type: cdk8s_plus_20.ServiceType Default: ClusterIP. The type of the exposed service. target_port Optional \u00b6 Type: typing.Union[int, float] Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ingress Optional \u00b6 Type: cdk8s_plus_20.IngressV1Beta1 Default: An ingress will be automatically created. The ingress to add rules to. expose_via_service \u00b6 def expose_via_service ( name : str = None , port : typing . Union [ int , float ] = None , protocol : Protocol = None , service_type : ServiceType = None , target_port : typing . Union [ int , float ] = None ) name Optional \u00b6 Type: str Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 Type: typing.Union[int, float] Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 Type: cdk8s_plus_20.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. service_type Optional \u00b6 Type: cdk8s_plus_20.ServiceType Default: ClusterIP. The type of the exposed service. target_port Optional \u00b6 Type: typing.Union[int, float] Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. select_by_label \u00b6 def select_by_label ( key : str , value : str ) key Required \u00b6 Type: str The label key. value Required \u00b6 Type: str The label value. Properties \u00b6 containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_20.Container ] The containers belonging to the pod. Use addContainer to add containers. label_selector Required \u00b6 label_selector : typing . Mapping [ str ] Type: typing.Mapping[ str ] The labels this deployment will match against in order to select pods. Returns a a copy. Use selectByLabel() to add labels. pod_metadata Required \u00b6 pod_metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. replicas Required \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Number of desired pods. volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_20.Volume ] The volumes associated with this pod. Use addVolume to add volumes. restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_20.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_20.IServiceAccount The service account used to run this pod. IngressV1Beta1 \u00b6 Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . IngressV1Beta1 ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , default_backend : IngressV1Beta1Backend = None , rules : typing . List [ IngressV1Beta1Rule ] = None , tls : typing . List [ IngressV1Beta1Tls ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. default_backend Optional \u00b6 Type: cdk8s_plus_20.IngressV1Beta1Backend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 Type: typing.List[ cdk8s_plus_20.IngressV1Beta1Rule ] Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 Type: typing.List[ cdk8s_plus_20.IngressV1Beta1Tls ] TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. Methods \u00b6 add_default_backend \u00b6 def add_default_backend ( backend : IngressV1Beta1Backend ) backend Required \u00b6 Type: cdk8s_plus_20.IngressV1Beta1Backend The backend to use for requests that do not match any rule. add_host_default_backend \u00b6 def add_host_default_backend ( host : str , backend : IngressV1Beta1Backend ) host Required \u00b6 Type: str The host name to match. backend Required \u00b6 Type: cdk8s_plus_20.IngressV1Beta1Backend The backend to route to. add_host_rule \u00b6 def add_host_rule ( host : str , path : str , backend : IngressV1Beta1Backend ) host Required \u00b6 Type: str The host name. path Required \u00b6 Type: str The HTTP path. backend Required \u00b6 Type: cdk8s_plus_20.IngressV1Beta1Backend The backend to route requests to. add_rule \u00b6 def add_rule ( path : str , backend : IngressV1Beta1Backend ) path Required \u00b6 Type: str The HTTP path. backend Required \u00b6 Type: cdk8s_plus_20.IngressV1Beta1Backend The backend to route requests to. add_rules \u00b6 def add_rules ( backend : IngressV1Beta1Backend , host : str = None , path : str = None ) backend Required \u00b6 Type: cdk8s_plus_20.IngressV1Beta1Backend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 Type: str Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 Type: str Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. add_tls \u00b6 def add_tls ( tls : typing . List [ IngressV1Beta1Tls ] ) tls Required \u00b6 Type: typing.List[ cdk8s_plus_20.IngressV1Beta1Tls ] Job \u00b6 Implements: cdk8s_plus_20.IPodTemplate A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel. Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Job ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , active_deadline : Duration = None , backoff_limit : typing . Union [ int , float ] = None , ttl_after_finished : Duration = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: typing.List[ cdk8s_plus_20.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_20.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata. active_deadline Optional \u00b6 Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoff_limit Optional \u00b6 Type: typing.Union[int, float] Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttl_after_finished Optional \u00b6 Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_20.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_20.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_20.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_20.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_20.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_20.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( volume : Volume ) volume Required \u00b6 Type: cdk8s_plus_20.Volume Properties \u00b6 containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_20.Container ] The containers belonging to the pod. Use addContainer to add containers. pod_metadata Required \u00b6 pod_metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_20.Volume ] The volumes associated with this pod. Use addVolume to add volumes. active_deadline Optional \u00b6 active_deadline : Duration Type: cdk8s.Duration Duration before job is terminated. If undefined, there is no deadline. backoff_limit Optional \u00b6 backoff_limit : typing . Union [ int , float ] Type: typing.Union[int, float] Number of retries before marking failed. restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_20.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_20.IServiceAccount The service account used to run this pod. ttl_after_finished Optional \u00b6 ttl_after_finished : Duration Type: cdk8s.Duration TTL before the job is deleted after it is finished. Pod \u00b6 Implements: cdk8s_plus_20.IPodSpec Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts. Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Pod ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: typing.List[ cdk8s_plus_20.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_20.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_20.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_20.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_20.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_20.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_20.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_20.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( volume : Volume ) volume Required \u00b6 Type: cdk8s_plus_20.Volume Properties \u00b6 containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_20.Container ] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_20.Volume ] The volumes associated with this pod. Use addVolume to add volumes. restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_20.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_20.IServiceAccount The service account used to run this pod. Resource \u00b6 Implements: cdk8s_plus_20.IResource Base class for all Kubernetes objects in stdk8s. Represents a single resource. Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Resource ( scope : Construct , id : str , node_factory : INodeFactory = None ) scope Required \u00b6 Type: constructs.Construct The scope in which to define this construct. id Required \u00b6 Type: str The scoped construct ID. Must be unique amongst siblings. If the ID includes a path separator ( / ), then it will be replaced by double dash -- . node_factory Optional \u00b6 Type: constructs.INodeFactory Default: the default Node is associated A factory for attaching Node s to the construct. Properties \u00b6 metadata Required \u00b6 metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition name Required \u00b6 name : str Type: str The name of this API object. Secret \u00b6 Implements: cdk8s_plus_20.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Secret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , string_data : typing . Mapping [ str ] = None , type : str = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. string_data Optional \u00b6 Type: typing.Mapping[ str ] stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 Type: str Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. Methods \u00b6 add_string_data \u00b6 def add_string_data ( key : str , value : str ) key Required \u00b6 Type: str Key. value Required \u00b6 Type: str Value. get_string_data \u00b6 def get_string_data ( key : str ) key Required \u00b6 Type: str Key. Static Functions \u00b6 from_secret_name \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Secret . from_secret_name ( name : str ) name Required \u00b6 Type: str The name of the secret to reference. Service \u00b6 An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods. Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Service ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , cluster_i_p : str = None , external_i_ps : typing . List [ str ] = None , external_name : str = None , load_balancer_source_ranges : typing . List [ str ] = None , ports : typing . List [ ServicePort ] = None , type : ServiceType = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. cluster_i_p Optional \u00b6 Type: str Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies external_i_ps Optional \u00b6 Type: typing.List[ str ] Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. external_name Optional \u00b6 Type: str Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. load_balancer_source_ranges Optional \u00b6 Type: typing.List[ str ] A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 Type: typing.List[ cdk8s_plus_20.ServicePort ] The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 Type: cdk8s_plus_20.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types Methods \u00b6 add_deployment \u00b6 def add_deployment ( deployment : Deployment , name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None , port : typing . Union [ int , float ] = None ) deployment Required \u00b6 Type: cdk8s_plus_20.Deployment The deployment to expose. name Optional \u00b6 Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 Type: cdk8s_plus_20.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. port Optional \u00b6 Type: typing.Union[int, float] Default: Copied from the first container of the deployment. The port number the service will bind to. add_selector \u00b6 def add_selector ( label : str , value : str ) label Required \u00b6 Type: str The label key. value Required \u00b6 Type: str The label value. expose_via_ingress \u00b6 def expose_via_ingress ( path : str , ingress : IngressV1Beta1 = None ) path Required \u00b6 Type: str The path to expose the service under. ingress Optional \u00b6 Type: cdk8s_plus_20.IngressV1Beta1 Default: An ingress will be automatically created. The ingress to add rules to. serve \u00b6 def serve ( port : typing . Union [ int , float ], name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None ) port Required \u00b6 Type: typing.Union[int, float] The port definition. name Optional \u00b6 Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 Type: cdk8s_plus_20.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. Properties \u00b6 ports Required \u00b6 ports : typing . List [ ServicePort ] Type: typing.List[ cdk8s_plus_20.ServicePort ] Ports for this service. Use serve() to expose additional service ports. selector Required \u00b6 selector : typing . Mapping [ str ] Type: typing.Mapping[ str ] Returns the labels which are used to select pods for this service. type Required \u00b6 type : ServiceType Type: cdk8s_plus_20.ServiceType Determines how the Service is exposed. cluster_i_p Optional \u00b6 cluster_i_p : str Type: str The IP address of the service and is usually assigned randomly by the master. external_name Optional \u00b6 external_name : str Type: str The externalName to be used for EXTERNAL_NAME types. ServiceAccount \u00b6 Implements: cdk8s_plus_20.IServiceAccount A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ServiceAccount ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , secrets : typing . List [ ISecret ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. secrets Optional \u00b6 Type: typing.List[ cdk8s_plus_20.ISecret ] List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret Methods \u00b6 add_secret \u00b6 def add_secret ( secret : ISecret ) secret Required \u00b6 Type: cdk8s_plus_20.ISecret The secret. Static Functions \u00b6 from_service_account_name \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ServiceAccount . from_service_account_name ( name : str ) name Required \u00b6 Type: str The name of the service account resource. Properties \u00b6 secrets Required \u00b6 secrets : typing . List [ ISecret ] Type: typing.List[ cdk8s_plus_20.ISecret ] List of secrets allowed to be used by pods running using this service account. Returns a copy. To add a secret, use addSecret() . StatefulSet \u00b6 Implements: cdk8s_plus_20.IPodTemplate StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed. Using StatefulSets \u00b6 StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates. Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . StatefulSet ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , service : Service , default_selector : bool = None , pod_management_policy : PodManagementPolicy = None , replicas : typing . Union [ int , float ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: typing.List[ cdk8s_plus_20.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_20.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata. service Required \u00b6 Type: cdk8s_plus_20.Service Service to associate with the statefulset. default_selector Optional \u00b6 Type: bool Default: true Automatically allocates a pod selector for this statefulset. If this is set to false you must define your selector through statefulset.podMetadata.addLabel() and statefulset.selectByLabel() . pod_management_policy Optional \u00b6 Type: cdk8s_plus_20.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 Type: typing.Union[int, float] Default: 1 Number of desired pods. Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_20.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_20.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_20.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_20.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_20.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_20.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( volume : Volume ) volume Required \u00b6 Type: cdk8s_plus_20.Volume select_by_label \u00b6 def select_by_label ( key : str , value : str ) key Required \u00b6 Type: str The label key. value Required \u00b6 Type: str The label value. Properties \u00b6 containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_20.Container ] The containers belonging to the pod. Use addContainer to add containers. label_selector Required \u00b6 label_selector : typing . Mapping [ str ] Type: typing.Mapping[ str ] The labels this statefulset will match against in order to select pods. Returns a a copy. Use selectByLabel() to add labels. pod_management_policy Required \u00b6 pod_management_policy : PodManagementPolicy Type: cdk8s_plus_20.PodManagementPolicy Management policy to use for the set. pod_metadata Required \u00b6 pod_metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. replicas Required \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Number of desired pods. volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_20.Volume ] The volumes associated with this pod. Use addVolume to add volumes. restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_20.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_20.IServiceAccount The service account used to run this pod. Structs \u00b6 AddDeploymentOptions \u00b6 Options to add a deployment to a service. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . AddDeploymentOptions ( name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None , port : typing . Union [ int , float ] = None ) name Optional \u00b6 name : str Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 node_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_20.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: Copied from the first container of the deployment. The port number the service will bind to. AddDirectoryOptions \u00b6 Options for configmap.addDirectory() . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . AddDirectoryOptions ( exclude : typing . List [ str ] = None , key_prefix : str = None ) exclude Optional \u00b6 exclude : typing . List [ str ] Type: typing.List[ str ] Default: include all files Glob patterns to exclude when adding files. key_prefix Optional \u00b6 key_prefix : str Type: str Default: \u201c\u201d A prefix to add to all keys in the config map. CommandProbeOptions \u00b6 Options for Probe.fromCommand() . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . CommandProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None ) failure_threshold Optional \u00b6 failure_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 initial_delay_seconds : Duration Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 period_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 success_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 timeout_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ConfigMapProps \u00b6 Properties for initialization of ConfigMap . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ConfigMapProps ( metadata : ApiObjectMetadata = None , binary_data : typing . Mapping [ str ] = None , data : typing . Mapping [ str ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binary_data Optional \u00b6 binary_data : typing . Mapping [ str ] Type: typing.Mapping[ str ] BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. Using this field will require 1.10+ apiserver and kubelet. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 data : typing . Mapping [ str ] Type: typing.Mapping[ str ] Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . ConfigMapVolumeOptions \u00b6 Options for the ConfigMap-based volume. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ConfigMapVolumeOptions ( default_mode : typing . Union [ int , float ] = None , items : typing . Mapping [ PathMapping ] = None , name : str = None , optional : bool = None ) default_mode Optional \u00b6 default_mode : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 items : typing . Mapping [ PathMapping ] Type: typing.Mapping[ cdk8s_plus_20.PathMapping ] Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 name : str Type: str Default: auto-generated The volume name. optional Optional \u00b6 optional : bool Type: bool Default: undocumented Specify whether the ConfigMap or its keys must be defined. ContainerProps \u00b6 Properties for creating a container. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ContainerProps ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 image : str Type: str Docker image name. args Optional \u00b6 args : typing . List [ str ] Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 command : typing . List [ str ] Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 env : typing . Mapping [ EnvValue ] Type: typing.Mapping[ cdk8s_plus_20.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 image_pull_policy : ImagePullPolicy Type: cdk8s_plus_20.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 liveness : Probe Type: cdk8s_plus_20.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 name : str Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 readiness : Probe Type: cdk8s_plus_20.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 startup : Probe Type: cdk8s_plus_20.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 volume_mounts : typing . List [ VolumeMount ] Type: typing.List[ cdk8s_plus_20.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 working_dir : str Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. DeploymentProps \u00b6 Properties for initialization of Deployment . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . DeploymentProps ( metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , default_selector : bool = None , replicas : typing . Union [ int , float ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_20.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_20.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata. default_selector Optional \u00b6 default_selector : bool Type: bool Default: true Automatically allocates a pod selector for this deployment. If this is set to false you must define your selector through deployment.podMetadata.addLabel() and deployment.selectByLabel() . replicas Optional \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Number of desired pods. EmptyDirVolumeOptions \u00b6 Options for volumes populated with an empty directory. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . EmptyDirVolumeOptions ( medium : EmptyDirMedium = None , size_limit : Size = None ) medium Optional \u00b6 medium : EmptyDirMedium Type: cdk8s_plus_20.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. size_limit Optional \u00b6 size_limit : Size Type: cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. EnvValueFromConfigMapOptions \u00b6 Options to specify an envionment variable value from a ConfigMap key. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . EnvValueFromConfigMapOptions ( optional : bool = None ) optional Optional \u00b6 optional : bool Type: bool Default: false Specify whether the ConfigMap or its key must be defined. EnvValueFromProcessOptions \u00b6 Options to specify an environment variable value from the process environment. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . EnvValueFromProcessOptions ( required : bool = None ) required Optional \u00b6 required : bool Type: bool Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. EnvValueFromSecretOptions \u00b6 Options to specify an environment variable value from a Secret. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . EnvValueFromSecretOptions ( optional : bool = None ) optional Optional \u00b6 optional : bool Type: bool Default: false Specify whether the Secret or its key must be defined. ExposeDeploymentViaIngressOptions \u00b6 Options for exposing a deployment via an ingress. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ExposeDeploymentViaIngressOptions ( name : str = None , port : typing . Union [ int , float ] = None , protocol : Protocol = None , service_type : ServiceType = None , target_port : typing . Union [ int , float ] = None , ingress : IngressV1Beta1 = None ) name Optional \u00b6 name : str Type: str Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_20.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. service_type Optional \u00b6 service_type : ServiceType Type: cdk8s_plus_20.ServiceType Default: ClusterIP. The type of the exposed service. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ingress Optional \u00b6 ingress : IngressV1Beta1 Type: cdk8s_plus_20.IngressV1Beta1 Default: An ingress will be automatically created. The ingress to add rules to. ExposeDeploymentViaServiceOptions \u00b6 Options for exposing a deployment via a service. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ExposeDeploymentViaServiceOptions ( name : str = None , port : typing . Union [ int , float ] = None , protocol : Protocol = None , service_type : ServiceType = None , target_port : typing . Union [ int , float ] = None ) name Optional \u00b6 name : str Type: str Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_20.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. service_type Optional \u00b6 service_type : ServiceType Type: cdk8s_plus_20.ServiceType Default: ClusterIP. The type of the exposed service. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ExposeServiceViaIngressOptions \u00b6 Options for exposing a service using an ingress. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ExposeServiceViaIngressOptions ( ingress : IngressV1Beta1 = None ) ingress Optional \u00b6 ingress : IngressV1Beta1 Type: cdk8s_plus_20.IngressV1Beta1 Default: An ingress will be automatically created. The ingress to add rules to. HttpGetProbeOptions \u00b6 Options for Probe.fromHttpGet() . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . HttpGetProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None , port : typing . Union [ int , float ] = None ) failure_threshold Optional \u00b6 failure_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 initial_delay_seconds : Duration Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 period_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 success_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 timeout_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to use when sending the GET request. IngressV1Beta1Props \u00b6 Properties for Ingress . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . IngressV1Beta1Props ( metadata : ApiObjectMetadata = None , default_backend : IngressV1Beta1Backend = None , rules : typing . List [ IngressV1Beta1Rule ] = None , tls : typing . List [ IngressV1Beta1Tls ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. default_backend Optional \u00b6 default_backend : IngressV1Beta1Backend Type: cdk8s_plus_20.IngressV1Beta1Backend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 rules : typing . List [ IngressV1Beta1Rule ] Type: typing.List[ cdk8s_plus_20.IngressV1Beta1Rule ] Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 tls : typing . List [ IngressV1Beta1Tls ] Type: typing.List[ cdk8s_plus_20.IngressV1Beta1Tls ] TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. IngressV1Beta1Rule \u00b6 Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . IngressV1Beta1Rule ( backend : IngressV1Beta1Backend , host : str = None , path : str = None ) backend Required \u00b6 backend : IngressV1Beta1Backend Type: cdk8s_plus_20.IngressV1Beta1Backend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 host : str Type: str Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 path : str Type: str Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. IngressV1Beta1Tls \u00b6 Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . IngressV1Beta1Tls ( hosts : typing . List [ str ] = None , secret : ISecret = None ) hosts Optional \u00b6 hosts : typing . List [ str ] Type: typing.List[ str ] Default: If unspecified, it defaults to the wildcard host setting for the loadbalancer controller fulfilling this Ingress. Hosts are a list of hosts included in the TLS certificate. The values in this list must match the name/s used in the TLS Secret. secret Optional \u00b6 secret : ISecret Type: cdk8s_plus_20.ISecret Default: If unspecified, it allows SSL routing based on SNI hostname. Secret is the secret that contains the certificate and key used to terminate SSL traffic on 443. If the SNI host in a listener conflicts with the \u201cHost\u201d header field used by an IngressRule, the SNI host is used for termination and value of the Host header is used for routing. JobProps \u00b6 Properties for initialization of Job . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . JobProps ( metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , active_deadline : Duration = None , backoff_limit : typing . Union [ int , float ] = None , ttl_after_finished : Duration = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_20.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_20.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata. active_deadline Optional \u00b6 active_deadline : Duration Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoff_limit Optional \u00b6 backoff_limit : typing . Union [ int , float ] Type: typing.Union[int, float] Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttl_after_finished Optional \u00b6 ttl_after_finished : Duration Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. MountOptions \u00b6 Options for mounts. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . MountOptions ( propagation : MountPropagation = None , read_only : bool = None , sub_path : str = None , sub_path_expr : str = None ) propagation Optional \u00b6 propagation : MountPropagation Type: cdk8s_plus_20.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. This field is beta in 1.10. read_only Optional \u00b6 read_only : bool Type: bool Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. sub_path Optional \u00b6 sub_path : str Type: str Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). sub_path_expr Optional \u00b6 sub_path_expr : str Type: str Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). SubPathExpr and SubPath are mutually exclusive. This field is beta in 1.15. subPathExpr and subPath are mutually exclusive. This field is beta in 1.15. PathMapping \u00b6 Maps a string key to a path within a volume. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . PathMapping ( path : str , mode : typing . Union [ int , float ] = None ) path Required \u00b6 path : str Type: str The relative path of the file to map the key to. May not be an absolute path. May not contain the path element \u2018..\u2019. May not start with the string \u2018..\u2019. mode Optional \u00b6 mode : typing . Union [ int , float ] Type: typing.Union[int, float] Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. PodProps \u00b6 Properties for initialization of Pod . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . PodProps ( metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_20.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_20.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodSpecProps \u00b6 Properties of a PodSpec . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . PodSpecProps ( containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_20.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_20.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodTemplateProps \u00b6 Properties of a PodTemplate . Adds metadata information on top of the spec. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . PodTemplateProps ( containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None ) containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_20.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_20.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata. ProbeOptions \u00b6 Probe options. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None ) failure_threshold Optional \u00b6 failure_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 initial_delay_seconds : Duration Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 period_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 success_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 timeout_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ResourceProps \u00b6 Initialization properties for resources. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ResourceProps ( metadata : ApiObjectMetadata = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. SecretProps \u00b6 Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . SecretProps ( metadata : ApiObjectMetadata = None , string_data : typing . Mapping [ str ] = None , type : str = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. string_data Optional \u00b6 string_data : typing . Mapping [ str ] Type: typing.Mapping[ str ] stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 type : str Type: str Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. SecretValue \u00b6 Represents a specific value in JSON secret. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . SecretValue ( key : str , secret : ISecret ) key Required \u00b6 key : str Type: str The JSON key. secret Required \u00b6 secret : ISecret Type: cdk8s_plus_20.ISecret The secret. ServiceAccountProps \u00b6 Properties for initialization of ServiceAccount . Properties for initialization of ServiceAccount . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ServiceAccountProps ( metadata : ApiObjectMetadata = None , secrets : typing . List [ ISecret ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. secrets Optional \u00b6 secrets : typing . List [ ISecret ] Type: typing.List[ cdk8s_plus_20.ISecret ] List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret ServiceIngressV1BetaBackendOptions \u00b6 Options for setting up backends for ingress rules. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ServiceIngressV1BetaBackendOptions ( port : typing . Union [ int , float ] = None ) port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. If the service exposes multiple ports, this option must be specified. If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. ServicePort \u00b6 Definition of a service port. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ServicePort ( name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None , port : typing . Union [ int , float ] ) name Optional \u00b6 name : str Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 node_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_20.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. port Required \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] The port number the service will bind to. ServicePortOptions \u00b6 Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ServicePortOptions ( name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None ) name Optional \u00b6 name : str Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 node_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_20.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. ServiceProps \u00b6 Properties for initialization of Service . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . ServiceProps ( metadata : ApiObjectMetadata = None , cluster_i_p : str = None , external_i_ps : typing . List [ str ] = None , external_name : str = None , load_balancer_source_ranges : typing . List [ str ] = None , ports : typing . List [ ServicePort ] = None , type : ServiceType = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. cluster_i_p Optional \u00b6 cluster_i_p : str Type: str Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies external_i_ps Optional \u00b6 external_i_ps : typing . List [ str ] Type: typing.List[ str ] Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. external_name Optional \u00b6 external_name : str Type: str Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. load_balancer_source_ranges Optional \u00b6 load_balancer_source_ranges : typing . List [ str ] Type: typing.List[ str ] A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 ports : typing . List [ ServicePort ] Type: typing.List[ cdk8s_plus_20.ServicePort ] The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 type : ServiceType Type: cdk8s_plus_20.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types StatefulSetProps \u00b6 Properties for initialization of StatefulSet . Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . StatefulSetProps ( metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , service : Service , default_selector : bool = None , pod_management_policy : PodManagementPolicy = None , replicas : typing . Union [ int , float ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_20.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_20.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata. service Required \u00b6 service : Service Type: cdk8s_plus_20.Service Service to associate with the statefulset. default_selector Optional \u00b6 default_selector : bool Type: bool Default: true Automatically allocates a pod selector for this statefulset. If this is set to false you must define your selector through statefulset.podMetadata.addLabel() and statefulset.selectByLabel() . pod_management_policy Optional \u00b6 pod_management_policy : PodManagementPolicy Type: cdk8s_plus_20.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Number of desired pods. VolumeMount \u00b6 Mount a volume from the pod to the container. Initializer \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . VolumeMount ( propagation : MountPropagation = None , read_only : bool = None , sub_path : str = None , sub_path_expr : str = None , path : str , volume : Volume ) propagation Optional \u00b6 propagation : MountPropagation Type: cdk8s_plus_20.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. This field is beta in 1.10. read_only Optional \u00b6 read_only : bool Type: bool Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. sub_path Optional \u00b6 sub_path : str Type: str Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). sub_path_expr Optional \u00b6 sub_path_expr : str Type: str Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). SubPathExpr and SubPath are mutually exclusive. This field is beta in 1.15. subPathExpr and subPath are mutually exclusive. This field is beta in 1.15. path Required \u00b6 path : str Type: str Path within the container at which the volume should be mounted. Must not contain \u2018:\u2019. volume Required \u00b6 volume : Volume Type: cdk8s_plus_20.Volume The volume to mount. Classes \u00b6 Container \u00b6 A single application container that you want to run within a pod. Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_20.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_20.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_20.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_20.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_20.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_20.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. Methods \u00b6 add_env \u00b6 def add_env ( name : str , value : EnvValue ) name Required \u00b6 Type: str The variable name. value Required \u00b6 Type: cdk8s_plus_20.EnvValue The variable value. mount \u00b6 def mount ( path : str , volume : Volume , propagation : MountPropagation = None , read_only : bool = None , sub_path : str = None , sub_path_expr : str = None ) path Required \u00b6 Type: str The desired path in the container. volume Required \u00b6 Type: cdk8s_plus_20.Volume The volume to mount. propagation Optional \u00b6 Type: cdk8s_plus_20.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. This field is beta in 1.10. read_only Optional \u00b6 Type: bool Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. sub_path Optional \u00b6 Type: str Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). sub_path_expr Optional \u00b6 Type: str Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). SubPathExpr and SubPath are mutually exclusive. This field is beta in 1.15. subPathExpr and subPath are mutually exclusive. This field is beta in 1.15. Properties \u00b6 env Required \u00b6 env : typing . Mapping [ EnvValue ] Type: typing.Mapping[ cdk8s_plus_20.EnvValue ] The environment variables for this container. Returns a copy. To add environment variables use addEnv() . image Required \u00b6 image : str Type: str The container image. image_pull_policy Required \u00b6 image_pull_policy : ImagePullPolicy Type: cdk8s_plus_20.ImagePullPolicy Image pull policy for this container. mounts Required \u00b6 mounts : typing . List [ VolumeMount ] Type: typing.List[ cdk8s_plus_20.VolumeMount ] Volume mounts configured for this container. name Required \u00b6 name : str Type: str The name of the container. args Optional \u00b6 args : typing . List [ str ] Type: typing.List[ str ] Arguments to the entrypoint. command Optional \u00b6 command : typing . List [ str ] Type: typing.List[ str ] Entrypoint array (the command to execute when the container starts). port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] The port this container exposes. working_dir Optional \u00b6 working_dir : str Type: str The working directory inside the container. EnvValue \u00b6 Utility class for creating reading env values from various sources. Static Functions \u00b6 from_config_map \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . EnvValue . from_config_map ( config_map : IConfigMap , key : str , optional : bool = None ) config_map Required \u00b6 Type: cdk8s_plus_20.IConfigMap The config map. key Required \u00b6 Type: str The key to extract the value from. optional Optional \u00b6 Type: bool Default: false Specify whether the ConfigMap or its key must be defined. from_process \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . EnvValue . from_process ( key : str , required : bool = None ) key Required \u00b6 Type: str The key to read. required Optional \u00b6 Type: bool Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. from_secret_value \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . EnvValue . from_secret_value ( key : str , secret : ISecret , optional : bool = None ) key Required \u00b6 Type: str The JSON key. secret Required \u00b6 Type: cdk8s_plus_20.ISecret The secret. optional Optional \u00b6 Type: bool Default: false Specify whether the Secret or its key must be defined. from_value \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . EnvValue . from_value ( value : str ) value Required \u00b6 Type: str The value. Properties \u00b6 value Optional \u00b6 value : typing . Any Type: typing.Any value_from Optional \u00b6 value_from : typing . Any Type: typing.Any IngressV1Beta1Backend \u00b6 The backend for an ingress path. Static Functions \u00b6 from_service \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . IngressV1Beta1Backend . from_service ( service : Service , port : typing . Union [ int , float ] = None ) service Required \u00b6 Type: cdk8s_plus_20.Service The service object. port Optional \u00b6 Type: typing.Union[int, float] Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. If the service exposes multiple ports, this option must be specified. If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. PodSpec \u00b6 Implements: cdk8s_plus_20.IPodSpec Provides read/write capabilities ontop of a PodSpecProps . Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . PodSpec ( containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) containers Optional \u00b6 Type: typing.List[ cdk8s_plus_20.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_20.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_20.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_20.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_20.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_20.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_20.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_20.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( volume : Volume ) volume Required \u00b6 Type: cdk8s_plus_20.Volume Properties \u00b6 containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_20.Container ] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_20.Volume ] The volumes associated with this pod. Use addVolume to add volumes. restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_20.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_20.IServiceAccount The service account used to run this pod. PodTemplate \u00b6 Implements: cdk8s_plus_20.IPodTemplate Provides read/write capabilities ontop of a PodTemplateProps . Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . PodTemplate ( containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None ) containers Optional \u00b6 Type: typing.List[ cdk8s_plus_20.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_20.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata. Properties \u00b6 pod_metadata Required \u00b6 pod_metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. Probe \u00b6 Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic. Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Probe () Static Functions \u00b6 from_command \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Probe . from_command ( command : typing . List [ str ], failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None ) command Required \u00b6 Type: typing.List[ str ] The command to execute. failure_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes from_http_get \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Probe . from_http_get ( path : str , failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None , port : typing . Union [ int , float ] = None ) path Required \u00b6 Type: str The URL path to hit. failure_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to use when sending the GET request. Volume \u00b6 Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes Initializers \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Volume ( name : str , config : typing . Any ) name Required \u00b6 Type: str config Required \u00b6 Type: typing.Any Static Functions \u00b6 from_config_map \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Volume . from_config_map ( config_map : IConfigMap , default_mode : typing . Union [ int , float ] = None , items : typing . Mapping [ PathMapping ] = None , name : str = None , optional : bool = None ) config_map Required \u00b6 Type: cdk8s_plus_20.IConfigMap The config map to use to populate the volume. default_mode Optional \u00b6 Type: typing.Union[int, float] Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_20.PathMapping ] Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 Type: str Default: auto-generated The volume name. optional Optional \u00b6 Type: bool Default: undocumented Specify whether the ConfigMap or its keys must be defined. from_empty_dir \u00b6 import cdk8s_plus_20 cdk8s_plus_20 . Volume . from_empty_dir ( name : str , medium : EmptyDirMedium = None , size_limit : Size = None ) name Required \u00b6 Type: str medium Optional \u00b6 Type: cdk8s_plus_20.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. size_limit Optional \u00b6 Type: cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. Properties \u00b6 name Required \u00b6 name : str Type: str Protocols \u00b6 IConfigMap \u00b6 Extends: cdk8s_plus_20.IResource Implemented By: cdk8s_plus_20.ConfigMap , cdk8s_plus_20.IConfigMap Represents a config map. Properties \u00b6 name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IPodSpec \u00b6 Implemented By: cdk8s_plus_20.Deployment , cdk8s_plus_20.Job , cdk8s_plus_20.Pod , cdk8s_plus_20.PodSpec , cdk8s_plus_20.PodTemplate , cdk8s_plus_20.StatefulSet , cdk8s_plus_20.IPodSpec , cdk8s_plus_20.IPodTemplate Represents a resource that can be configured with a kuberenets pod spec. (e.g Deployment , Job , Pod , \u2026). Use the PodSpec class as an implementation helper. Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_20.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_20.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_20.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_20.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_20.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_20.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( volume : Volume ) volume Required \u00b6 Type: cdk8s_plus_20.Volume The volume. Properties \u00b6 containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_20.Container ] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_20.Volume ] The volumes associated with this pod. Use addVolume to add volumes. restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_20.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_20.IServiceAccount The service account used to run this pod. IPodTemplate \u00b6 Extends: cdk8s_plus_20.IPodSpec Implemented By: cdk8s_plus_20.Deployment , cdk8s_plus_20.Job , cdk8s_plus_20.PodTemplate , cdk8s_plus_20.StatefulSet , cdk8s_plus_20.IPodTemplate Represents a resource that can be configured with a kuberenets pod template. (e.g Deployment , Job , \u2026). Use the PodTemplate class as an implementation helper. Properties \u00b6 containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_20.Container ] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_20.Volume ] The volumes associated with this pod. Use addVolume to add volumes. restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_20.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_20.IServiceAccount The service account used to run this pod. pod_metadata Required \u00b6 pod_metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. IResource \u00b6 Implemented By: cdk8s_plus_20.ConfigMap , cdk8s_plus_20.Deployment , cdk8s_plus_20.IngressV1Beta1 , cdk8s_plus_20.Job , cdk8s_plus_20.Pod , cdk8s_plus_20.Resource , cdk8s_plus_20.Secret , cdk8s_plus_20.Service , cdk8s_plus_20.ServiceAccount , cdk8s_plus_20.StatefulSet , cdk8s_plus_20.IConfigMap , cdk8s_plus_20.IResource , cdk8s_plus_20.ISecret , cdk8s_plus_20.IServiceAccount Represents a resource. Properties \u00b6 name Required \u00b6 name : str Type: str The Kubernetes name of this resource. ISecret \u00b6 Extends: cdk8s_plus_20.IResource Implemented By: cdk8s_plus_20.Secret , cdk8s_plus_20.ISecret Properties \u00b6 name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IServiceAccount \u00b6 Extends: cdk8s_plus_20.IResource Implemented By: cdk8s_plus_20.ServiceAccount , cdk8s_plus_20.IServiceAccount Properties \u00b6 name Required \u00b6 name : str Type: str The Kubernetes name of this resource. Enums \u00b6 EmptyDirMedium \u00b6 The medium on which to store the volume. DEFAULT \u00b6 The default volume of the backing node. MEMORY \u00b6 Mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. ImagePullPolicy \u00b6 ALWAYS \u00b6 Every time the kubelet launches a container, the kubelet queries the container image registry to resolve the name to an image digest. If the kubelet has a container image with that exact digest cached locally, the kubelet uses its cached image; otherwise, the kubelet downloads (pulls) the image with the resolved digest, and uses that image to launch the container. Default is Always if ImagePullPolicy is omitted and either the image tag is :latest or the image tag is omitted. IF_NOT_PRESENT \u00b6 The image is pulled only if it is not already present locally. Default is IfNotPresent if ImagePullPolicy is omitted and the image tag is present but not :latest NEVER \u00b6 The image is assumed to exist locally. No attempt is made to pull the image. MountPropagation \u00b6 NONE \u00b6 This volume mount will not receive any subsequent mounts that are mounted to this volume or any of its subdirectories by the host. In similar fashion, no mounts created by the Container will be visible on the host. This is the default mode. This mode is equal to private mount propagation as described in the Linux kernel documentation HOST_TO_CONTAINER \u00b6 This volume mount will receive all subsequent mounts that are mounted to this volume or any of its subdirectories. In other words, if the host mounts anything inside the volume mount, the Container will see it mounted there. Similarly, if any Pod with Bidirectional mount propagation to the same volume mounts anything there, the Container with HostToContainer mount propagation will see it. This mode is equal to rslave mount propagation as described in the Linux kernel documentation BIDIRECTIONAL \u00b6 This volume mount behaves the same the HostToContainer mount. In addition, all volume mounts created by the Container will be propagated back to the host and to all Containers of all Pods that use the same volume A typical use case for this mode is a Pod with a FlexVolume or CSI driver or a Pod that needs to mount something on the host using a hostPath volume. This mode is equal to rshared mount propagation as described in the Linux kernel documentation Caution: Bidirectional mount propagation can be dangerous. It can damage the host operating system and therefore it is allowed only in privileged Containers. Familiarity with Linux kernel behavior is strongly recommended. In addition, any volume mounts created by Containers in Pods must be destroyed (unmounted) by the Containers on termination. PodManagementPolicy \u00b6 Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once. ORDERED_READY \u00b6 PARALLEL \u00b6 Protocol \u00b6 TCP \u00b6 UDP \u00b6 SCTP \u00b6 RestartPolicy \u00b6 Restart policy for all containers within the pod. ALWAYS \u00b6 Always restart the pod after it exits. ON_FAILURE \u00b6 Only restart if the pod exits with a non-zero exit code. NEVER \u00b6 Never restart the pod. ServiceType \u00b6 For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP. CLUSTER_IP \u00b6 Exposes the Service on a cluster-internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default ServiceType NODE_PORT \u00b6 Exposes the Service on each Node\u2019s IP at a static port (the NodePort). A ClusterIP Service, to which the NodePort Service routes, is automatically created. You\u2019ll be able to contact the NodePort Service, from outside the cluster, by requesting : . LOAD_BALANCER \u00b6 Exposes the Service externally using a cloud provider\u2019s load balancer. NodePort and ClusterIP Services, to which the external load balancer routes, are automatically created. EXTERNAL_NAME \u00b6 Maps the Service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value. No proxying of any kind is set up. Note: You need either kube-dns version 1.7 or CoreDNS version 0.0.8 or higher to use the ExternalName type.","title":"Python"},{"location":"reference/cdk8s-plus-20/python/#cdk8s-plus-20-python","text":"","title":"cdk8s-plus-20 (Python) "},{"location":"reference/cdk8s-plus-20/python/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s-plus-20/python/#configmap","text":"Implements: cdk8s_plus_20.IConfigMap ConfigMap holds configuration data for pods to consume.","title":"ConfigMap "},{"location":"reference/cdk8s-plus-20/python/#deployment","text":"Implements: cdk8s_plus_20.IPodTemplate A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below.","title":"Deployment "},{"location":"reference/cdk8s-plus-20/python/#use-case","text":"The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore.","title":"Use Case"},{"location":"reference/cdk8s-plus-20/python/#ingressv1beta1","text":"Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.","title":"IngressV1Beta1 "},{"location":"reference/cdk8s-plus-20/python/#job","text":"Implements: cdk8s_plus_20.IPodTemplate A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel.","title":"Job "},{"location":"reference/cdk8s-plus-20/python/#pod","text":"Implements: cdk8s_plus_20.IPodSpec Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.","title":"Pod "},{"location":"reference/cdk8s-plus-20/python/#resource","text":"Implements: cdk8s_plus_20.IResource Base class for all Kubernetes objects in stdk8s. Represents a single resource.","title":"Resource "},{"location":"reference/cdk8s-plus-20/python/#secret","text":"Implements: cdk8s_plus_20.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret","title":"Secret "},{"location":"reference/cdk8s-plus-20/python/#service","text":"An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods.","title":"Service "},{"location":"reference/cdk8s-plus-20/python/#serviceaccount","text":"Implements: cdk8s_plus_20.IServiceAccount A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account","title":"ServiceAccount "},{"location":"reference/cdk8s-plus-20/python/#statefulset","text":"Implements: cdk8s_plus_20.IPodTemplate StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed.","title":"StatefulSet "},{"location":"reference/cdk8s-plus-20/python/#using-statefulsets","text":"StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates.","title":"Using StatefulSets"},{"location":"reference/cdk8s-plus-20/python/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s-plus-20/python/#adddeploymentoptions","text":"Options to add a deployment to a service.","title":"AddDeploymentOptions "},{"location":"reference/cdk8s-plus-20/python/#adddirectoryoptions","text":"Options for configmap.addDirectory() .","title":"AddDirectoryOptions "},{"location":"reference/cdk8s-plus-20/python/#commandprobeoptions","text":"Options for Probe.fromCommand() .","title":"CommandProbeOptions "},{"location":"reference/cdk8s-plus-20/python/#configmapprops","text":"Properties for initialization of ConfigMap .","title":"ConfigMapProps "},{"location":"reference/cdk8s-plus-20/python/#configmapvolumeoptions","text":"Options for the ConfigMap-based volume.","title":"ConfigMapVolumeOptions "},{"location":"reference/cdk8s-plus-20/python/#containerprops","text":"Properties for creating a container.","title":"ContainerProps "},{"location":"reference/cdk8s-plus-20/python/#deploymentprops","text":"Properties for initialization of Deployment .","title":"DeploymentProps "},{"location":"reference/cdk8s-plus-20/python/#emptydirvolumeoptions","text":"Options for volumes populated with an empty directory.","title":"EmptyDirVolumeOptions "},{"location":"reference/cdk8s-plus-20/python/#envvaluefromconfigmapoptions","text":"Options to specify an envionment variable value from a ConfigMap key.","title":"EnvValueFromConfigMapOptions "},{"location":"reference/cdk8s-plus-20/python/#envvaluefromprocessoptions","text":"Options to specify an environment variable value from the process environment.","title":"EnvValueFromProcessOptions "},{"location":"reference/cdk8s-plus-20/python/#envvaluefromsecretoptions","text":"Options to specify an environment variable value from a Secret.","title":"EnvValueFromSecretOptions "},{"location":"reference/cdk8s-plus-20/python/#exposedeploymentviaingressoptions","text":"Options for exposing a deployment via an ingress.","title":"ExposeDeploymentViaIngressOptions "},{"location":"reference/cdk8s-plus-20/python/#exposedeploymentviaserviceoptions","text":"Options for exposing a deployment via a service.","title":"ExposeDeploymentViaServiceOptions "},{"location":"reference/cdk8s-plus-20/python/#exposeserviceviaingressoptions","text":"Options for exposing a service using an ingress.","title":"ExposeServiceViaIngressOptions "},{"location":"reference/cdk8s-plus-20/python/#httpgetprobeoptions","text":"Options for Probe.fromHttpGet() .","title":"HttpGetProbeOptions "},{"location":"reference/cdk8s-plus-20/python/#ingressv1beta1props","text":"Properties for Ingress .","title":"IngressV1Beta1Props "},{"location":"reference/cdk8s-plus-20/python/#ingressv1beta1rule","text":"Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path.","title":"IngressV1Beta1Rule "},{"location":"reference/cdk8s-plus-20/python/#ingressv1beta1tls","text":"Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination.","title":"IngressV1Beta1Tls "},{"location":"reference/cdk8s-plus-20/python/#jobprops","text":"Properties for initialization of Job .","title":"JobProps "},{"location":"reference/cdk8s-plus-20/python/#mountoptions","text":"Options for mounts.","title":"MountOptions "},{"location":"reference/cdk8s-plus-20/python/#pathmapping","text":"Maps a string key to a path within a volume.","title":"PathMapping "},{"location":"reference/cdk8s-plus-20/python/#podprops","text":"Properties for initialization of Pod .","title":"PodProps "},{"location":"reference/cdk8s-plus-20/python/#podspecprops","text":"Properties of a PodSpec .","title":"PodSpecProps "},{"location":"reference/cdk8s-plus-20/python/#podtemplateprops","text":"Properties of a PodTemplate . Adds metadata information on top of the spec.","title":"PodTemplateProps "},{"location":"reference/cdk8s-plus-20/python/#probeoptions","text":"Probe options.","title":"ProbeOptions "},{"location":"reference/cdk8s-plus-20/python/#resourceprops","text":"Initialization properties for resources.","title":"ResourceProps "},{"location":"reference/cdk8s-plus-20/python/#secretprops","text":"","title":"SecretProps "},{"location":"reference/cdk8s-plus-20/python/#secretvalue","text":"Represents a specific value in JSON secret.","title":"SecretValue "},{"location":"reference/cdk8s-plus-20/python/#serviceaccountprops","text":"Properties for initialization of ServiceAccount . Properties for initialization of ServiceAccount .","title":"ServiceAccountProps "},{"location":"reference/cdk8s-plus-20/python/#serviceingressv1betabackendoptions","text":"Options for setting up backends for ingress rules.","title":"ServiceIngressV1BetaBackendOptions "},{"location":"reference/cdk8s-plus-20/python/#serviceport","text":"Definition of a service port.","title":"ServicePort "},{"location":"reference/cdk8s-plus-20/python/#serviceportoptions","text":"","title":"ServicePortOptions "},{"location":"reference/cdk8s-plus-20/python/#serviceprops","text":"Properties for initialization of Service .","title":"ServiceProps "},{"location":"reference/cdk8s-plus-20/python/#statefulsetprops","text":"Properties for initialization of StatefulSet .","title":"StatefulSetProps "},{"location":"reference/cdk8s-plus-20/python/#volumemount","text":"Mount a volume from the pod to the container.","title":"VolumeMount "},{"location":"reference/cdk8s-plus-20/python/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s-plus-20/python/#container","text":"A single application container that you want to run within a pod.","title":"Container "},{"location":"reference/cdk8s-plus-20/python/#envvalue","text":"Utility class for creating reading env values from various sources.","title":"EnvValue "},{"location":"reference/cdk8s-plus-20/python/#ingressv1beta1backend","text":"The backend for an ingress path.","title":"IngressV1Beta1Backend "},{"location":"reference/cdk8s-plus-20/python/#podspec","text":"Implements: cdk8s_plus_20.IPodSpec Provides read/write capabilities ontop of a PodSpecProps .","title":"PodSpec "},{"location":"reference/cdk8s-plus-20/python/#podtemplate","text":"Implements: cdk8s_plus_20.IPodTemplate Provides read/write capabilities ontop of a PodTemplateProps .","title":"PodTemplate "},{"location":"reference/cdk8s-plus-20/python/#probe","text":"Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.","title":"Probe "},{"location":"reference/cdk8s-plus-20/python/#volume","text":"Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes","title":"Volume "},{"location":"reference/cdk8s-plus-20/python/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s-plus-20/python/#iconfigmap","text":"Extends: cdk8s_plus_20.IResource Implemented By: cdk8s_plus_20.ConfigMap , cdk8s_plus_20.IConfigMap Represents a config map.","title":"IConfigMap "},{"location":"reference/cdk8s-plus-20/python/#ipodspec","text":"Implemented By: cdk8s_plus_20.Deployment , cdk8s_plus_20.Job , cdk8s_plus_20.Pod , cdk8s_plus_20.PodSpec , cdk8s_plus_20.PodTemplate , cdk8s_plus_20.StatefulSet , cdk8s_plus_20.IPodSpec , cdk8s_plus_20.IPodTemplate Represents a resource that can be configured with a kuberenets pod spec. (e.g Deployment , Job , Pod , \u2026). Use the PodSpec class as an implementation helper.","title":"IPodSpec "},{"location":"reference/cdk8s-plus-20/python/#ipodtemplate","text":"Extends: cdk8s_plus_20.IPodSpec Implemented By: cdk8s_plus_20.Deployment , cdk8s_plus_20.Job , cdk8s_plus_20.PodTemplate , cdk8s_plus_20.StatefulSet , cdk8s_plus_20.IPodTemplate Represents a resource that can be configured with a kuberenets pod template. (e.g Deployment , Job , \u2026). Use the PodTemplate class as an implementation helper.","title":"IPodTemplate "},{"location":"reference/cdk8s-plus-20/python/#iresource","text":"Implemented By: cdk8s_plus_20.ConfigMap , cdk8s_plus_20.Deployment , cdk8s_plus_20.IngressV1Beta1 , cdk8s_plus_20.Job , cdk8s_plus_20.Pod , cdk8s_plus_20.Resource , cdk8s_plus_20.Secret , cdk8s_plus_20.Service , cdk8s_plus_20.ServiceAccount , cdk8s_plus_20.StatefulSet , cdk8s_plus_20.IConfigMap , cdk8s_plus_20.IResource , cdk8s_plus_20.ISecret , cdk8s_plus_20.IServiceAccount Represents a resource.","title":"IResource "},{"location":"reference/cdk8s-plus-20/python/#isecret","text":"Extends: cdk8s_plus_20.IResource Implemented By: cdk8s_plus_20.Secret , cdk8s_plus_20.ISecret","title":"ISecret "},{"location":"reference/cdk8s-plus-20/python/#iserviceaccount","text":"Extends: cdk8s_plus_20.IResource Implemented By: cdk8s_plus_20.ServiceAccount , cdk8s_plus_20.IServiceAccount","title":"IServiceAccount "},{"location":"reference/cdk8s-plus-20/python/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s-plus-20/python/#emptydirmedium","text":"The medium on which to store the volume.","title":"EmptyDirMedium "},{"location":"reference/cdk8s-plus-20/python/#imagepullpolicy","text":"","title":"ImagePullPolicy "},{"location":"reference/cdk8s-plus-20/python/#mountpropagation","text":"","title":"MountPropagation "},{"location":"reference/cdk8s-plus-20/python/#podmanagementpolicy","text":"Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.","title":"PodManagementPolicy "},{"location":"reference/cdk8s-plus-20/python/#protocol","text":"","title":"Protocol "},{"location":"reference/cdk8s-plus-20/python/#restartpolicy","text":"Restart policy for all containers within the pod.","title":"RestartPolicy "},{"location":"reference/cdk8s-plus-20/python/#servicetype","text":"For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP.","title":"ServiceType "},{"location":"reference/cdk8s-plus-20/typescript/","text":"cdk8s-plus-20 (TypeScript) \u00b6 Constructs \u00b6 ConfigMap \u00b6 Implements: cdk8s-plus-20.IConfigMap ConfigMap holds configuration data for pods to consume. Initializers \u00b6 import { ConfigMap } from 'cdk8s-plus-20' new ConfigMap ( scope : Construct , id : string , props? : ConfigMapProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-20.ConfigMapProps Methods \u00b6 addBinaryData \u00b6 public addBinaryData ( key : string , value : string ) key Required \u00b6 Type: string The key. value Required \u00b6 Type: string The value. addData \u00b6 public addData ( key : string , value : string ) key Required \u00b6 Type: string The key. value Required \u00b6 Type: string The value. addDirectory \u00b6 public addDirectory ( localDir : string , options? : AddDirectoryOptions ) localDir Required \u00b6 Type: string A path to a local directory. options Optional \u00b6 Type: cdk8s-plus-20.AddDirectoryOptions Options. addFile \u00b6 public addFile ( localFile : string , key? : string ) localFile Required \u00b6 Type: string The path to the local file. key Optional \u00b6 Type: string The ConfigMap key (default to the file name). Static Functions \u00b6 fromConfigMapName \u00b6 import { ConfigMap } from 'cdk8s-plus-20' ConfigMap . fromConfigMapName ( name : string ) name Required \u00b6 Type: string The name of the config map to import. Properties \u00b6 binaryData Required \u00b6 public readonly binaryData : {[ key : string ] : string }; Type: {[ key: string ]: string } The binary data associated with this config map. Returns a copy. To add data records, use addBinaryData() or addData() . data Required \u00b6 public readonly data : {[ key : string ] : string }; Type: {[ key: string ]: string } The data associated with this config map. Returns an copy. To add data records, use addData() or addBinaryData() . Deployment \u00b6 Implements: cdk8s-plus-20.IPodTemplate A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case \u00b6 The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore. Initializers \u00b6 import { Deployment } from 'cdk8s-plus-20' new Deployment ( scope : Construct , id : string , props? : DeploymentProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-20.DeploymentProps Methods \u00b6 addContainer \u00b6 public addContainer ( container : ContainerProps ) container Required \u00b6 Type: cdk8s-plus-20.ContainerProps addVolume \u00b6 public addVolume ( volume : Volume ) volume Required \u00b6 Type: cdk8s-plus-20.Volume exposeViaIngress \u00b6 public exposeViaIngress ( path : string , options? : ExposeDeploymentViaIngressOptions ) path Required \u00b6 Type: string The ingress path to register under. options Optional \u00b6 Type: cdk8s-plus-20.ExposeDeploymentViaIngressOptions Additional options. exposeViaService \u00b6 public exposeViaService ( options? : ExposeDeploymentViaServiceOptions ) options Optional \u00b6 Type: cdk8s-plus-20.ExposeDeploymentViaServiceOptions Options to determine details of the service and port exposed. selectByLabel \u00b6 public selectByLabel ( key : string , value : string ) key Required \u00b6 Type: string The label key. value Required \u00b6 Type: string The label value. Properties \u00b6 containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-20.Container [] The containers belonging to the pod. Use addContainer to add containers. labelSelector Required \u00b6 public readonly labelSelector : {[ key : string ] : string }; Type: {[ key: string ]: string } The labels this deployment will match against in order to select pods. Returns a a copy. Use selectByLabel() to add labels. podMetadata Required \u00b6 public readonly podMetadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. replicas Required \u00b6 public readonly replicas : number ; Type: number Number of desired pods. volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-20.Volume [] The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-20.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-20.IServiceAccount The service account used to run this pod. IngressV1Beta1 \u00b6 Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. Initializers \u00b6 import { IngressV1Beta1 } from 'cdk8s-plus-20' new IngressV1Beta1 ( scope : Construct , id : string , props? : IngressV1Beta1Props ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-20.IngressV1Beta1Props Methods \u00b6 addDefaultBackend \u00b6 public addDefaultBackend ( backend : IngressV1Beta1Backend ) backend Required \u00b6 Type: cdk8s-plus-20.IngressV1Beta1Backend The backend to use for requests that do not match any rule. addHostDefaultBackend \u00b6 public addHostDefaultBackend ( host : string , backend : IngressV1Beta1Backend ) host Required \u00b6 Type: string The host name to match. backend Required \u00b6 Type: cdk8s-plus-20.IngressV1Beta1Backend The backend to route to. addHostRule \u00b6 public addHostRule ( host : string , path : string , backend : IngressV1Beta1Backend ) host Required \u00b6 Type: string The host name. path Required \u00b6 Type: string The HTTP path. backend Required \u00b6 Type: cdk8s-plus-20.IngressV1Beta1Backend The backend to route requests to. addRule \u00b6 public addRule ( path : string , backend : IngressV1Beta1Backend ) path Required \u00b6 Type: string The HTTP path. backend Required \u00b6 Type: cdk8s-plus-20.IngressV1Beta1Backend The backend to route requests to. addRules \u00b6 public addRules ( rules : IngressV1Beta1Rule ) rules Required \u00b6 Type: cdk8s-plus-20.IngressV1Beta1Rule The rules to add. addTls \u00b6 public addTls ( tls : IngressV1Beta1Tls []) tls Required \u00b6 Type: cdk8s-plus-20.IngressV1Beta1Tls [] Job \u00b6 Implements: cdk8s-plus-20.IPodTemplate A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel. Initializers \u00b6 import { Job } from 'cdk8s-plus-20' new Job ( scope : Construct , id : string , props? : JobProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-20.JobProps Methods \u00b6 addContainer \u00b6 public addContainer ( container : ContainerProps ) container Required \u00b6 Type: cdk8s-plus-20.ContainerProps addVolume \u00b6 public addVolume ( volume : Volume ) volume Required \u00b6 Type: cdk8s-plus-20.Volume Properties \u00b6 containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-20.Container [] The containers belonging to the pod. Use addContainer to add containers. podMetadata Required \u00b6 public readonly podMetadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-20.Volume [] The volumes associated with this pod. Use addVolume to add volumes. activeDeadline Optional \u00b6 public readonly activeDeadline : Duration ; Type: cdk8s.Duration Duration before job is terminated. If undefined, there is no deadline. backoffLimit Optional \u00b6 public readonly backoffLimit : number ; Type: number Number of retries before marking failed. restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-20.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-20.IServiceAccount The service account used to run this pod. ttlAfterFinished Optional \u00b6 public readonly ttlAfterFinished : Duration ; Type: cdk8s.Duration TTL before the job is deleted after it is finished. Pod \u00b6 Implements: cdk8s-plus-20.IPodSpec Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts. Initializers \u00b6 import { Pod } from 'cdk8s-plus-20' new Pod ( scope : Construct , id : string , props? : PodProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-20.PodProps Methods \u00b6 addContainer \u00b6 public addContainer ( container : ContainerProps ) container Required \u00b6 Type: cdk8s-plus-20.ContainerProps addVolume \u00b6 public addVolume ( volume : Volume ) volume Required \u00b6 Type: cdk8s-plus-20.Volume Properties \u00b6 containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-20.Container [] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-20.Volume [] The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-20.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-20.IServiceAccount The service account used to run this pod. Resource \u00b6 Implements: cdk8s-plus-20.IResource Base class for all Kubernetes objects in stdk8s. Represents a single resource. Initializers \u00b6 import { Resource } from 'cdk8s-plus-20' new Resource ( scope : Construct , id : string , options? : ConstructOptions ) scope Required \u00b6 Type: constructs.Construct The scope in which to define this construct. id Required \u00b6 Type: string The scoped construct ID. Must be unique amongst siblings. If the ID includes a path separator ( / ), then it will be replaced by double dash -- . options Optional \u00b6 Type: constructs.ConstructOptions Options. Properties \u00b6 metadata Required \u00b6 public readonly metadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition name Required \u00b6 public readonly name : string ; Type: string The name of this API object. Secret \u00b6 Implements: cdk8s-plus-20.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret Initializers \u00b6 import { Secret } from 'cdk8s-plus-20' new Secret ( scope : Construct , id : string , props? : SecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-20.SecretProps Methods \u00b6 addStringData \u00b6 public addStringData ( key : string , value : string ) key Required \u00b6 Type: string Key. value Required \u00b6 Type: string Value. getStringData \u00b6 public getStringData ( key : string ) key Required \u00b6 Type: string Key. Static Functions \u00b6 fromSecretName \u00b6 import { Secret } from 'cdk8s-plus-20' Secret . fromSecretName ( name : string ) name Required \u00b6 Type: string The name of the secret to reference. Service \u00b6 An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods. Initializers \u00b6 import { Service } from 'cdk8s-plus-20' new Service ( scope : Construct , id : string , props? : ServiceProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-20.ServiceProps Methods \u00b6 addDeployment \u00b6 public addDeployment ( deployment : Deployment , options? : AddDeploymentOptions ) deployment Required \u00b6 Type: cdk8s-plus-20.Deployment The deployment to expose. options Optional \u00b6 Type: cdk8s-plus-20.AddDeploymentOptions Optional settings for the port. addSelector \u00b6 public addSelector ( label : string , value : string ) label Required \u00b6 Type: string The label key. value Required \u00b6 Type: string The label value. exposeViaIngress \u00b6 public exposeViaIngress ( path : string , options? : ExposeServiceViaIngressOptions ) path Required \u00b6 Type: string The path to expose the service under. options Optional \u00b6 Type: cdk8s-plus-20.ExposeServiceViaIngressOptions Additional options. serve \u00b6 public serve ( port : number , options? : ServicePortOptions ) port Required \u00b6 Type: number The port definition. options Optional \u00b6 Type: cdk8s-plus-20.ServicePortOptions Properties \u00b6 ports Required \u00b6 public readonly ports : ServicePort []; Type: cdk8s-plus-20.ServicePort [] Ports for this service. Use serve() to expose additional service ports. selector Required \u00b6 public readonly selector : {[ key : string ] : string }; Type: {[ key: string ]: string } Returns the labels which are used to select pods for this service. type Required \u00b6 public readonly type : ServiceType ; Type: cdk8s-plus-20.ServiceType Determines how the Service is exposed. clusterIP Optional \u00b6 public readonly clusterIP : string ; Type: string The IP address of the service and is usually assigned randomly by the master. externalName Optional \u00b6 public readonly externalName : string ; Type: string The externalName to be used for EXTERNAL_NAME types. ServiceAccount \u00b6 Implements: cdk8s-plus-20.IServiceAccount A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account Initializers \u00b6 import { ServiceAccount } from 'cdk8s-plus-20' new ServiceAccount ( scope : Construct , id : string , props? : ServiceAccountProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-20.ServiceAccountProps Methods \u00b6 addSecret \u00b6 public addSecret ( secret : ISecret ) secret Required \u00b6 Type: cdk8s-plus-20.ISecret The secret. Static Functions \u00b6 fromServiceAccountName \u00b6 import { ServiceAccount } from 'cdk8s-plus-20' ServiceAccount . fromServiceAccountName ( name : string ) name Required \u00b6 Type: string The name of the service account resource. Properties \u00b6 secrets Required \u00b6 public readonly secrets : ISecret []; Type: cdk8s-plus-20.ISecret [] List of secrets allowed to be used by pods running using this service account. Returns a copy. To add a secret, use addSecret() . StatefulSet \u00b6 Implements: cdk8s-plus-20.IPodTemplate StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed. Using StatefulSets \u00b6 StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates. Initializers \u00b6 import { StatefulSet } from 'cdk8s-plus-20' new StatefulSet ( scope : Construct , id : string , props : StatefulSetProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-20.StatefulSetProps Methods \u00b6 addContainer \u00b6 public addContainer ( container : ContainerProps ) container Required \u00b6 Type: cdk8s-plus-20.ContainerProps addVolume \u00b6 public addVolume ( volume : Volume ) volume Required \u00b6 Type: cdk8s-plus-20.Volume selectByLabel \u00b6 public selectByLabel ( key : string , value : string ) key Required \u00b6 Type: string The label key. value Required \u00b6 Type: string The label value. Properties \u00b6 containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-20.Container [] The containers belonging to the pod. Use addContainer to add containers. labelSelector Required \u00b6 public readonly labelSelector : {[ key : string ] : string }; Type: {[ key: string ]: string } The labels this statefulset will match against in order to select pods. Returns a a copy. Use selectByLabel() to add labels. podManagementPolicy Required \u00b6 public readonly podManagementPolicy : PodManagementPolicy ; Type: cdk8s-plus-20.PodManagementPolicy Management policy to use for the set. podMetadata Required \u00b6 public readonly podMetadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. replicas Required \u00b6 public readonly replicas : number ; Type: number Number of desired pods. volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-20.Volume [] The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-20.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-20.IServiceAccount The service account used to run this pod. Structs \u00b6 AddDeploymentOptions \u00b6 Options to add a deployment to a service. Initializer \u00b6 import { AddDeploymentOptions } from 'cdk8s-plus-20' const addDeploymentOptions : AddDeploymentOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public readonly nodePort : number ; Type: number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-20.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The value of port will be used. The port number the service will redirect to. port Optional \u00b6 public readonly port : number ; Type: number Default: Copied from the first container of the deployment. The port number the service will bind to. AddDirectoryOptions \u00b6 Options for configmap.addDirectory() . Initializer \u00b6 import { AddDirectoryOptions } from 'cdk8s-plus-20' const addDirectoryOptions : AddDirectoryOptions = { ... } exclude Optional \u00b6 public readonly exclude : string []; Type: string [] Default: include all files Glob patterns to exclude when adding files. keyPrefix Optional \u00b6 public readonly keyPrefix : string ; Type: string Default: \u201c\u201d A prefix to add to all keys in the config map. CommandProbeOptions \u00b6 Options for Probe.fromCommand() . Initializer \u00b6 import { CommandProbeOptions } from 'cdk8s-plus-20' const commandProbeOptions : CommandProbeOptions = { ... } failureThreshold Optional \u00b6 public readonly failureThreshold : number ; Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public readonly initialDelaySeconds : Duration ; Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public readonly periodSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public readonly successThreshold : number ; Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public readonly timeoutSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ConfigMapProps \u00b6 Properties for initialization of ConfigMap . Initializer \u00b6 import { ConfigMapProps } from 'cdk8s-plus-20' const configMapProps : ConfigMapProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binaryData Optional \u00b6 public readonly binaryData : {[ key : string ] : string }; Type: {[ key: string ]: string } BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. Using this field will require 1.10+ apiserver and kubelet. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 public readonly data : {[ key : string ] : string }; Type: {[ key: string ]: string } Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . ConfigMapVolumeOptions \u00b6 Options for the ConfigMap-based volume. Initializer \u00b6 import { ConfigMapVolumeOptions } from 'cdk8s-plus-20' const configMapVolumeOptions : ConfigMapVolumeOptions = { ... } defaultMode Optional \u00b6 public readonly defaultMode : number ; Type: number Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 public readonly items : {[ key : string ] : PathMapping }; Type: {[ key: string ]: cdk8s-plus-20.PathMapping } Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 public readonly name : string ; Type: string Default: auto-generated The volume name. optional Optional \u00b6 public readonly optional : boolean ; Type: boolean Default: undocumented Specify whether the ConfigMap or its keys must be defined. ContainerProps \u00b6 Properties for creating a container. Initializer \u00b6 import { ContainerProps } from 'cdk8s-plus-20' const containerProps : ContainerProps = { ... } image Required \u00b6 public readonly image : string ; Type: string Docker image name. args Optional \u00b6 public readonly args : string []; Type: string [] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 public readonly command : string []; Type: string [] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 public readonly env : {[ key : string ] : EnvValue }; Type: {[ key: string ]: cdk8s-plus-20.EnvValue } Default: No environment variables. List of environment variables to set in the container. Cannot be updated. imagePullPolicy Optional \u00b6 public readonly imagePullPolicy : ImagePullPolicy ; Type: cdk8s-plus-20.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 public readonly liveness : Probe ; Type: cdk8s-plus-20.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 public readonly name : string ; Type: string Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 public readonly port : number ; Type: number Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 public readonly readiness : Probe ; Type: cdk8s-plus-20.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 public readonly startup : Probe ; Type: cdk8s-plus-20.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volumeMounts Optional \u00b6 public readonly volumeMounts : VolumeMount []; Type: cdk8s-plus-20.VolumeMount [] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. workingDir Optional \u00b6 public readonly workingDir : string ; Type: string Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. DeploymentProps \u00b6 Properties for initialization of Deployment . Initializer \u00b6 import { DeploymentProps } from 'cdk8s-plus-20' const deploymentProps : DeploymentProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-20.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-20.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata. defaultSelector Optional \u00b6 public readonly defaultSelector : boolean ; Type: boolean Default: true Automatically allocates a pod selector for this deployment. If this is set to false you must define your selector through deployment.podMetadata.addLabel() and deployment.selectByLabel() . replicas Optional \u00b6 public readonly replicas : number ; Type: number Default: 1 Number of desired pods. EmptyDirVolumeOptions \u00b6 Options for volumes populated with an empty directory. Initializer \u00b6 import { EmptyDirVolumeOptions } from 'cdk8s-plus-20' const emptyDirVolumeOptions : EmptyDirVolumeOptions = { ... } medium Optional \u00b6 public readonly medium : EmptyDirMedium ; Type: cdk8s-plus-20.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. sizeLimit Optional \u00b6 public readonly sizeLimit : Size ; Type: cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. EnvValueFromConfigMapOptions \u00b6 Options to specify an envionment variable value from a ConfigMap key. Initializer \u00b6 import { EnvValueFromConfigMapOptions } from 'cdk8s-plus-20' const envValueFromConfigMapOptions : EnvValueFromConfigMapOptions = { ... } optional Optional \u00b6 public readonly optional : boolean ; Type: boolean Default: false Specify whether the ConfigMap or its key must be defined. EnvValueFromProcessOptions \u00b6 Options to specify an environment variable value from the process environment. Initializer \u00b6 import { EnvValueFromProcessOptions } from 'cdk8s-plus-20' const envValueFromProcessOptions : EnvValueFromProcessOptions = { ... } required Optional \u00b6 public readonly required : boolean ; Type: boolean Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. EnvValueFromSecretOptions \u00b6 Options to specify an environment variable value from a Secret. Initializer \u00b6 import { EnvValueFromSecretOptions } from 'cdk8s-plus-20' const envValueFromSecretOptions : EnvValueFromSecretOptions = { ... } optional Optional \u00b6 public readonly optional : boolean ; Type: boolean Default: false Specify whether the Secret or its key must be defined. ExposeDeploymentViaIngressOptions \u00b6 Options for exposing a deployment via an ingress. Initializer \u00b6 import { ExposeDeploymentViaIngressOptions } from 'cdk8s-plus-20' const exposeDeploymentViaIngressOptions : ExposeDeploymentViaIngressOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 public readonly port : number ; Type: number Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-20.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. serviceType Optional \u00b6 public readonly serviceType : ServiceType ; Type: cdk8s-plus-20.ServiceType Default: ClusterIP. The type of the exposed service. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ingress Optional \u00b6 public readonly ingress : IngressV1Beta1 ; Type: cdk8s-plus-20.IngressV1Beta1 Default: An ingress will be automatically created. The ingress to add rules to. ExposeDeploymentViaServiceOptions \u00b6 Options for exposing a deployment via a service. Initializer \u00b6 import { ExposeDeploymentViaServiceOptions } from 'cdk8s-plus-20' const exposeDeploymentViaServiceOptions : ExposeDeploymentViaServiceOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 public readonly port : number ; Type: number Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-20.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. serviceType Optional \u00b6 public readonly serviceType : ServiceType ; Type: cdk8s-plus-20.ServiceType Default: ClusterIP. The type of the exposed service. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ExposeServiceViaIngressOptions \u00b6 Options for exposing a service using an ingress. Initializer \u00b6 import { ExposeServiceViaIngressOptions } from 'cdk8s-plus-20' const exposeServiceViaIngressOptions : ExposeServiceViaIngressOptions = { ... } ingress Optional \u00b6 public readonly ingress : IngressV1Beta1 ; Type: cdk8s-plus-20.IngressV1Beta1 Default: An ingress will be automatically created. The ingress to add rules to. HttpGetProbeOptions \u00b6 Options for Probe.fromHttpGet() . Initializer \u00b6 import { HttpGetProbeOptions } from 'cdk8s-plus-20' const httpGetProbeOptions : HttpGetProbeOptions = { ... } failureThreshold Optional \u00b6 public readonly failureThreshold : number ; Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public readonly initialDelaySeconds : Duration ; Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public readonly periodSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public readonly successThreshold : number ; Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public readonly timeoutSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 public readonly port : number ; Type: number Default: defaults to container.port . The TCP port to use when sending the GET request. IngressV1Beta1Props \u00b6 Properties for Ingress . Initializer \u00b6 import { IngressV1Beta1Props } from 'cdk8s-plus-20' const ingressV1Beta1Props : IngressV1Beta1Props = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. defaultBackend Optional \u00b6 public readonly defaultBackend : IngressV1Beta1Backend ; Type: cdk8s-plus-20.IngressV1Beta1Backend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 public readonly rules : IngressV1Beta1Rule []; Type: cdk8s-plus-20.IngressV1Beta1Rule [] Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 public readonly tls : IngressV1Beta1Tls []; Type: cdk8s-plus-20.IngressV1Beta1Tls [] TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. IngressV1Beta1Rule \u00b6 Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path. Initializer \u00b6 import { IngressV1Beta1Rule } from 'cdk8s-plus-20' const ingressV1Beta1Rule : IngressV1Beta1Rule = { ... } backend Required \u00b6 public readonly backend : IngressV1Beta1Backend ; Type: cdk8s-plus-20.IngressV1Beta1Backend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 public readonly host : string ; Type: string Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 public readonly path : string ; Type: string Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. IngressV1Beta1Tls \u00b6 Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination. Initializer \u00b6 import { IngressV1Beta1Tls } from 'cdk8s-plus-20' const ingressV1Beta1Tls : IngressV1Beta1Tls = { ... } hosts Optional \u00b6 public readonly hosts : string []; Type: string [] Default: If unspecified, it defaults to the wildcard host setting for the loadbalancer controller fulfilling this Ingress. Hosts are a list of hosts included in the TLS certificate. The values in this list must match the name/s used in the TLS Secret. secret Optional \u00b6 public readonly secret : ISecret ; Type: cdk8s-plus-20.ISecret Default: If unspecified, it allows SSL routing based on SNI hostname. Secret is the secret that contains the certificate and key used to terminate SSL traffic on 443. If the SNI host in a listener conflicts with the \u201cHost\u201d header field used by an IngressRule, the SNI host is used for termination and value of the Host header is used for routing. JobProps \u00b6 Properties for initialization of Job . Initializer \u00b6 import { JobProps } from 'cdk8s-plus-20' const jobProps : JobProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-20.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-20.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata. activeDeadline Optional \u00b6 public readonly activeDeadline : Duration ; Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 public readonly backoffLimit : number ; Type: number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 public readonly ttlAfterFinished : Duration ; Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. MountOptions \u00b6 Options for mounts. Initializer \u00b6 import { MountOptions } from 'cdk8s-plus-20' const mountOptions : MountOptions = { ... } propagation Optional \u00b6 public readonly propagation : MountPropagation ; Type: cdk8s-plus-20.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. This field is beta in 1.10. readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public readonly subPath : string ; Type: string Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public readonly subPathExpr : string ; Type: string Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). SubPathExpr and SubPath are mutually exclusive. This field is beta in 1.15. subPathExpr and subPath are mutually exclusive. This field is beta in 1.15. PathMapping \u00b6 Maps a string key to a path within a volume. Initializer \u00b6 import { PathMapping } from 'cdk8s-plus-20' const pathMapping : PathMapping = { ... } path Required \u00b6 public readonly path : string ; Type: string The relative path of the file to map the key to. May not be an absolute path. May not contain the path element \u2018..\u2019. May not start with the string \u2018..\u2019. mode Optional \u00b6 public readonly mode : number ; Type: number Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. PodProps \u00b6 Properties for initialization of Pod . Initializer \u00b6 import { PodProps } from 'cdk8s-plus-20' const podProps : PodProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-20.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-20.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodSpecProps \u00b6 Properties of a PodSpec . Initializer \u00b6 import { PodSpecProps } from 'cdk8s-plus-20' const podSpecProps : PodSpecProps = { ... } containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-20.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-20.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodTemplateProps \u00b6 Properties of a PodTemplate . Adds metadata information on top of the spec. Initializer \u00b6 import { PodTemplateProps } from 'cdk8s-plus-20' const podTemplateProps : PodTemplateProps = { ... } containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-20.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-20.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata. ProbeOptions \u00b6 Probe options. Initializer \u00b6 import { ProbeOptions } from 'cdk8s-plus-20' const probeOptions : ProbeOptions = { ... } failureThreshold Optional \u00b6 public readonly failureThreshold : number ; Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public readonly initialDelaySeconds : Duration ; Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public readonly periodSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public readonly successThreshold : number ; Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public readonly timeoutSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ResourceProps \u00b6 Initialization properties for resources. Initializer \u00b6 import { ResourceProps } from 'cdk8s-plus-20' const resourceProps : ResourceProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. SecretProps \u00b6 Initializer \u00b6 import { SecretProps } from 'cdk8s-plus-20' const secretProps : SecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. stringData Optional \u00b6 public readonly stringData : {[ key : string ] : string }; Type: {[ key: string ]: string } stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 public readonly type : string ; Type: string Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. SecretValue \u00b6 Represents a specific value in JSON secret. Initializer \u00b6 import { SecretValue } from 'cdk8s-plus-20' const secretValue : SecretValue = { ... } key Required \u00b6 public readonly key : string ; Type: string The JSON key. secret Required \u00b6 public readonly secret : ISecret ; Type: cdk8s-plus-20.ISecret The secret. ServiceAccountProps \u00b6 Properties for initialization of ServiceAccount . Properties for initialization of ServiceAccount . Initializer \u00b6 import { ServiceAccountProps } from 'cdk8s-plus-20' const serviceAccountProps : ServiceAccountProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. secrets Optional \u00b6 public readonly secrets : ISecret []; Type: cdk8s-plus-20.ISecret [] List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret ServiceIngressV1BetaBackendOptions \u00b6 Options for setting up backends for ingress rules. Initializer \u00b6 import { ServiceIngressV1BetaBackendOptions } from 'cdk8s-plus-20' const serviceIngressV1BetaBackendOptions : ServiceIngressV1BetaBackendOptions = { ... } port Optional \u00b6 public readonly port : number ; Type: number Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. - If the service exposes multiple ports, this option must be specified. - If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. ServicePort \u00b6 Definition of a service port. Initializer \u00b6 import { ServicePort } from 'cdk8s-plus-20' const servicePort : ServicePort = { ... } name Optional \u00b6 public readonly name : string ; Type: string The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public readonly nodePort : number ; Type: number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-20.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The value of port will be used. The port number the service will redirect to. port Required \u00b6 public readonly port : number ; Type: number The port number the service will bind to. ServicePortOptions \u00b6 Initializer \u00b6 import { ServicePortOptions } from 'cdk8s-plus-20' const servicePortOptions : ServicePortOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public readonly nodePort : number ; Type: number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-20.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The value of port will be used. The port number the service will redirect to. ServiceProps \u00b6 Properties for initialization of Service . Initializer \u00b6 import { ServiceProps } from 'cdk8s-plus-20' const serviceProps : ServiceProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. clusterIP Optional \u00b6 public readonly clusterIP : string ; Type: string Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies externalIPs Optional \u00b6 public readonly externalIPs : string []; Type: string [] Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. externalName Optional \u00b6 public readonly externalName : string ; Type: string Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. loadBalancerSourceRanges Optional \u00b6 public readonly loadBalancerSourceRanges : string []; Type: string [] A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 public readonly ports : ServicePort []; Type: cdk8s-plus-20.ServicePort [] The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 public readonly type : ServiceType ; Type: cdk8s-plus-20.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types StatefulSetProps \u00b6 Properties for initialization of StatefulSet . Initializer \u00b6 import { StatefulSetProps } from 'cdk8s-plus-20' const statefulSetProps : StatefulSetProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-20.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-20.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-20.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-20.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata. service Required \u00b6 public readonly service : Service ; Type: cdk8s-plus-20.Service Service to associate with the statefulset. defaultSelector Optional \u00b6 public readonly defaultSelector : boolean ; Type: boolean Default: true Automatically allocates a pod selector for this statefulset. If this is set to false you must define your selector through statefulset.podMetadata.addLabel() and statefulset.selectByLabel() . podManagementPolicy Optional \u00b6 public readonly podManagementPolicy : PodManagementPolicy ; Type: cdk8s-plus-20.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 public readonly replicas : number ; Type: number Default: 1 Number of desired pods. VolumeMount \u00b6 Mount a volume from the pod to the container. Initializer \u00b6 import { VolumeMount } from 'cdk8s-plus-20' const volumeMount : VolumeMount = { ... } propagation Optional \u00b6 public readonly propagation : MountPropagation ; Type: cdk8s-plus-20.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. This field is beta in 1.10. readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public readonly subPath : string ; Type: string Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public readonly subPathExpr : string ; Type: string Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). SubPathExpr and SubPath are mutually exclusive. This field is beta in 1.15. subPathExpr and subPath are mutually exclusive. This field is beta in 1.15. path Required \u00b6 public readonly path : string ; Type: string Path within the container at which the volume should be mounted. Must not contain \u2018:\u2019. volume Required \u00b6 public readonly volume : Volume ; Type: cdk8s-plus-20.Volume The volume to mount. Classes \u00b6 Container \u00b6 A single application container that you want to run within a pod. Initializers \u00b6 import { Container } from 'cdk8s-plus-20' new Container ( props : ContainerProps ) props Required \u00b6 Type: cdk8s-plus-20.ContainerProps Methods \u00b6 addEnv \u00b6 public addEnv ( name : string , value : EnvValue ) name Required \u00b6 Type: string The variable name. value Required \u00b6 Type: cdk8s-plus-20.EnvValue The variable value. mount \u00b6 public mount ( path : string , volume : Volume , options? : MountOptions ) path Required \u00b6 Type: string The desired path in the container. volume Required \u00b6 Type: cdk8s-plus-20.Volume The volume to mount. options Optional \u00b6 Type: cdk8s-plus-20.MountOptions Properties \u00b6 env Required \u00b6 public readonly env : {[ key : string ] : EnvValue }; Type: {[ key: string ]: cdk8s-plus-20.EnvValue } The environment variables for this container. Returns a copy. To add environment variables use addEnv() . image Required \u00b6 public readonly image : string ; Type: string The container image. imagePullPolicy Required \u00b6 public readonly imagePullPolicy : ImagePullPolicy ; Type: cdk8s-plus-20.ImagePullPolicy Image pull policy for this container. mounts Required \u00b6 public readonly mounts : VolumeMount []; Type: cdk8s-plus-20.VolumeMount [] Volume mounts configured for this container. name Required \u00b6 public readonly name : string ; Type: string The name of the container. args Optional \u00b6 public readonly args : string []; Type: string [] Arguments to the entrypoint. command Optional \u00b6 public readonly command : string []; Type: string [] Entrypoint array (the command to execute when the container starts). port Optional \u00b6 public readonly port : number ; Type: number The port this container exposes. workingDir Optional \u00b6 public readonly workingDir : string ; Type: string The working directory inside the container. EnvValue \u00b6 Utility class for creating reading env values from various sources. Static Functions \u00b6 fromConfigMap \u00b6 import { EnvValue } from 'cdk8s-plus-20' EnvValue . fromConfigMap ( configMap : IConfigMap , key : string , options? : EnvValueFromConfigMapOptions ) configMap Required \u00b6 Type: cdk8s-plus-20.IConfigMap The config map. key Required \u00b6 Type: string The key to extract the value from. options Optional \u00b6 Type: cdk8s-plus-20.EnvValueFromConfigMapOptions Additional options. fromProcess \u00b6 import { EnvValue } from 'cdk8s-plus-20' EnvValue . fromProcess ( key : string , options? : EnvValueFromProcessOptions ) key Required \u00b6 Type: string The key to read. options Optional \u00b6 Type: cdk8s-plus-20.EnvValueFromProcessOptions Additional options. fromSecretValue \u00b6 import { EnvValue } from 'cdk8s-plus-20' EnvValue . fromSecretValue ( secretValue : SecretValue , options? : EnvValueFromSecretOptions ) secretValue Required \u00b6 Type: cdk8s-plus-20.SecretValue The secret value (secrent + key). options Optional \u00b6 Type: cdk8s-plus-20.EnvValueFromSecretOptions Additional options. fromValue \u00b6 import { EnvValue } from 'cdk8s-plus-20' EnvValue . fromValue ( value : string ) value Required \u00b6 Type: string The value. Properties \u00b6 value Optional \u00b6 public readonly value : any ; Type: any valueFrom Optional \u00b6 public readonly valueFrom : any ; Type: any IngressV1Beta1Backend \u00b6 The backend for an ingress path. Static Functions \u00b6 fromService \u00b6 import { IngressV1Beta1Backend } from 'cdk8s-plus-20' IngressV1Beta1Backend . fromService ( service : Service , options? : ServiceIngressV1BetaBackendOptions ) service Required \u00b6 Type: cdk8s-plus-20.Service The service object. options Optional \u00b6 Type: cdk8s-plus-20.ServiceIngressV1BetaBackendOptions PodSpec \u00b6 Implements: cdk8s-plus-20.IPodSpec Provides read/write capabilities ontop of a PodSpecProps . Initializers \u00b6 import { PodSpec } from 'cdk8s-plus-20' new PodSpec ( props? : PodSpecProps ) props Optional \u00b6 Type: cdk8s-plus-20.PodSpecProps Methods \u00b6 addContainer \u00b6 public addContainer ( container : ContainerProps ) container Required \u00b6 Type: cdk8s-plus-20.ContainerProps addVolume \u00b6 public addVolume ( volume : Volume ) volume Required \u00b6 Type: cdk8s-plus-20.Volume Properties \u00b6 containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-20.Container [] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-20.Volume [] The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-20.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-20.IServiceAccount The service account used to run this pod. PodTemplate \u00b6 Implements: cdk8s-plus-20.IPodTemplate Provides read/write capabilities ontop of a PodTemplateProps . Initializers \u00b6 import { PodTemplate } from 'cdk8s-plus-20' new PodTemplate ( props? : PodTemplateProps ) props Optional \u00b6 Type: cdk8s-plus-20.PodTemplateProps Properties \u00b6 podMetadata Required \u00b6 public readonly podMetadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. Probe \u00b6 Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic. Initializers \u00b6 import { Probe } from 'cdk8s-plus-20' new Probe () Static Functions \u00b6 fromCommand \u00b6 import { Probe } from 'cdk8s-plus-20' Probe . fromCommand ( command : string [], options? : CommandProbeOptions ) command Required \u00b6 Type: string [] The command to execute. options Optional \u00b6 Type: cdk8s-plus-20.CommandProbeOptions Options. fromHttpGet \u00b6 import { Probe } from 'cdk8s-plus-20' Probe . fromHttpGet ( path : string , options? : HttpGetProbeOptions ) path Required \u00b6 Type: string The URL path to hit. options Optional \u00b6 Type: cdk8s-plus-20.HttpGetProbeOptions Options. Volume \u00b6 Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes Initializers \u00b6 import { Volume } from 'cdk8s-plus-20' new Volume ( name : string , config : any ) name Required \u00b6 Type: string config Required \u00b6 Type: any Static Functions \u00b6 fromConfigMap \u00b6 import { Volume } from 'cdk8s-plus-20' Volume . fromConfigMap ( configMap : IConfigMap , options? : ConfigMapVolumeOptions ) configMap Required \u00b6 Type: cdk8s-plus-20.IConfigMap The config map to use to populate the volume. options Optional \u00b6 Type: cdk8s-plus-20.ConfigMapVolumeOptions Options. fromEmptyDir \u00b6 import { Volume } from 'cdk8s-plus-20' Volume . fromEmptyDir ( name : string , options? : EmptyDirVolumeOptions ) name Required \u00b6 Type: string options Optional \u00b6 Type: cdk8s-plus-20.EmptyDirVolumeOptions Additional options. Properties \u00b6 name Required \u00b6 public readonly name : string ; Type: string Protocols \u00b6 IConfigMap \u00b6 Extends: cdk8s-plus-20.IResource Implemented By: cdk8s-plus-20.ConfigMap , cdk8s-plus-20.IConfigMap Represents a config map. Properties \u00b6 name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IPodSpec \u00b6 Implemented By: cdk8s-plus-20.Deployment , cdk8s-plus-20.Job , cdk8s-plus-20.Pod , cdk8s-plus-20.PodSpec , cdk8s-plus-20.PodTemplate , cdk8s-plus-20.StatefulSet , cdk8s-plus-20.IPodSpec , cdk8s-plus-20.IPodTemplate Represents a resource that can be configured with a kuberenets pod spec. (e.g Deployment , Job , Pod , \u2026). Use the PodSpec class as an implementation helper. Methods \u00b6 addContainer \u00b6 public addContainer ( container : ContainerProps ) container Required \u00b6 Type: cdk8s-plus-20.ContainerProps The container. addVolume \u00b6 public addVolume ( volume : Volume ) volume Required \u00b6 Type: cdk8s-plus-20.Volume The volume. Properties \u00b6 containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-20.Container [] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-20.Volume [] The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-20.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-20.IServiceAccount The service account used to run this pod. IPodTemplate \u00b6 Extends: cdk8s-plus-20.IPodSpec Implemented By: cdk8s-plus-20.Deployment , cdk8s-plus-20.Job , cdk8s-plus-20.PodTemplate , cdk8s-plus-20.StatefulSet , cdk8s-plus-20.IPodTemplate Represents a resource that can be configured with a kuberenets pod template. (e.g Deployment , Job , \u2026). Use the PodTemplate class as an implementation helper. Properties \u00b6 containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-20.Container [] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-20.Volume [] The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-20.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-20.IServiceAccount The service account used to run this pod. podMetadata Required \u00b6 public readonly podMetadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. IResource \u00b6 Implemented By: cdk8s-plus-20.ConfigMap , cdk8s-plus-20.Deployment , cdk8s-plus-20.IngressV1Beta1 , cdk8s-plus-20.Job , cdk8s-plus-20.Pod , cdk8s-plus-20.Resource , cdk8s-plus-20.Secret , cdk8s-plus-20.Service , cdk8s-plus-20.ServiceAccount , cdk8s-plus-20.StatefulSet , cdk8s-plus-20.IConfigMap , cdk8s-plus-20.IResource , cdk8s-plus-20.ISecret , cdk8s-plus-20.IServiceAccount Represents a resource. Properties \u00b6 name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. ISecret \u00b6 Extends: cdk8s-plus-20.IResource Implemented By: cdk8s-plus-20.Secret , cdk8s-plus-20.ISecret Properties \u00b6 name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IServiceAccount \u00b6 Extends: cdk8s-plus-20.IResource Implemented By: cdk8s-plus-20.ServiceAccount , cdk8s-plus-20.IServiceAccount Properties \u00b6 name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. Enums \u00b6 EmptyDirMedium \u00b6 The medium on which to store the volume. DEFAULT \u00b6 The default volume of the backing node. MEMORY \u00b6 Mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. ImagePullPolicy \u00b6 ALWAYS \u00b6 Every time the kubelet launches a container, the kubelet queries the container image registry to resolve the name to an image digest. If the kubelet has a container image with that exact digest cached locally, the kubelet uses its cached image; otherwise, the kubelet downloads (pulls) the image with the resolved digest, and uses that image to launch the container. Default is Always if ImagePullPolicy is omitted and either the image tag is :latest or the image tag is omitted. IF_NOT_PRESENT \u00b6 The image is pulled only if it is not already present locally. Default is IfNotPresent if ImagePullPolicy is omitted and the image tag is present but not :latest NEVER \u00b6 The image is assumed to exist locally. No attempt is made to pull the image. MountPropagation \u00b6 NONE \u00b6 This volume mount will not receive any subsequent mounts that are mounted to this volume or any of its subdirectories by the host. In similar fashion, no mounts created by the Container will be visible on the host. This is the default mode. This mode is equal to private mount propagation as described in the Linux kernel documentation HOST_TO_CONTAINER \u00b6 This volume mount will receive all subsequent mounts that are mounted to this volume or any of its subdirectories. In other words, if the host mounts anything inside the volume mount, the Container will see it mounted there. Similarly, if any Pod with Bidirectional mount propagation to the same volume mounts anything there, the Container with HostToContainer mount propagation will see it. This mode is equal to rslave mount propagation as described in the Linux kernel documentation BIDIRECTIONAL \u00b6 This volume mount behaves the same the HostToContainer mount. In addition, all volume mounts created by the Container will be propagated back to the host and to all Containers of all Pods that use the same volume A typical use case for this mode is a Pod with a FlexVolume or CSI driver or a Pod that needs to mount something on the host using a hostPath volume. This mode is equal to rshared mount propagation as described in the Linux kernel documentation Caution: Bidirectional mount propagation can be dangerous. It can damage the host operating system and therefore it is allowed only in privileged Containers. Familiarity with Linux kernel behavior is strongly recommended. In addition, any volume mounts created by Containers in Pods must be destroyed (unmounted) by the Containers on termination. PodManagementPolicy \u00b6 Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once. ORDERED_READY \u00b6 PARALLEL \u00b6 Protocol \u00b6 TCP \u00b6 UDP \u00b6 SCTP \u00b6 RestartPolicy \u00b6 Restart policy for all containers within the pod. ALWAYS \u00b6 Always restart the pod after it exits. ON_FAILURE \u00b6 Only restart if the pod exits with a non-zero exit code. NEVER \u00b6 Never restart the pod. ServiceType \u00b6 For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP. CLUSTER_IP \u00b6 Exposes the Service on a cluster-internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default ServiceType NODE_PORT \u00b6 Exposes the Service on each Node\u2019s IP at a static port (the NodePort). A ClusterIP Service, to which the NodePort Service routes, is automatically created. You\u2019ll be able to contact the NodePort Service, from outside the cluster, by requesting : . LOAD_BALANCER \u00b6 Exposes the Service externally using a cloud provider\u2019s load balancer. NodePort and ClusterIP Services, to which the external load balancer routes, are automatically created. EXTERNAL_NAME \u00b6 Maps the Service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value. No proxying of any kind is set up. Note: You need either kube-dns version 1.7 or CoreDNS version 0.0.8 or higher to use the ExternalName type.","title":"TypeScript"},{"location":"reference/cdk8s-plus-20/typescript/#cdk8s-plus-20-typescript","text":"","title":"cdk8s-plus-20 (TypeScript) "},{"location":"reference/cdk8s-plus-20/typescript/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s-plus-20/typescript/#configmap","text":"Implements: cdk8s-plus-20.IConfigMap ConfigMap holds configuration data for pods to consume.","title":"ConfigMap "},{"location":"reference/cdk8s-plus-20/typescript/#deployment","text":"Implements: cdk8s-plus-20.IPodTemplate A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below.","title":"Deployment "},{"location":"reference/cdk8s-plus-20/typescript/#use-case","text":"The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore.","title":"Use Case"},{"location":"reference/cdk8s-plus-20/typescript/#ingressv1beta1","text":"Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.","title":"IngressV1Beta1 "},{"location":"reference/cdk8s-plus-20/typescript/#job","text":"Implements: cdk8s-plus-20.IPodTemplate A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel.","title":"Job "},{"location":"reference/cdk8s-plus-20/typescript/#pod","text":"Implements: cdk8s-plus-20.IPodSpec Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.","title":"Pod "},{"location":"reference/cdk8s-plus-20/typescript/#resource","text":"Implements: cdk8s-plus-20.IResource Base class for all Kubernetes objects in stdk8s. Represents a single resource.","title":"Resource "},{"location":"reference/cdk8s-plus-20/typescript/#secret","text":"Implements: cdk8s-plus-20.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret","title":"Secret "},{"location":"reference/cdk8s-plus-20/typescript/#service","text":"An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods.","title":"Service "},{"location":"reference/cdk8s-plus-20/typescript/#serviceaccount","text":"Implements: cdk8s-plus-20.IServiceAccount A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account","title":"ServiceAccount "},{"location":"reference/cdk8s-plus-20/typescript/#statefulset","text":"Implements: cdk8s-plus-20.IPodTemplate StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed.","title":"StatefulSet "},{"location":"reference/cdk8s-plus-20/typescript/#using-statefulsets","text":"StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates.","title":"Using StatefulSets"},{"location":"reference/cdk8s-plus-20/typescript/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s-plus-20/typescript/#adddeploymentoptions","text":"Options to add a deployment to a service.","title":"AddDeploymentOptions "},{"location":"reference/cdk8s-plus-20/typescript/#adddirectoryoptions","text":"Options for configmap.addDirectory() .","title":"AddDirectoryOptions "},{"location":"reference/cdk8s-plus-20/typescript/#commandprobeoptions","text":"Options for Probe.fromCommand() .","title":"CommandProbeOptions "},{"location":"reference/cdk8s-plus-20/typescript/#configmapprops","text":"Properties for initialization of ConfigMap .","title":"ConfigMapProps "},{"location":"reference/cdk8s-plus-20/typescript/#configmapvolumeoptions","text":"Options for the ConfigMap-based volume.","title":"ConfigMapVolumeOptions "},{"location":"reference/cdk8s-plus-20/typescript/#containerprops","text":"Properties for creating a container.","title":"ContainerProps "},{"location":"reference/cdk8s-plus-20/typescript/#deploymentprops","text":"Properties for initialization of Deployment .","title":"DeploymentProps "},{"location":"reference/cdk8s-plus-20/typescript/#emptydirvolumeoptions","text":"Options for volumes populated with an empty directory.","title":"EmptyDirVolumeOptions "},{"location":"reference/cdk8s-plus-20/typescript/#envvaluefromconfigmapoptions","text":"Options to specify an envionment variable value from a ConfigMap key.","title":"EnvValueFromConfigMapOptions "},{"location":"reference/cdk8s-plus-20/typescript/#envvaluefromprocessoptions","text":"Options to specify an environment variable value from the process environment.","title":"EnvValueFromProcessOptions "},{"location":"reference/cdk8s-plus-20/typescript/#envvaluefromsecretoptions","text":"Options to specify an environment variable value from a Secret.","title":"EnvValueFromSecretOptions "},{"location":"reference/cdk8s-plus-20/typescript/#exposedeploymentviaingressoptions","text":"Options for exposing a deployment via an ingress.","title":"ExposeDeploymentViaIngressOptions "},{"location":"reference/cdk8s-plus-20/typescript/#exposedeploymentviaserviceoptions","text":"Options for exposing a deployment via a service.","title":"ExposeDeploymentViaServiceOptions "},{"location":"reference/cdk8s-plus-20/typescript/#exposeserviceviaingressoptions","text":"Options for exposing a service using an ingress.","title":"ExposeServiceViaIngressOptions "},{"location":"reference/cdk8s-plus-20/typescript/#httpgetprobeoptions","text":"Options for Probe.fromHttpGet() .","title":"HttpGetProbeOptions "},{"location":"reference/cdk8s-plus-20/typescript/#ingressv1beta1props","text":"Properties for Ingress .","title":"IngressV1Beta1Props "},{"location":"reference/cdk8s-plus-20/typescript/#ingressv1beta1rule","text":"Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path.","title":"IngressV1Beta1Rule "},{"location":"reference/cdk8s-plus-20/typescript/#ingressv1beta1tls","text":"Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination.","title":"IngressV1Beta1Tls "},{"location":"reference/cdk8s-plus-20/typescript/#jobprops","text":"Properties for initialization of Job .","title":"JobProps "},{"location":"reference/cdk8s-plus-20/typescript/#mountoptions","text":"Options for mounts.","title":"MountOptions "},{"location":"reference/cdk8s-plus-20/typescript/#pathmapping","text":"Maps a string key to a path within a volume.","title":"PathMapping "},{"location":"reference/cdk8s-plus-20/typescript/#podprops","text":"Properties for initialization of Pod .","title":"PodProps "},{"location":"reference/cdk8s-plus-20/typescript/#podspecprops","text":"Properties of a PodSpec .","title":"PodSpecProps "},{"location":"reference/cdk8s-plus-20/typescript/#podtemplateprops","text":"Properties of a PodTemplate . Adds metadata information on top of the spec.","title":"PodTemplateProps "},{"location":"reference/cdk8s-plus-20/typescript/#probeoptions","text":"Probe options.","title":"ProbeOptions "},{"location":"reference/cdk8s-plus-20/typescript/#resourceprops","text":"Initialization properties for resources.","title":"ResourceProps "},{"location":"reference/cdk8s-plus-20/typescript/#secretprops","text":"","title":"SecretProps "},{"location":"reference/cdk8s-plus-20/typescript/#secretvalue","text":"Represents a specific value in JSON secret.","title":"SecretValue "},{"location":"reference/cdk8s-plus-20/typescript/#serviceaccountprops","text":"Properties for initialization of ServiceAccount . Properties for initialization of ServiceAccount .","title":"ServiceAccountProps "},{"location":"reference/cdk8s-plus-20/typescript/#serviceingressv1betabackendoptions","text":"Options for setting up backends for ingress rules.","title":"ServiceIngressV1BetaBackendOptions "},{"location":"reference/cdk8s-plus-20/typescript/#serviceport","text":"Definition of a service port.","title":"ServicePort "},{"location":"reference/cdk8s-plus-20/typescript/#serviceportoptions","text":"","title":"ServicePortOptions "},{"location":"reference/cdk8s-plus-20/typescript/#serviceprops","text":"Properties for initialization of Service .","title":"ServiceProps "},{"location":"reference/cdk8s-plus-20/typescript/#statefulsetprops","text":"Properties for initialization of StatefulSet .","title":"StatefulSetProps "},{"location":"reference/cdk8s-plus-20/typescript/#volumemount","text":"Mount a volume from the pod to the container.","title":"VolumeMount "},{"location":"reference/cdk8s-plus-20/typescript/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s-plus-20/typescript/#container","text":"A single application container that you want to run within a pod.","title":"Container "},{"location":"reference/cdk8s-plus-20/typescript/#envvalue","text":"Utility class for creating reading env values from various sources.","title":"EnvValue "},{"location":"reference/cdk8s-plus-20/typescript/#ingressv1beta1backend","text":"The backend for an ingress path.","title":"IngressV1Beta1Backend "},{"location":"reference/cdk8s-plus-20/typescript/#podspec","text":"Implements: cdk8s-plus-20.IPodSpec Provides read/write capabilities ontop of a PodSpecProps .","title":"PodSpec "},{"location":"reference/cdk8s-plus-20/typescript/#podtemplate","text":"Implements: cdk8s-plus-20.IPodTemplate Provides read/write capabilities ontop of a PodTemplateProps .","title":"PodTemplate "},{"location":"reference/cdk8s-plus-20/typescript/#probe","text":"Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.","title":"Probe "},{"location":"reference/cdk8s-plus-20/typescript/#volume","text":"Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes","title":"Volume "},{"location":"reference/cdk8s-plus-20/typescript/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s-plus-20/typescript/#iconfigmap","text":"Extends: cdk8s-plus-20.IResource Implemented By: cdk8s-plus-20.ConfigMap , cdk8s-plus-20.IConfigMap Represents a config map.","title":"IConfigMap "},{"location":"reference/cdk8s-plus-20/typescript/#ipodspec","text":"Implemented By: cdk8s-plus-20.Deployment , cdk8s-plus-20.Job , cdk8s-plus-20.Pod , cdk8s-plus-20.PodSpec , cdk8s-plus-20.PodTemplate , cdk8s-plus-20.StatefulSet , cdk8s-plus-20.IPodSpec , cdk8s-plus-20.IPodTemplate Represents a resource that can be configured with a kuberenets pod spec. (e.g Deployment , Job , Pod , \u2026). Use the PodSpec class as an implementation helper.","title":"IPodSpec "},{"location":"reference/cdk8s-plus-20/typescript/#ipodtemplate","text":"Extends: cdk8s-plus-20.IPodSpec Implemented By: cdk8s-plus-20.Deployment , cdk8s-plus-20.Job , cdk8s-plus-20.PodTemplate , cdk8s-plus-20.StatefulSet , cdk8s-plus-20.IPodTemplate Represents a resource that can be configured with a kuberenets pod template. (e.g Deployment , Job , \u2026). Use the PodTemplate class as an implementation helper.","title":"IPodTemplate "},{"location":"reference/cdk8s-plus-20/typescript/#iresource","text":"Implemented By: cdk8s-plus-20.ConfigMap , cdk8s-plus-20.Deployment , cdk8s-plus-20.IngressV1Beta1 , cdk8s-plus-20.Job , cdk8s-plus-20.Pod , cdk8s-plus-20.Resource , cdk8s-plus-20.Secret , cdk8s-plus-20.Service , cdk8s-plus-20.ServiceAccount , cdk8s-plus-20.StatefulSet , cdk8s-plus-20.IConfigMap , cdk8s-plus-20.IResource , cdk8s-plus-20.ISecret , cdk8s-plus-20.IServiceAccount Represents a resource.","title":"IResource "},{"location":"reference/cdk8s-plus-20/typescript/#isecret","text":"Extends: cdk8s-plus-20.IResource Implemented By: cdk8s-plus-20.Secret , cdk8s-plus-20.ISecret","title":"ISecret "},{"location":"reference/cdk8s-plus-20/typescript/#iserviceaccount","text":"Extends: cdk8s-plus-20.IResource Implemented By: cdk8s-plus-20.ServiceAccount , cdk8s-plus-20.IServiceAccount","title":"IServiceAccount "},{"location":"reference/cdk8s-plus-20/typescript/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s-plus-20/typescript/#emptydirmedium","text":"The medium on which to store the volume.","title":"EmptyDirMedium "},{"location":"reference/cdk8s-plus-20/typescript/#imagepullpolicy","text":"","title":"ImagePullPolicy "},{"location":"reference/cdk8s-plus-20/typescript/#mountpropagation","text":"","title":"MountPropagation "},{"location":"reference/cdk8s-plus-20/typescript/#podmanagementpolicy","text":"Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.","title":"PodManagementPolicy "},{"location":"reference/cdk8s-plus-20/typescript/#protocol","text":"","title":"Protocol "},{"location":"reference/cdk8s-plus-20/typescript/#restartpolicy","text":"Restart policy for all containers within the pod.","title":"RestartPolicy "},{"location":"reference/cdk8s-plus-20/typescript/#servicetype","text":"For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP.","title":"ServiceType "},{"location":"reference/cdk8s-plus-21/go/","text":"cdk8s-plus-21 (Go) \u00b6 For Go API reference, please visit https://pkg.go.dev/github.com/cdk8s-team/cdk8s-plus-go/cdk8splus21 .","title":"Go"},{"location":"reference/cdk8s-plus-21/go/#cdk8s-plus-21-go","text":"For Go API reference, please visit https://pkg.go.dev/github.com/cdk8s-team/cdk8s-plus-go/cdk8splus21 .","title":"cdk8s-plus-21 (Go) "},{"location":"reference/cdk8s-plus-21/java/","text":"cdk8s-plus-21 (Java) \u00b6 Constructs \u00b6 ConfigMap \u00b6 Implements: org.cdk8s.plus21.IConfigMap ConfigMap holds configuration data for pods to consume. Initializers \u00b6 import org.cdk8s.plus21.ConfigMap ; ConfigMap . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .binaryData(java.util.Map<java.lang.String, java.lang.String>) // .data(java.util.Map<java.lang.String, java.lang.String>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binaryData Optional \u00b6 Type: java.util.Map java.lang.String > BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. Using this field will require 1.10+ apiserver and kubelet. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 Type: java.util.Map java.lang.String > Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . Methods \u00b6 addBinaryData \u00b6 public addBinaryData ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String The key. value Required \u00b6 Type: java.lang.String The value. addData \u00b6 public addData ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String The key. value Required \u00b6 Type: java.lang.String The value. addDirectory \u00b6 public addDirectory ( java . lang . String localDir ) public addDirectory ( java . lang . String localDir , AddDirectoryOptions options ) localDir Required \u00b6 Type: java.lang.String A path to a local directory. options Optional \u00b6 Type: org.cdk8s.plus21.AddDirectoryOptions Options. addFile \u00b6 public addFile ( java . lang . String localFile ) public addFile ( java . lang . String localFile , java . lang . String key ) localFile Required \u00b6 Type: java.lang.String The path to the local file. key Optional \u00b6 Type: java.lang.String The ConfigMap key (default to the file name). Static Functions \u00b6 fromConfigMapName \u00b6 import org.cdk8s.plus21.ConfigMap ; ConfigMap . fromConfigMapName ( java . lang . String name ) name Required \u00b6 Type: java.lang.String The name of the config map to import. Properties \u00b6 binaryData Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getBinaryData (); Type: java.util.Map java.lang.String > The binary data associated with this config map. Returns a copy. To add data records, use addBinaryData() or addData() . data Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getData (); Type: java.util.Map java.lang.String > The data associated with this config map. Returns an copy. To add data records, use addData() or addBinaryData() . Deployment \u00b6 Implements: org.cdk8s.plus21.IPodTemplate A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case \u00b6 The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore. Initializers \u00b6 import org.cdk8s.plus21.Deployment ; Deployment . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .defaultSelector(java.lang.Boolean) // .replicas(java.lang.Number) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 Type: org.cdk8s.plus21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 Type: org.cdk8s.plus21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata. defaultSelector Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod selector for this deployment. If this is set to false you must define your selector through deployment.podMetadata.addLabel() and deployment.selectByLabel() . replicas Optional \u00b6 Type: java.lang.Number Default: 1 Number of desired pods. Methods \u00b6 addContainer \u00b6 public addContainer ( ContainerProps container ) container Required \u00b6 Type: org.cdk8s.plus21.ContainerProps addVolume \u00b6 public addVolume ( Volume volume ) volume Required \u00b6 Type: org.cdk8s.plus21.Volume exposeViaIngress \u00b6 public exposeViaIngress ( java . lang . String path ) public exposeViaIngress ( java . lang . String path , ExposeDeploymentViaIngressOptions options ) path Required \u00b6 Type: java.lang.String The ingress path to register under. options Optional \u00b6 Type: org.cdk8s.plus21.ExposeDeploymentViaIngressOptions Additional options. exposeViaService \u00b6 public exposeViaService () public exposeViaService ( ExposeDeploymentViaServiceOptions options ) options Optional \u00b6 Type: org.cdk8s.plus21.ExposeDeploymentViaServiceOptions Options to determine details of the service and port exposed. selectByLabel \u00b6 public selectByLabel ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String The label key. value Required \u00b6 Type: java.lang.String The label value. Properties \u00b6 containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus21.Container > The containers belonging to the pod. Use addContainer to add containers. labelSelector Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getLabelSelector (); Type: java.util.Map java.lang.String > The labels this deployment will match against in order to select pods. Returns a a copy. Use selectByLabel() to add labels. podMetadata Required \u00b6 public ApiObjectMetadataDefinition getPodMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. replicas Required \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Number of desired pods. volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus21.Volume > The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus21.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus21.IServiceAccount The service account used to run this pod. IngressV1Beta1 \u00b6 Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. Initializers \u00b6 import org.cdk8s.plus21.IngressV1Beta1 ; IngressV1Beta1 . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .defaultBackend(IngressV1Beta1Backend) // .rules(java.util.List<IngressV1Beta1Rule>) // .tls(java.util.List<IngressV1Beta1Tls>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. defaultBackend Optional \u00b6 Type: org.cdk8s.plus21.IngressV1Beta1Backend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.IngressV1Beta1Rule > Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.IngressV1Beta1Tls > TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. Methods \u00b6 addDefaultBackend \u00b6 public addDefaultBackend ( IngressV1Beta1Backend backend ) backend Required \u00b6 Type: org.cdk8s.plus21.IngressV1Beta1Backend The backend to use for requests that do not match any rule. addHostDefaultBackend \u00b6 public addHostDefaultBackend ( java . lang . String host , IngressV1Beta1Backend backend ) host Required \u00b6 Type: java.lang.String The host name to match. backend Required \u00b6 Type: org.cdk8s.plus21.IngressV1Beta1Backend The backend to route to. addHostRule \u00b6 public addHostRule ( java . lang . String host , java . lang . String path , IngressV1Beta1Backend backend ) host Required \u00b6 Type: java.lang.String The host name. path Required \u00b6 Type: java.lang.String The HTTP path. backend Required \u00b6 Type: org.cdk8s.plus21.IngressV1Beta1Backend The backend to route requests to. addRule \u00b6 public addRule ( java . lang . String path , IngressV1Beta1Backend backend ) path Required \u00b6 Type: java.lang.String The HTTP path. backend Required \u00b6 Type: org.cdk8s.plus21.IngressV1Beta1Backend The backend to route requests to. addRules \u00b6 public addRules ( IngressV1Beta1Rule rules ) rules Required \u00b6 Type: org.cdk8s.plus21.IngressV1Beta1Rule The rules to add. addTls \u00b6 public addTls ( java . util . List < IngressV1Beta1Tls > tls ) tls Required \u00b6 Type: java.util.List< org.cdk8s.plus21.IngressV1Beta1Tls > Job \u00b6 Implements: org.cdk8s.plus21.IPodTemplate A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel. Initializers \u00b6 import org.cdk8s.plus21.Job ; Job . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .activeDeadline(Duration) // .backoffLimit(java.lang.Number) // .ttlAfterFinished(Duration) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 Type: org.cdk8s.plus21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 Type: org.cdk8s.plus21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata. activeDeadline Optional \u00b6 Type: org.cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 Type: java.lang.Number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 Type: org.cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. Methods \u00b6 addContainer \u00b6 public addContainer ( ContainerProps container ) container Required \u00b6 Type: org.cdk8s.plus21.ContainerProps addVolume \u00b6 public addVolume ( Volume volume ) volume Required \u00b6 Type: org.cdk8s.plus21.Volume Properties \u00b6 containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus21.Container > The containers belonging to the pod. Use addContainer to add containers. podMetadata Required \u00b6 public ApiObjectMetadataDefinition getPodMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus21.Volume > The volumes associated with this pod. Use addVolume to add volumes. activeDeadline Optional \u00b6 public Duration getActiveDeadline (); Type: org.cdk8s.Duration Duration before job is terminated. If undefined, there is no deadline. backoffLimit Optional \u00b6 public java . lang . Number getBackoffLimit (); Type: java.lang.Number Number of retries before marking failed. restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus21.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus21.IServiceAccount The service account used to run this pod. ttlAfterFinished Optional \u00b6 public Duration getTtlAfterFinished (); Type: org.cdk8s.Duration TTL before the job is deleted after it is finished. Pod \u00b6 Implements: org.cdk8s.plus21.IPodSpec Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts. Initializers \u00b6 import org.cdk8s.plus21.Pod ; Pod . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 Type: org.cdk8s.plus21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 Type: org.cdk8s.plus21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Methods \u00b6 addContainer \u00b6 public addContainer ( ContainerProps container ) container Required \u00b6 Type: org.cdk8s.plus21.ContainerProps addVolume \u00b6 public addVolume ( Volume volume ) volume Required \u00b6 Type: org.cdk8s.plus21.Volume Properties \u00b6 containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus21.Container > The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus21.Volume > The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus21.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus21.IServiceAccount The service account used to run this pod. Resource \u00b6 Implements: org.cdk8s.plus21.IResource Base class for all Kubernetes objects in stdk8s. Represents a single resource. Initializers \u00b6 import org.cdk8s.plus21.Resource ; Resource . Builder . create ( Construct scope , java . lang . String id ) // .nodeFactory(INodeFactory) . build (); scope Required \u00b6 Type: software.constructs.Construct The scope in which to define this construct. id Required \u00b6 Type: java.lang.String The scoped construct ID. Must be unique amongst siblings. If the ID includes a path separator ( / ), then it will be replaced by double dash -- . nodeFactory Optional \u00b6 Type: software.constructs.INodeFactory Default: the default Node is associated A factory for attaching Node s to the construct. Properties \u00b6 metadata Required \u00b6 public ApiObjectMetadataDefinition getMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this API object. Secret \u00b6 Implements: org.cdk8s.plus21.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret Initializers \u00b6 import org.cdk8s.plus21.Secret ; Secret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .stringData(java.util.Map<java.lang.String, java.lang.String>) // .type(java.lang.String) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. stringData Optional \u00b6 Type: java.util.Map java.lang.String > stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 Type: java.lang.String Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. Methods \u00b6 addStringData \u00b6 public addStringData ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String Key. value Required \u00b6 Type: java.lang.String Value. getStringData \u00b6 public getStringData ( java . lang . String key ) key Required \u00b6 Type: java.lang.String Key. Static Functions \u00b6 fromSecretName \u00b6 import org.cdk8s.plus21.Secret ; Secret . fromSecretName ( java . lang . String name ) name Required \u00b6 Type: java.lang.String The name of the secret to reference. Service \u00b6 An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods. Initializers \u00b6 import org.cdk8s.plus21.Service ; Service . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .clusterIP(java.lang.String) // .externalIPs(java.util.List<java.lang.String>) // .externalName(java.lang.String) // .loadBalancerSourceRanges(java.util.List<java.lang.String>) // .ports(java.util.List<ServicePort>) // .type(ServiceType) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. clusterIP Optional \u00b6 Type: java.lang.String Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies externalIPs Optional \u00b6 Type: java.util.List< java.lang.String > Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. externalName Optional \u00b6 Type: java.lang.String Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. loadBalancerSourceRanges Optional \u00b6 Type: java.util.List< java.lang.String > A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.ServicePort > The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 Type: org.cdk8s.plus21.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types Methods \u00b6 addDeployment \u00b6 public addDeployment ( Deployment deployment ) public addDeployment ( Deployment deployment , AddDeploymentOptions options ) deployment Required \u00b6 Type: org.cdk8s.plus21.Deployment The deployment to expose. options Optional \u00b6 Type: org.cdk8s.plus21.AddDeploymentOptions Optional settings for the port. addSelector \u00b6 public addSelector ( java . lang . String label , java . lang . String value ) label Required \u00b6 Type: java.lang.String The label key. value Required \u00b6 Type: java.lang.String The label value. exposeViaIngress \u00b6 public exposeViaIngress ( java . lang . String path ) public exposeViaIngress ( java . lang . String path , ExposeServiceViaIngressOptions options ) path Required \u00b6 Type: java.lang.String The path to expose the service under. options Optional \u00b6 Type: org.cdk8s.plus21.ExposeServiceViaIngressOptions Additional options. serve \u00b6 public serve ( java . lang . Number port ) public serve ( java . lang . Number port , ServicePortOptions options ) port Required \u00b6 Type: java.lang.Number The port definition. options Optional \u00b6 Type: org.cdk8s.plus21.ServicePortOptions Properties \u00b6 ports Required \u00b6 public java . util . List < ServicePort > getPorts (); Type: java.util.List< org.cdk8s.plus21.ServicePort > Ports for this service. Use serve() to expose additional service ports. selector Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getSelector (); Type: java.util.Map java.lang.String > Returns the labels which are used to select pods for this service. type Required \u00b6 public ServiceType getType (); Type: org.cdk8s.plus21.ServiceType Determines how the Service is exposed. clusterIP Optional \u00b6 public java . lang . String getClusterIP (); Type: java.lang.String The IP address of the service and is usually assigned randomly by the master. externalName Optional \u00b6 public java . lang . String getExternalName (); Type: java.lang.String The externalName to be used for EXTERNAL_NAME types. ServiceAccount \u00b6 Implements: org.cdk8s.plus21.IServiceAccount A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account Initializers \u00b6 import org.cdk8s.plus21.ServiceAccount ; ServiceAccount . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .secrets(java.util.List<ISecret>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. secrets Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.ISecret > List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret Methods \u00b6 addSecret \u00b6 public addSecret ( ISecret secret ) secret Required \u00b6 Type: org.cdk8s.plus21.ISecret The secret. Static Functions \u00b6 fromServiceAccountName \u00b6 import org.cdk8s.plus21.ServiceAccount ; ServiceAccount . fromServiceAccountName ( java . lang . String name ) name Required \u00b6 Type: java.lang.String The name of the service account resource. Properties \u00b6 secrets Required \u00b6 public java . util . List < ISecret > getSecrets (); Type: java.util.List< org.cdk8s.plus21.ISecret > List of secrets allowed to be used by pods running using this service account. Returns a copy. To add a secret, use addSecret() . StatefulSet \u00b6 Implements: org.cdk8s.plus21.IPodTemplate StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed. Using StatefulSets \u00b6 StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates. Initializers \u00b6 import org.cdk8s.plus21.StatefulSet ; StatefulSet . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) . service ( Service ) // .defaultSelector(java.lang.Boolean) // .podManagementPolicy(PodManagementPolicy) // .replicas(java.lang.Number) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 Type: org.cdk8s.plus21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 Type: org.cdk8s.plus21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata. service Required \u00b6 Type: org.cdk8s.plus21.Service Service to associate with the statefulset. defaultSelector Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod selector for this statefulset. If this is set to false you must define your selector through statefulset.podMetadata.addLabel() and statefulset.selectByLabel() . podManagementPolicy Optional \u00b6 Type: org.cdk8s.plus21.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 Type: java.lang.Number Default: 1 Number of desired pods. Methods \u00b6 addContainer \u00b6 public addContainer ( ContainerProps container ) container Required \u00b6 Type: org.cdk8s.plus21.ContainerProps addVolume \u00b6 public addVolume ( Volume volume ) volume Required \u00b6 Type: org.cdk8s.plus21.Volume selectByLabel \u00b6 public selectByLabel ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String The label key. value Required \u00b6 Type: java.lang.String The label value. Properties \u00b6 containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus21.Container > The containers belonging to the pod. Use addContainer to add containers. labelSelector Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getLabelSelector (); Type: java.util.Map java.lang.String > The labels this statefulset will match against in order to select pods. Returns a a copy. Use selectByLabel() to add labels. podManagementPolicy Required \u00b6 public PodManagementPolicy getPodManagementPolicy (); Type: org.cdk8s.plus21.PodManagementPolicy Management policy to use for the set. podMetadata Required \u00b6 public ApiObjectMetadataDefinition getPodMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. replicas Required \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Number of desired pods. volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus21.Volume > The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus21.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus21.IServiceAccount The service account used to run this pod. Structs \u00b6 AddDeploymentOptions \u00b6 Options to add a deployment to a service. Initializer \u00b6 import org.cdk8s.plus21.AddDeploymentOptions ; AddDeploymentOptions . builder () // .name(java.lang.String) // .nodePort(java.lang.Number) // .protocol(Protocol) // .targetPort(java.lang.Number) // .port(java.lang.Number) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public java . lang . Number getNodePort (); Type: java.lang.Number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus21.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The value of port will be used. The port number the service will redirect to. port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: Copied from the first container of the deployment. The port number the service will bind to. AddDirectoryOptions \u00b6 Options for configmap.addDirectory() . Initializer \u00b6 import org.cdk8s.plus21.AddDirectoryOptions ; AddDirectoryOptions . builder () // .exclude(java.util.List<java.lang.String>) // .keyPrefix(java.lang.String) . build (); exclude Optional \u00b6 public java . util . List < java . lang . String > getExclude (); Type: java.util.List< java.lang.String > Default: include all files Glob patterns to exclude when adding files. keyPrefix Optional \u00b6 public java . lang . String getKeyPrefix (); Type: java.lang.String Default: \u201c\u201d A prefix to add to all keys in the config map. CommandProbeOptions \u00b6 Options for Probe.fromCommand() . Initializer \u00b6 import org.cdk8s.plus21.CommandProbeOptions ; CommandProbeOptions . builder () // .failureThreshold(java.lang.Number) // .initialDelaySeconds(Duration) // .periodSeconds(Duration) // .successThreshold(java.lang.Number) // .timeoutSeconds(Duration) . build (); failureThreshold Optional \u00b6 public java . lang . Number getFailureThreshold (); Type: java.lang.Number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public Duration getInitialDelaySeconds (); Type: org.cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public Duration getPeriodSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public java . lang . Number getSuccessThreshold (); Type: java.lang.Number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public Duration getTimeoutSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ConfigMapProps \u00b6 Properties for initialization of ConfigMap . Initializer \u00b6 import org.cdk8s.plus21.ConfigMapProps ; ConfigMapProps . builder () // .metadata(ApiObjectMetadata) // .binaryData(java.util.Map<java.lang.String, java.lang.String>) // .data(java.util.Map<java.lang.String, java.lang.String>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binaryData Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getBinaryData (); Type: java.util.Map java.lang.String > BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. Using this field will require 1.10+ apiserver and kubelet. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getData (); Type: java.util.Map java.lang.String > Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . ConfigMapVolumeOptions \u00b6 Options for the ConfigMap-based volume. Initializer \u00b6 import org.cdk8s.plus21.ConfigMapVolumeOptions ; ConfigMapVolumeOptions . builder () // .defaultMode(java.lang.Number) // .items(java.util.Map<java.lang.String, PathMapping>) // .name(java.lang.String) // .optional(java.lang.Boolean) . build (); defaultMode Optional \u00b6 public java . lang . Number getDefaultMode (); Type: java.lang.Number Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 public java . util . Map < java . lang . String , PathMapping > getItems (); Type: java.util.Map \u0002klzzwxh:3315\u0003 > Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto-generated The volume name. optional Optional \u00b6 public java . lang . Boolean getOptional (); Type: java.lang.Boolean Default: undocumented Specify whether the ConfigMap or its keys must be defined. ContainerProps \u00b6 Properties for creating a container. Initializer \u00b6 import org.cdk8s.plus21.ContainerProps ; ContainerProps . builder () . image ( java . lang . String ) // .args(java.util.List<java.lang.String>) // .command(java.util.List<java.lang.String>) // .env(java.util.Map<java.lang.String, EnvValue>) // .imagePullPolicy(ImagePullPolicy) // .liveness(Probe) // .name(java.lang.String) // .port(java.lang.Number) // .readiness(Probe) // .startup(Probe) // .volumeMounts(java.util.List<VolumeMount>) // .workingDir(java.lang.String) . build (); image Required \u00b6 public java . lang . String getImage (); Type: java.lang.String Docker image name. args Optional \u00b6 public java . util . List < java . lang . String > getArgs (); Type: java.util.List< java.lang.String > Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 public java . util . List < java . lang . String > getCommand (); Type: java.util.List< java.lang.String > Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 public java . util . Map < java . lang . String , EnvValue > getEnv (); Type: java.util.Map \u0002klzzwxh:3296\u0003 > Default: No environment variables. List of environment variables to set in the container. Cannot be updated. imagePullPolicy Optional \u00b6 public ImagePullPolicy getImagePullPolicy (); Type: org.cdk8s.plus21.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 public Probe getLiveness (); Type: org.cdk8s.plus21.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 public Probe getReadiness (); Type: org.cdk8s.plus21.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 public Probe getStartup (); Type: org.cdk8s.plus21.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volumeMounts Optional \u00b6 public java . util . List < VolumeMount > getVolumeMounts (); Type: java.util.List< org.cdk8s.plus21.VolumeMount > Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. workingDir Optional \u00b6 public java . lang . String getWorkingDir (); Type: java.lang.String Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. DeploymentProps \u00b6 Properties for initialization of Deployment . Initializer \u00b6 import org.cdk8s.plus21.DeploymentProps ; DeploymentProps . builder () // .metadata(ApiObjectMetadata) // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .defaultSelector(java.lang.Boolean) // .replicas(java.lang.Number) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus21.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus21.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata. defaultSelector Optional \u00b6 public java . lang . Boolean getDefaultSelector (); Type: java.lang.Boolean Default: true Automatically allocates a pod selector for this deployment. If this is set to false you must define your selector through deployment.podMetadata.addLabel() and deployment.selectByLabel() . replicas Optional \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Default: 1 Number of desired pods. EmptyDirVolumeOptions \u00b6 Options for volumes populated with an empty directory. Initializer \u00b6 import org.cdk8s.plus21.EmptyDirVolumeOptions ; EmptyDirVolumeOptions . builder () // .medium(EmptyDirMedium) // .sizeLimit(Size) . build (); medium Optional \u00b6 public EmptyDirMedium getMedium (); Type: org.cdk8s.plus21.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. sizeLimit Optional \u00b6 public Size getSizeLimit (); Type: org.cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. EnvValueFromConfigMapOptions \u00b6 Options to specify an envionment variable value from a ConfigMap key. Initializer \u00b6 import org.cdk8s.plus21.EnvValueFromConfigMapOptions ; EnvValueFromConfigMapOptions . builder () // .optional(java.lang.Boolean) . build (); optional Optional \u00b6 public java . lang . Boolean getOptional (); Type: java.lang.Boolean Default: false Specify whether the ConfigMap or its key must be defined. EnvValueFromProcessOptions \u00b6 Options to specify an environment variable value from the process environment. Initializer \u00b6 import org.cdk8s.plus21.EnvValueFromProcessOptions ; EnvValueFromProcessOptions . builder () // .required(java.lang.Boolean) . build (); required Optional \u00b6 public java . lang . Boolean getRequired (); Type: java.lang.Boolean Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. EnvValueFromSecretOptions \u00b6 Options to specify an environment variable value from a Secret. Initializer \u00b6 import org.cdk8s.plus21.EnvValueFromSecretOptions ; EnvValueFromSecretOptions . builder () // .optional(java.lang.Boolean) . build (); optional Optional \u00b6 public java . lang . Boolean getOptional (); Type: java.lang.Boolean Default: false Specify whether the Secret or its key must be defined. ExposeDeploymentViaIngressOptions \u00b6 Options for exposing a deployment via an ingress. Initializer \u00b6 import org.cdk8s.plus21.ExposeDeploymentViaIngressOptions ; ExposeDeploymentViaIngressOptions . builder () // .name(java.lang.String) // .port(java.lang.Number) // .protocol(Protocol) // .serviceType(ServiceType) // .targetPort(java.lang.Number) // .ingress(IngressV1Beta1) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus21.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. serviceType Optional \u00b6 public ServiceType getServiceType (); Type: org.cdk8s.plus21.ServiceType Default: ClusterIP. The type of the exposed service. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ingress Optional \u00b6 public IngressV1Beta1 getIngress (); Type: org.cdk8s.plus21.IngressV1Beta1 Default: An ingress will be automatically created. The ingress to add rules to. ExposeDeploymentViaServiceOptions \u00b6 Options for exposing a deployment via a service. Initializer \u00b6 import org.cdk8s.plus21.ExposeDeploymentViaServiceOptions ; ExposeDeploymentViaServiceOptions . builder () // .name(java.lang.String) // .port(java.lang.Number) // .protocol(Protocol) // .serviceType(ServiceType) // .targetPort(java.lang.Number) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus21.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. serviceType Optional \u00b6 public ServiceType getServiceType (); Type: org.cdk8s.plus21.ServiceType Default: ClusterIP. The type of the exposed service. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ExposeServiceViaIngressOptions \u00b6 Options for exposing a service using an ingress. Initializer \u00b6 import org.cdk8s.plus21.ExposeServiceViaIngressOptions ; ExposeServiceViaIngressOptions . builder () // .ingress(IngressV1Beta1) . build (); ingress Optional \u00b6 public IngressV1Beta1 getIngress (); Type: org.cdk8s.plus21.IngressV1Beta1 Default: An ingress will be automatically created. The ingress to add rules to. HttpGetProbeOptions \u00b6 Options for Probe.fromHttpGet() . Initializer \u00b6 import org.cdk8s.plus21.HttpGetProbeOptions ; HttpGetProbeOptions . builder () // .failureThreshold(java.lang.Number) // .initialDelaySeconds(Duration) // .periodSeconds(Duration) // .successThreshold(java.lang.Number) // .timeoutSeconds(Duration) // .port(java.lang.Number) . build (); failureThreshold Optional \u00b6 public java . lang . Number getFailureThreshold (); Type: java.lang.Number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public Duration getInitialDelaySeconds (); Type: org.cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public Duration getPeriodSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public java . lang . Number getSuccessThreshold (); Type: java.lang.Number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public Duration getTimeoutSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: defaults to container.port . The TCP port to use when sending the GET request. IngressV1Beta1Props \u00b6 Properties for Ingress . Initializer \u00b6 import org.cdk8s.plus21.IngressV1Beta1Props ; IngressV1Beta1Props . builder () // .metadata(ApiObjectMetadata) // .defaultBackend(IngressV1Beta1Backend) // .rules(java.util.List<IngressV1Beta1Rule>) // .tls(java.util.List<IngressV1Beta1Tls>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. defaultBackend Optional \u00b6 public IngressV1Beta1Backend getDefaultBackend (); Type: org.cdk8s.plus21.IngressV1Beta1Backend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 public java . util . List < IngressV1Beta1Rule > getRules (); Type: java.util.List< org.cdk8s.plus21.IngressV1Beta1Rule > Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 public java . util . List < IngressV1Beta1Tls > getTls (); Type: java.util.List< org.cdk8s.plus21.IngressV1Beta1Tls > TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. IngressV1Beta1Rule \u00b6 Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path. Initializer \u00b6 import org.cdk8s.plus21.IngressV1Beta1Rule ; IngressV1Beta1Rule . builder () . backend ( IngressV1Beta1Backend ) // .host(java.lang.String) // .path(java.lang.String) . build (); backend Required \u00b6 public IngressV1Beta1Backend getBackend (); Type: org.cdk8s.plus21.IngressV1Beta1Backend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 public java . lang . String getHost (); Type: java.lang.String Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 public java . lang . String getPath (); Type: java.lang.String Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. IngressV1Beta1Tls \u00b6 Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination. Initializer \u00b6 import org.cdk8s.plus21.IngressV1Beta1Tls ; IngressV1Beta1Tls . builder () // .hosts(java.util.List<java.lang.String>) // .secret(ISecret) . build (); hosts Optional \u00b6 public java . util . List < java . lang . String > getHosts (); Type: java.util.List< java.lang.String > Default: If unspecified, it defaults to the wildcard host setting for the loadbalancer controller fulfilling this Ingress. Hosts are a list of hosts included in the TLS certificate. The values in this list must match the name/s used in the TLS Secret. secret Optional \u00b6 public ISecret getSecret (); Type: org.cdk8s.plus21.ISecret Default: If unspecified, it allows SSL routing based on SNI hostname. Secret is the secret that contains the certificate and key used to terminate SSL traffic on 443. If the SNI host in a listener conflicts with the \u201cHost\u201d header field used by an IngressRule, the SNI host is used for termination and value of the Host header is used for routing. JobProps \u00b6 Properties for initialization of Job . Initializer \u00b6 import org.cdk8s.plus21.JobProps ; JobProps . builder () // .metadata(ApiObjectMetadata) // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .activeDeadline(Duration) // .backoffLimit(java.lang.Number) // .ttlAfterFinished(Duration) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus21.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus21.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata. activeDeadline Optional \u00b6 public Duration getActiveDeadline (); Type: org.cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 public java . lang . Number getBackoffLimit (); Type: java.lang.Number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 public Duration getTtlAfterFinished (); Type: org.cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. MountOptions \u00b6 Options for mounts. Initializer \u00b6 import org.cdk8s.plus21.MountOptions ; MountOptions . builder () // .propagation(MountPropagation) // .readOnly(java.lang.Boolean) // .subPath(java.lang.String) // .subPathExpr(java.lang.String) . build (); propagation Optional \u00b6 public MountPropagation getPropagation (); Type: org.cdk8s.plus21.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. This field is beta in 1.10. readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public java . lang . String getSubPath (); Type: java.lang.String Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public java . lang . String getSubPathExpr (); Type: java.lang.String Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). SubPathExpr and SubPath are mutually exclusive. This field is beta in 1.15. subPathExpr and subPath are mutually exclusive. This field is beta in 1.15. PathMapping \u00b6 Maps a string key to a path within a volume. Initializer \u00b6 import org.cdk8s.plus21.PathMapping ; PathMapping . builder () . path ( java . lang . String ) // .mode(java.lang.Number) . build (); path Required \u00b6 public java . lang . String getPath (); Type: java.lang.String The relative path of the file to map the key to. May not be an absolute path. May not contain the path element \u2018..\u2019. May not start with the string \u2018..\u2019. mode Optional \u00b6 public java . lang . Number getMode (); Type: java.lang.Number Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. PodProps \u00b6 Properties for initialization of Pod . Initializer \u00b6 import org.cdk8s.plus21.PodProps ; PodProps . builder () // .metadata(ApiObjectMetadata) // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus21.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus21.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodSpecProps \u00b6 Properties of a PodSpec . Initializer \u00b6 import org.cdk8s.plus21.PodSpecProps ; PodSpecProps . builder () // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus21.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus21.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodTemplateProps \u00b6 Properties of a PodTemplate . Adds metadata information on top of the spec. Initializer \u00b6 import org.cdk8s.plus21.PodTemplateProps ; PodTemplateProps . builder () // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) . build (); containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus21.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus21.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata. ProbeOptions \u00b6 Probe options. Initializer \u00b6 import org.cdk8s.plus21.ProbeOptions ; ProbeOptions . builder () // .failureThreshold(java.lang.Number) // .initialDelaySeconds(Duration) // .periodSeconds(Duration) // .successThreshold(java.lang.Number) // .timeoutSeconds(Duration) . build (); failureThreshold Optional \u00b6 public java . lang . Number getFailureThreshold (); Type: java.lang.Number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public Duration getInitialDelaySeconds (); Type: org.cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public Duration getPeriodSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public java . lang . Number getSuccessThreshold (); Type: java.lang.Number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public Duration getTimeoutSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ResourceProps \u00b6 Initialization properties for resources. Initializer \u00b6 import org.cdk8s.plus21.ResourceProps ; ResourceProps . builder () // .metadata(ApiObjectMetadata) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. SecretProps \u00b6 Initializer \u00b6 import org.cdk8s.plus21.SecretProps ; SecretProps . builder () // .metadata(ApiObjectMetadata) // .stringData(java.util.Map<java.lang.String, java.lang.String>) // .type(java.lang.String) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. stringData Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getStringData (); Type: java.util.Map java.lang.String > stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 public java . lang . String getType (); Type: java.lang.String Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. SecretValue \u00b6 Represents a specific value in JSON secret. Initializer \u00b6 import org.cdk8s.plus21.SecretValue ; SecretValue . builder () . key ( java . lang . String ) . secret ( ISecret ) . build (); key Required \u00b6 public java . lang . String getKey (); Type: java.lang.String The JSON key. secret Required \u00b6 public ISecret getSecret (); Type: org.cdk8s.plus21.ISecret The secret. ServiceAccountProps \u00b6 Properties for initialization of ServiceAccount . Properties for initialization of ServiceAccount . Initializer \u00b6 import org.cdk8s.plus21.ServiceAccountProps ; ServiceAccountProps . builder () // .metadata(ApiObjectMetadata) // .secrets(java.util.List<ISecret>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. secrets Optional \u00b6 public java . util . List < ISecret > getSecrets (); Type: java.util.List< org.cdk8s.plus21.ISecret > List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret ServiceIngressV1BetaBackendOptions \u00b6 Options for setting up backends for ingress rules. Initializer \u00b6 import org.cdk8s.plus21.ServiceIngressV1BetaBackendOptions ; ServiceIngressV1BetaBackendOptions . builder () // .port(java.lang.Number) . build (); port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. If the service exposes multiple ports, this option must be specified. If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. ServicePort \u00b6 Definition of a service port. Initializer \u00b6 import org.cdk8s.plus21.ServicePort ; ServicePort . builder () // .name(java.lang.String) // .nodePort(java.lang.Number) // .protocol(Protocol) // .targetPort(java.lang.Number) . port ( java . lang . Number ) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public java . lang . Number getNodePort (); Type: java.lang.Number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus21.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The value of port will be used. The port number the service will redirect to. port Required \u00b6 public java . lang . Number getPort (); Type: java.lang.Number The port number the service will bind to. ServicePortOptions \u00b6 Initializer \u00b6 import org.cdk8s.plus21.ServicePortOptions ; ServicePortOptions . builder () // .name(java.lang.String) // .nodePort(java.lang.Number) // .protocol(Protocol) // .targetPort(java.lang.Number) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public java . lang . Number getNodePort (); Type: java.lang.Number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus21.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The value of port will be used. The port number the service will redirect to. ServiceProps \u00b6 Properties for initialization of Service . Initializer \u00b6 import org.cdk8s.plus21.ServiceProps ; ServiceProps . builder () // .metadata(ApiObjectMetadata) // .clusterIP(java.lang.String) // .externalIPs(java.util.List<java.lang.String>) // .externalName(java.lang.String) // .loadBalancerSourceRanges(java.util.List<java.lang.String>) // .ports(java.util.List<ServicePort>) // .type(ServiceType) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. clusterIP Optional \u00b6 public java . lang . String getClusterIP (); Type: java.lang.String Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies externalIPs Optional \u00b6 public java . util . List < java . lang . String > getExternalIPs (); Type: java.util.List< java.lang.String > Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. externalName Optional \u00b6 public java . lang . String getExternalName (); Type: java.lang.String Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. loadBalancerSourceRanges Optional \u00b6 public java . util . List < java . lang . String > getLoadBalancerSourceRanges (); Type: java.util.List< java.lang.String > A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 public java . util . List < ServicePort > getPorts (); Type: java.util.List< org.cdk8s.plus21.ServicePort > The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 public ServiceType getType (); Type: org.cdk8s.plus21.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types StatefulSetProps \u00b6 Properties for initialization of StatefulSet . Initializer \u00b6 import org.cdk8s.plus21.StatefulSetProps ; StatefulSetProps . builder () // .metadata(ApiObjectMetadata) // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) . service ( Service ) // .defaultSelector(java.lang.Boolean) // .podManagementPolicy(PodManagementPolicy) // .replicas(java.lang.Number) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus21.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus21.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata. service Required \u00b6 public Service getService (); Type: org.cdk8s.plus21.Service Service to associate with the statefulset. defaultSelector Optional \u00b6 public java . lang . Boolean getDefaultSelector (); Type: java.lang.Boolean Default: true Automatically allocates a pod selector for this statefulset. If this is set to false you must define your selector through statefulset.podMetadata.addLabel() and statefulset.selectByLabel() . podManagementPolicy Optional \u00b6 public PodManagementPolicy getPodManagementPolicy (); Type: org.cdk8s.plus21.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Default: 1 Number of desired pods. VolumeMount \u00b6 Mount a volume from the pod to the container. Initializer \u00b6 import org.cdk8s.plus21.VolumeMount ; VolumeMount . builder () // .propagation(MountPropagation) // .readOnly(java.lang.Boolean) // .subPath(java.lang.String) // .subPathExpr(java.lang.String) . path ( java . lang . String ) . volume ( Volume ) . build (); propagation Optional \u00b6 public MountPropagation getPropagation (); Type: org.cdk8s.plus21.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. This field is beta in 1.10. readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public java . lang . String getSubPath (); Type: java.lang.String Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public java . lang . String getSubPathExpr (); Type: java.lang.String Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). SubPathExpr and SubPath are mutually exclusive. This field is beta in 1.15. subPathExpr and subPath are mutually exclusive. This field is beta in 1.15. path Required \u00b6 public java . lang . String getPath (); Type: java.lang.String Path within the container at which the volume should be mounted. Must not contain \u2018:\u2019. volume Required \u00b6 public Volume getVolume (); Type: org.cdk8s.plus21.Volume The volume to mount. Classes \u00b6 Container \u00b6 A single application container that you want to run within a pod. Initializers \u00b6 import org.cdk8s.plus21.Container ; Container . Builder . create () . image ( java . lang . String ) // .args(java.util.List<java.lang.String>) // .command(java.util.List<java.lang.String>) // .env(java.util.Map<java.lang.String, EnvValue>) // .imagePullPolicy(ImagePullPolicy) // .liveness(Probe) // .name(java.lang.String) // .port(java.lang.Number) // .readiness(Probe) // .startup(Probe) // .volumeMounts(java.util.List<VolumeMount>) // .workingDir(java.lang.String) . build (); image Required \u00b6 Type: java.lang.String Docker image name. args Optional \u00b6 Type: java.util.List< java.lang.String > Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: java.util.List< java.lang.String > Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: java.util.Map \u0002klzzwxh:2868\u0003 > Default: No environment variables. List of environment variables to set in the container. Cannot be updated. imagePullPolicy Optional \u00b6 Type: org.cdk8s.plus21.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: org.cdk8s.plus21.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: java.lang.String Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: java.lang.Number Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: org.cdk8s.plus21.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: org.cdk8s.plus21.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volumeMounts Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.VolumeMount > Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. workingDir Optional \u00b6 Type: java.lang.String Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. Methods \u00b6 addEnv \u00b6 public addEnv ( java . lang . String name , EnvValue value ) name Required \u00b6 Type: java.lang.String The variable name. value Required \u00b6 Type: org.cdk8s.plus21.EnvValue The variable value. mount \u00b6 public mount ( java . lang . String path , Volume volume ) public mount ( java . lang . String path , Volume volume , MountOptions options ) path Required \u00b6 Type: java.lang.String The desired path in the container. volume Required \u00b6 Type: org.cdk8s.plus21.Volume The volume to mount. options Optional \u00b6 Type: org.cdk8s.plus21.MountOptions Properties \u00b6 env Required \u00b6 public java . util . Map < java . lang . String , EnvValue > getEnv (); Type: java.util.Map \u0002klzzwxh:2823\u0003 > The environment variables for this container. Returns a copy. To add environment variables use addEnv() . image Required \u00b6 public java . lang . String getImage (); Type: java.lang.String The container image. imagePullPolicy Required \u00b6 public ImagePullPolicy getImagePullPolicy (); Type: org.cdk8s.plus21.ImagePullPolicy Image pull policy for this container. mounts Required \u00b6 public java . util . List < VolumeMount > getMounts (); Type: java.util.List< org.cdk8s.plus21.VolumeMount > Volume mounts configured for this container. name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The name of the container. args Optional \u00b6 public java . util . List < java . lang . String > getArgs (); Type: java.util.List< java.lang.String > Arguments to the entrypoint. command Optional \u00b6 public java . util . List < java . lang . String > getCommand (); Type: java.util.List< java.lang.String > Entrypoint array (the command to execute when the container starts). port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number The port this container exposes. workingDir Optional \u00b6 public java . lang . String getWorkingDir (); Type: java.lang.String The working directory inside the container. EnvValue \u00b6 Utility class for creating reading env values from various sources. Static Functions \u00b6 fromConfigMap \u00b6 import org.cdk8s.plus21.EnvValue ; EnvValue . fromConfigMap ( IConfigMap configMap , java . lang . String key ) EnvValue . fromConfigMap ( IConfigMap configMap , java . lang . String key , EnvValueFromConfigMapOptions options ) configMap Required \u00b6 Type: org.cdk8s.plus21.IConfigMap The config map. key Required \u00b6 Type: java.lang.String The key to extract the value from. options Optional \u00b6 Type: org.cdk8s.plus21.EnvValueFromConfigMapOptions Additional options. fromProcess \u00b6 import org.cdk8s.plus21.EnvValue ; EnvValue . fromProcess ( java . lang . String key ) EnvValue . fromProcess ( java . lang . String key , EnvValueFromProcessOptions options ) key Required \u00b6 Type: java.lang.String The key to read. options Optional \u00b6 Type: org.cdk8s.plus21.EnvValueFromProcessOptions Additional options. fromSecretValue \u00b6 import org.cdk8s.plus21.EnvValue ; EnvValue . fromSecretValue ( SecretValue secretValue ) EnvValue . fromSecretValue ( SecretValue secretValue , EnvValueFromSecretOptions options ) secretValue Required \u00b6 Type: org.cdk8s.plus21.SecretValue The secret value (secrent + key). options Optional \u00b6 Type: org.cdk8s.plus21.EnvValueFromSecretOptions Additional options. fromValue \u00b6 import org.cdk8s.plus21.EnvValue ; EnvValue . fromValue ( java . lang . String value ) value Required \u00b6 Type: java.lang.String The value. Properties \u00b6 value Optional \u00b6 public java . lang . Object getValue (); Type: java.lang.Object valueFrom Optional \u00b6 public java . lang . Object getValueFrom (); Type: java.lang.Object IngressV1Beta1Backend \u00b6 The backend for an ingress path. Static Functions \u00b6 fromService \u00b6 import org.cdk8s.plus21.IngressV1Beta1Backend ; IngressV1Beta1Backend . fromService ( Service service ) IngressV1Beta1Backend . fromService ( Service service , ServiceIngressV1BetaBackendOptions options ) service Required \u00b6 Type: org.cdk8s.plus21.Service The service object. options Optional \u00b6 Type: org.cdk8s.plus21.ServiceIngressV1BetaBackendOptions PodSpec \u00b6 Implements: org.cdk8s.plus21.IPodSpec Provides read/write capabilities ontop of a PodSpecProps . Initializers \u00b6 import org.cdk8s.plus21.PodSpec ; PodSpec . Builder . create () // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 Type: org.cdk8s.plus21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 Type: org.cdk8s.plus21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Methods \u00b6 addContainer \u00b6 public addContainer ( ContainerProps container ) container Required \u00b6 Type: org.cdk8s.plus21.ContainerProps addVolume \u00b6 public addVolume ( Volume volume ) volume Required \u00b6 Type: org.cdk8s.plus21.Volume Properties \u00b6 containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus21.Container > The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus21.Volume > The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus21.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus21.IServiceAccount The service account used to run this pod. PodTemplate \u00b6 Implements: org.cdk8s.plus21.IPodTemplate Provides read/write capabilities ontop of a PodTemplateProps . Initializers \u00b6 import org.cdk8s.plus21.PodTemplate ; PodTemplate . Builder . create () // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) . build (); containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 Type: org.cdk8s.plus21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 Type: org.cdk8s.plus21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus21.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata. Properties \u00b6 podMetadata Required \u00b6 public ApiObjectMetadataDefinition getPodMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. Probe \u00b6 Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic. Initializers \u00b6 import org.cdk8s.plus21.Probe ; new Probe (); Static Functions \u00b6 fromCommand \u00b6 import org.cdk8s.plus21.Probe ; Probe . fromCommand ( java . util . List < java . lang . String > command ) Probe . fromCommand ( java . util . List < java . lang . String > command , CommandProbeOptions options ) command Required \u00b6 Type: java.util.List< java.lang.String > The command to execute. options Optional \u00b6 Type: org.cdk8s.plus21.CommandProbeOptions Options. fromHttpGet \u00b6 import org.cdk8s.plus21.Probe ; Probe . fromHttpGet ( java . lang . String path ) Probe . fromHttpGet ( java . lang . String path , HttpGetProbeOptions options ) path Required \u00b6 Type: java.lang.String The URL path to hit. options Optional \u00b6 Type: org.cdk8s.plus21.HttpGetProbeOptions Options. Volume \u00b6 Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes Initializers \u00b6 import org.cdk8s.plus21.Volume ; new Volume ( java . lang . String name , java . lang . Object config ); name Required \u00b6 Type: java.lang.String config Required \u00b6 Type: java.lang.Object Static Functions \u00b6 fromConfigMap \u00b6 import org.cdk8s.plus21.Volume ; Volume . fromConfigMap ( IConfigMap configMap ) Volume . fromConfigMap ( IConfigMap configMap , ConfigMapVolumeOptions options ) configMap Required \u00b6 Type: org.cdk8s.plus21.IConfigMap The config map to use to populate the volume. options Optional \u00b6 Type: org.cdk8s.plus21.ConfigMapVolumeOptions Options. fromEmptyDir \u00b6 import org.cdk8s.plus21.Volume ; Volume . fromEmptyDir ( java . lang . String name ) Volume . fromEmptyDir ( java . lang . String name , EmptyDirVolumeOptions options ) name Required \u00b6 Type: java.lang.String options Optional \u00b6 Type: org.cdk8s.plus21.EmptyDirVolumeOptions Additional options. Properties \u00b6 name Required \u00b6 public java . lang . String getName (); Type: java.lang.String Protocols \u00b6 IConfigMap \u00b6 Extends: org.cdk8s.plus21.IResource Implemented By: org.cdk8s.plus21.ConfigMap , org.cdk8s.plus21.IConfigMap Represents a config map. Properties \u00b6 name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IPodSpec \u00b6 Implemented By: org.cdk8s.plus21.Deployment , org.cdk8s.plus21.Job , org.cdk8s.plus21.Pod , org.cdk8s.plus21.PodSpec , org.cdk8s.plus21.PodTemplate , org.cdk8s.plus21.StatefulSet , org.cdk8s.plus21.IPodSpec , org.cdk8s.plus21.IPodTemplate Represents a resource that can be configured with a kuberenets pod spec. (e.g Deployment , Job , Pod , \u2026). Use the PodSpec class as an implementation helper. Methods \u00b6 addContainer \u00b6 public addContainer ( ContainerProps container ) container Required \u00b6 Type: org.cdk8s.plus21.ContainerProps The container. addVolume \u00b6 public addVolume ( Volume volume ) volume Required \u00b6 Type: org.cdk8s.plus21.Volume The volume. Properties \u00b6 containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus21.Container > The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus21.Volume > The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus21.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus21.IServiceAccount The service account used to run this pod. IPodTemplate \u00b6 Extends: org.cdk8s.plus21.IPodSpec Implemented By: org.cdk8s.plus21.Deployment , org.cdk8s.plus21.Job , org.cdk8s.plus21.PodTemplate , org.cdk8s.plus21.StatefulSet , org.cdk8s.plus21.IPodTemplate Represents a resource that can be configured with a kuberenets pod template. (e.g Deployment , Job , \u2026). Use the PodTemplate class as an implementation helper. Properties \u00b6 containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus21.Container > The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus21.Volume > The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus21.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus21.IServiceAccount The service account used to run this pod. podMetadata Required \u00b6 public ApiObjectMetadataDefinition getPodMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. IResource \u00b6 Implemented By: org.cdk8s.plus21.ConfigMap , org.cdk8s.plus21.Deployment , org.cdk8s.plus21.IngressV1Beta1 , org.cdk8s.plus21.Job , org.cdk8s.plus21.Pod , org.cdk8s.plus21.Resource , org.cdk8s.plus21.Secret , org.cdk8s.plus21.Service , org.cdk8s.plus21.ServiceAccount , org.cdk8s.plus21.StatefulSet , org.cdk8s.plus21.IConfigMap , org.cdk8s.plus21.IResource , org.cdk8s.plus21.ISecret , org.cdk8s.plus21.IServiceAccount Represents a resource. Properties \u00b6 name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. ISecret \u00b6 Extends: org.cdk8s.plus21.IResource Implemented By: org.cdk8s.plus21.Secret , org.cdk8s.plus21.ISecret Properties \u00b6 name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IServiceAccount \u00b6 Extends: org.cdk8s.plus21.IResource Implemented By: org.cdk8s.plus21.ServiceAccount , org.cdk8s.plus21.IServiceAccount Properties \u00b6 name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. Enums \u00b6 EmptyDirMedium \u00b6 The medium on which to store the volume. DEFAULT \u00b6 The default volume of the backing node. MEMORY \u00b6 Mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. ImagePullPolicy \u00b6 ALWAYS \u00b6 Every time the kubelet launches a container, the kubelet queries the container image registry to resolve the name to an image digest. If the kubelet has a container image with that exact digest cached locally, the kubelet uses its cached image; otherwise, the kubelet downloads (pulls) the image with the resolved digest, and uses that image to launch the container. Default is Always if ImagePullPolicy is omitted and either the image tag is :latest or the image tag is omitted. IF_NOT_PRESENT \u00b6 The image is pulled only if it is not already present locally. Default is IfNotPresent if ImagePullPolicy is omitted and the image tag is present but not :latest NEVER \u00b6 The image is assumed to exist locally. No attempt is made to pull the image. MountPropagation \u00b6 NONE \u00b6 This volume mount will not receive any subsequent mounts that are mounted to this volume or any of its subdirectories by the host. In similar fashion, no mounts created by the Container will be visible on the host. This is the default mode. This mode is equal to private mount propagation as described in the Linux kernel documentation HOST_TO_CONTAINER \u00b6 This volume mount will receive all subsequent mounts that are mounted to this volume or any of its subdirectories. In other words, if the host mounts anything inside the volume mount, the Container will see it mounted there. Similarly, if any Pod with Bidirectional mount propagation to the same volume mounts anything there, the Container with HostToContainer mount propagation will see it. This mode is equal to rslave mount propagation as described in the Linux kernel documentation BIDIRECTIONAL \u00b6 This volume mount behaves the same the HostToContainer mount. In addition, all volume mounts created by the Container will be propagated back to the host and to all Containers of all Pods that use the same volume A typical use case for this mode is a Pod with a FlexVolume or CSI driver or a Pod that needs to mount something on the host using a hostPath volume. This mode is equal to rshared mount propagation as described in the Linux kernel documentation Caution: Bidirectional mount propagation can be dangerous. It can damage the host operating system and therefore it is allowed only in privileged Containers. Familiarity with Linux kernel behavior is strongly recommended. In addition, any volume mounts created by Containers in Pods must be destroyed (unmounted) by the Containers on termination. PodManagementPolicy \u00b6 Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once. ORDERED_READY \u00b6 PARALLEL \u00b6 Protocol \u00b6 TCP \u00b6 UDP \u00b6 SCTP \u00b6 RestartPolicy \u00b6 Restart policy for all containers within the pod. ALWAYS \u00b6 Always restart the pod after it exits. ON_FAILURE \u00b6 Only restart if the pod exits with a non-zero exit code. NEVER \u00b6 Never restart the pod. ServiceType \u00b6 For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP. CLUSTER_IP \u00b6 Exposes the Service on a cluster-internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default ServiceType NODE_PORT \u00b6 Exposes the Service on each Node\u2019s IP at a static port (the NodePort). A ClusterIP Service, to which the NodePort Service routes, is automatically created. You\u2019ll be able to contact the NodePort Service, from outside the cluster, by requesting : . LOAD_BALANCER \u00b6 Exposes the Service externally using a cloud provider\u2019s load balancer. NodePort and ClusterIP Services, to which the external load balancer routes, are automatically created. EXTERNAL_NAME \u00b6 Maps the Service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value. No proxying of any kind is set up. Note: You need either kube-dns version 1.7 or CoreDNS version 0.0.8 or higher to use the ExternalName type.","title":"Java"},{"location":"reference/cdk8s-plus-21/java/#cdk8s-plus-21-java","text":"","title":"cdk8s-plus-21 (Java) "},{"location":"reference/cdk8s-plus-21/java/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s-plus-21/java/#configmap","text":"Implements: org.cdk8s.plus21.IConfigMap ConfigMap holds configuration data for pods to consume.","title":"ConfigMap "},{"location":"reference/cdk8s-plus-21/java/#deployment","text":"Implements: org.cdk8s.plus21.IPodTemplate A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below.","title":"Deployment "},{"location":"reference/cdk8s-plus-21/java/#use-case","text":"The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore.","title":"Use Case"},{"location":"reference/cdk8s-plus-21/java/#ingressv1beta1","text":"Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.","title":"IngressV1Beta1 "},{"location":"reference/cdk8s-plus-21/java/#job","text":"Implements: org.cdk8s.plus21.IPodTemplate A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel.","title":"Job "},{"location":"reference/cdk8s-plus-21/java/#pod","text":"Implements: org.cdk8s.plus21.IPodSpec Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.","title":"Pod "},{"location":"reference/cdk8s-plus-21/java/#resource","text":"Implements: org.cdk8s.plus21.IResource Base class for all Kubernetes objects in stdk8s. Represents a single resource.","title":"Resource "},{"location":"reference/cdk8s-plus-21/java/#secret","text":"Implements: org.cdk8s.plus21.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret","title":"Secret "},{"location":"reference/cdk8s-plus-21/java/#service","text":"An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods.","title":"Service "},{"location":"reference/cdk8s-plus-21/java/#serviceaccount","text":"Implements: org.cdk8s.plus21.IServiceAccount A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account","title":"ServiceAccount "},{"location":"reference/cdk8s-plus-21/java/#statefulset","text":"Implements: org.cdk8s.plus21.IPodTemplate StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed.","title":"StatefulSet "},{"location":"reference/cdk8s-plus-21/java/#using-statefulsets","text":"StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates.","title":"Using StatefulSets"},{"location":"reference/cdk8s-plus-21/java/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s-plus-21/java/#adddeploymentoptions","text":"Options to add a deployment to a service.","title":"AddDeploymentOptions "},{"location":"reference/cdk8s-plus-21/java/#adddirectoryoptions","text":"Options for configmap.addDirectory() .","title":"AddDirectoryOptions "},{"location":"reference/cdk8s-plus-21/java/#commandprobeoptions","text":"Options for Probe.fromCommand() .","title":"CommandProbeOptions "},{"location":"reference/cdk8s-plus-21/java/#configmapprops","text":"Properties for initialization of ConfigMap .","title":"ConfigMapProps "},{"location":"reference/cdk8s-plus-21/java/#configmapvolumeoptions","text":"Options for the ConfigMap-based volume.","title":"ConfigMapVolumeOptions "},{"location":"reference/cdk8s-plus-21/java/#containerprops","text":"Properties for creating a container.","title":"ContainerProps "},{"location":"reference/cdk8s-plus-21/java/#deploymentprops","text":"Properties for initialization of Deployment .","title":"DeploymentProps "},{"location":"reference/cdk8s-plus-21/java/#emptydirvolumeoptions","text":"Options for volumes populated with an empty directory.","title":"EmptyDirVolumeOptions "},{"location":"reference/cdk8s-plus-21/java/#envvaluefromconfigmapoptions","text":"Options to specify an envionment variable value from a ConfigMap key.","title":"EnvValueFromConfigMapOptions "},{"location":"reference/cdk8s-plus-21/java/#envvaluefromprocessoptions","text":"Options to specify an environment variable value from the process environment.","title":"EnvValueFromProcessOptions "},{"location":"reference/cdk8s-plus-21/java/#envvaluefromsecretoptions","text":"Options to specify an environment variable value from a Secret.","title":"EnvValueFromSecretOptions "},{"location":"reference/cdk8s-plus-21/java/#exposedeploymentviaingressoptions","text":"Options for exposing a deployment via an ingress.","title":"ExposeDeploymentViaIngressOptions "},{"location":"reference/cdk8s-plus-21/java/#exposedeploymentviaserviceoptions","text":"Options for exposing a deployment via a service.","title":"ExposeDeploymentViaServiceOptions "},{"location":"reference/cdk8s-plus-21/java/#exposeserviceviaingressoptions","text":"Options for exposing a service using an ingress.","title":"ExposeServiceViaIngressOptions "},{"location":"reference/cdk8s-plus-21/java/#httpgetprobeoptions","text":"Options for Probe.fromHttpGet() .","title":"HttpGetProbeOptions "},{"location":"reference/cdk8s-plus-21/java/#ingressv1beta1props","text":"Properties for Ingress .","title":"IngressV1Beta1Props "},{"location":"reference/cdk8s-plus-21/java/#ingressv1beta1rule","text":"Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path.","title":"IngressV1Beta1Rule "},{"location":"reference/cdk8s-plus-21/java/#ingressv1beta1tls","text":"Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination.","title":"IngressV1Beta1Tls "},{"location":"reference/cdk8s-plus-21/java/#jobprops","text":"Properties for initialization of Job .","title":"JobProps "},{"location":"reference/cdk8s-plus-21/java/#mountoptions","text":"Options for mounts.","title":"MountOptions "},{"location":"reference/cdk8s-plus-21/java/#pathmapping","text":"Maps a string key to a path within a volume.","title":"PathMapping "},{"location":"reference/cdk8s-plus-21/java/#podprops","text":"Properties for initialization of Pod .","title":"PodProps "},{"location":"reference/cdk8s-plus-21/java/#podspecprops","text":"Properties of a PodSpec .","title":"PodSpecProps "},{"location":"reference/cdk8s-plus-21/java/#podtemplateprops","text":"Properties of a PodTemplate . Adds metadata information on top of the spec.","title":"PodTemplateProps "},{"location":"reference/cdk8s-plus-21/java/#probeoptions","text":"Probe options.","title":"ProbeOptions "},{"location":"reference/cdk8s-plus-21/java/#resourceprops","text":"Initialization properties for resources.","title":"ResourceProps "},{"location":"reference/cdk8s-plus-21/java/#secretprops","text":"","title":"SecretProps "},{"location":"reference/cdk8s-plus-21/java/#secretvalue","text":"Represents a specific value in JSON secret.","title":"SecretValue "},{"location":"reference/cdk8s-plus-21/java/#serviceaccountprops","text":"Properties for initialization of ServiceAccount . Properties for initialization of ServiceAccount .","title":"ServiceAccountProps "},{"location":"reference/cdk8s-plus-21/java/#serviceingressv1betabackendoptions","text":"Options for setting up backends for ingress rules.","title":"ServiceIngressV1BetaBackendOptions "},{"location":"reference/cdk8s-plus-21/java/#serviceport","text":"Definition of a service port.","title":"ServicePort "},{"location":"reference/cdk8s-plus-21/java/#serviceportoptions","text":"","title":"ServicePortOptions "},{"location":"reference/cdk8s-plus-21/java/#serviceprops","text":"Properties for initialization of Service .","title":"ServiceProps "},{"location":"reference/cdk8s-plus-21/java/#statefulsetprops","text":"Properties for initialization of StatefulSet .","title":"StatefulSetProps "},{"location":"reference/cdk8s-plus-21/java/#volumemount","text":"Mount a volume from the pod to the container.","title":"VolumeMount "},{"location":"reference/cdk8s-plus-21/java/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s-plus-21/java/#container","text":"A single application container that you want to run within a pod.","title":"Container "},{"location":"reference/cdk8s-plus-21/java/#envvalue","text":"Utility class for creating reading env values from various sources.","title":"EnvValue "},{"location":"reference/cdk8s-plus-21/java/#ingressv1beta1backend","text":"The backend for an ingress path.","title":"IngressV1Beta1Backend "},{"location":"reference/cdk8s-plus-21/java/#podspec","text":"Implements: org.cdk8s.plus21.IPodSpec Provides read/write capabilities ontop of a PodSpecProps .","title":"PodSpec "},{"location":"reference/cdk8s-plus-21/java/#podtemplate","text":"Implements: org.cdk8s.plus21.IPodTemplate Provides read/write capabilities ontop of a PodTemplateProps .","title":"PodTemplate "},{"location":"reference/cdk8s-plus-21/java/#probe","text":"Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.","title":"Probe "},{"location":"reference/cdk8s-plus-21/java/#volume","text":"Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes","title":"Volume "},{"location":"reference/cdk8s-plus-21/java/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s-plus-21/java/#iconfigmap","text":"Extends: org.cdk8s.plus21.IResource Implemented By: org.cdk8s.plus21.ConfigMap , org.cdk8s.plus21.IConfigMap Represents a config map.","title":"IConfigMap "},{"location":"reference/cdk8s-plus-21/java/#ipodspec","text":"Implemented By: org.cdk8s.plus21.Deployment , org.cdk8s.plus21.Job , org.cdk8s.plus21.Pod , org.cdk8s.plus21.PodSpec , org.cdk8s.plus21.PodTemplate , org.cdk8s.plus21.StatefulSet , org.cdk8s.plus21.IPodSpec , org.cdk8s.plus21.IPodTemplate Represents a resource that can be configured with a kuberenets pod spec. (e.g Deployment , Job , Pod , \u2026). Use the PodSpec class as an implementation helper.","title":"IPodSpec "},{"location":"reference/cdk8s-plus-21/java/#ipodtemplate","text":"Extends: org.cdk8s.plus21.IPodSpec Implemented By: org.cdk8s.plus21.Deployment , org.cdk8s.plus21.Job , org.cdk8s.plus21.PodTemplate , org.cdk8s.plus21.StatefulSet , org.cdk8s.plus21.IPodTemplate Represents a resource that can be configured with a kuberenets pod template. (e.g Deployment , Job , \u2026). Use the PodTemplate class as an implementation helper.","title":"IPodTemplate "},{"location":"reference/cdk8s-plus-21/java/#iresource","text":"Implemented By: org.cdk8s.plus21.ConfigMap , org.cdk8s.plus21.Deployment , org.cdk8s.plus21.IngressV1Beta1 , org.cdk8s.plus21.Job , org.cdk8s.plus21.Pod , org.cdk8s.plus21.Resource , org.cdk8s.plus21.Secret , org.cdk8s.plus21.Service , org.cdk8s.plus21.ServiceAccount , org.cdk8s.plus21.StatefulSet , org.cdk8s.plus21.IConfigMap , org.cdk8s.plus21.IResource , org.cdk8s.plus21.ISecret , org.cdk8s.plus21.IServiceAccount Represents a resource.","title":"IResource "},{"location":"reference/cdk8s-plus-21/java/#isecret","text":"Extends: org.cdk8s.plus21.IResource Implemented By: org.cdk8s.plus21.Secret , org.cdk8s.plus21.ISecret","title":"ISecret "},{"location":"reference/cdk8s-plus-21/java/#iserviceaccount","text":"Extends: org.cdk8s.plus21.IResource Implemented By: org.cdk8s.plus21.ServiceAccount , org.cdk8s.plus21.IServiceAccount","title":"IServiceAccount "},{"location":"reference/cdk8s-plus-21/java/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s-plus-21/java/#emptydirmedium","text":"The medium on which to store the volume.","title":"EmptyDirMedium "},{"location":"reference/cdk8s-plus-21/java/#imagepullpolicy","text":"","title":"ImagePullPolicy "},{"location":"reference/cdk8s-plus-21/java/#mountpropagation","text":"","title":"MountPropagation "},{"location":"reference/cdk8s-plus-21/java/#podmanagementpolicy","text":"Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.","title":"PodManagementPolicy "},{"location":"reference/cdk8s-plus-21/java/#protocol","text":"","title":"Protocol "},{"location":"reference/cdk8s-plus-21/java/#restartpolicy","text":"Restart policy for all containers within the pod.","title":"RestartPolicy "},{"location":"reference/cdk8s-plus-21/java/#servicetype","text":"For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP.","title":"ServiceType "},{"location":"reference/cdk8s-plus-21/python/","text":"cdk8s-plus-21 (Python) \u00b6 Constructs \u00b6 ConfigMap \u00b6 Implements: cdk8s_plus_21.IConfigMap ConfigMap holds configuration data for pods to consume. Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ConfigMap ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , binary_data : typing . Mapping [ str ] = None , data : typing . Mapping [ str ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binary_data Optional \u00b6 Type: typing.Mapping[ str ] BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. Using this field will require 1.10+ apiserver and kubelet. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 Type: typing.Mapping[ str ] Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . Methods \u00b6 add_binary_data \u00b6 def add_binary_data ( key : str , value : str ) key Required \u00b6 Type: str The key. value Required \u00b6 Type: str The value. add_data \u00b6 def add_data ( key : str , value : str ) key Required \u00b6 Type: str The key. value Required \u00b6 Type: str The value. add_directory \u00b6 def add_directory ( local_dir : str , exclude : typing . List [ str ] = None , key_prefix : str = None ) local_dir Required \u00b6 Type: str A path to a local directory. exclude Optional \u00b6 Type: typing.List[ str ] Default: include all files Glob patterns to exclude when adding files. key_prefix Optional \u00b6 Type: str Default: \u201c\u201d A prefix to add to all keys in the config map. add_file \u00b6 def add_file ( local_file : str , key : str = None ) local_file Required \u00b6 Type: str The path to the local file. key Optional \u00b6 Type: str The ConfigMap key (default to the file name). Static Functions \u00b6 from_config_map_name \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ConfigMap . from_config_map_name ( name : str ) name Required \u00b6 Type: str The name of the config map to import. Properties \u00b6 binary_data Required \u00b6 binary_data : typing . Mapping [ str ] Type: typing.Mapping[ str ] The binary data associated with this config map. Returns a copy. To add data records, use addBinaryData() or addData() . data Required \u00b6 data : typing . Mapping [ str ] Type: typing.Mapping[ str ] The data associated with this config map. Returns an copy. To add data records, use addData() or addBinaryData() . Deployment \u00b6 Implements: cdk8s_plus_21.IPodTemplate A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case \u00b6 The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore. Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Deployment ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , default_selector : bool = None , replicas : typing . Union [ int , float ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: typing.List[ cdk8s_plus_21.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_21.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata. default_selector Optional \u00b6 Type: bool Default: true Automatically allocates a pod selector for this deployment. If this is set to false you must define your selector through deployment.podMetadata.addLabel() and deployment.selectByLabel() . replicas Optional \u00b6 Type: typing.Union[int, float] Default: 1 Number of desired pods. Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_21.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_21.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_21.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_21.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_21.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_21.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( volume : Volume ) volume Required \u00b6 Type: cdk8s_plus_21.Volume expose_via_ingress \u00b6 def expose_via_ingress ( path : str , name : str = None , port : typing . Union [ int , float ] = None , protocol : Protocol = None , service_type : ServiceType = None , target_port : typing . Union [ int , float ] = None , ingress : IngressV1Beta1 = None ) path Required \u00b6 Type: str The ingress path to register under. name Optional \u00b6 Type: str Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 Type: typing.Union[int, float] Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 Type: cdk8s_plus_21.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. service_type Optional \u00b6 Type: cdk8s_plus_21.ServiceType Default: ClusterIP. The type of the exposed service. target_port Optional \u00b6 Type: typing.Union[int, float] Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ingress Optional \u00b6 Type: cdk8s_plus_21.IngressV1Beta1 Default: An ingress will be automatically created. The ingress to add rules to. expose_via_service \u00b6 def expose_via_service ( name : str = None , port : typing . Union [ int , float ] = None , protocol : Protocol = None , service_type : ServiceType = None , target_port : typing . Union [ int , float ] = None ) name Optional \u00b6 Type: str Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 Type: typing.Union[int, float] Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 Type: cdk8s_plus_21.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. service_type Optional \u00b6 Type: cdk8s_plus_21.ServiceType Default: ClusterIP. The type of the exposed service. target_port Optional \u00b6 Type: typing.Union[int, float] Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. select_by_label \u00b6 def select_by_label ( key : str , value : str ) key Required \u00b6 Type: str The label key. value Required \u00b6 Type: str The label value. Properties \u00b6 containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_21.Container ] The containers belonging to the pod. Use addContainer to add containers. label_selector Required \u00b6 label_selector : typing . Mapping [ str ] Type: typing.Mapping[ str ] The labels this deployment will match against in order to select pods. Returns a a copy. Use selectByLabel() to add labels. pod_metadata Required \u00b6 pod_metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. replicas Required \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Number of desired pods. volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_21.Volume ] The volumes associated with this pod. Use addVolume to add volumes. restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_21.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_21.IServiceAccount The service account used to run this pod. IngressV1Beta1 \u00b6 Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . IngressV1Beta1 ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , default_backend : IngressV1Beta1Backend = None , rules : typing . List [ IngressV1Beta1Rule ] = None , tls : typing . List [ IngressV1Beta1Tls ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. default_backend Optional \u00b6 Type: cdk8s_plus_21.IngressV1Beta1Backend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 Type: typing.List[ cdk8s_plus_21.IngressV1Beta1Rule ] Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 Type: typing.List[ cdk8s_plus_21.IngressV1Beta1Tls ] TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. Methods \u00b6 add_default_backend \u00b6 def add_default_backend ( backend : IngressV1Beta1Backend ) backend Required \u00b6 Type: cdk8s_plus_21.IngressV1Beta1Backend The backend to use for requests that do not match any rule. add_host_default_backend \u00b6 def add_host_default_backend ( host : str , backend : IngressV1Beta1Backend ) host Required \u00b6 Type: str The host name to match. backend Required \u00b6 Type: cdk8s_plus_21.IngressV1Beta1Backend The backend to route to. add_host_rule \u00b6 def add_host_rule ( host : str , path : str , backend : IngressV1Beta1Backend ) host Required \u00b6 Type: str The host name. path Required \u00b6 Type: str The HTTP path. backend Required \u00b6 Type: cdk8s_plus_21.IngressV1Beta1Backend The backend to route requests to. add_rule \u00b6 def add_rule ( path : str , backend : IngressV1Beta1Backend ) path Required \u00b6 Type: str The HTTP path. backend Required \u00b6 Type: cdk8s_plus_21.IngressV1Beta1Backend The backend to route requests to. add_rules \u00b6 def add_rules ( backend : IngressV1Beta1Backend , host : str = None , path : str = None ) backend Required \u00b6 Type: cdk8s_plus_21.IngressV1Beta1Backend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 Type: str Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 Type: str Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. add_tls \u00b6 def add_tls ( tls : typing . List [ IngressV1Beta1Tls ] ) tls Required \u00b6 Type: typing.List[ cdk8s_plus_21.IngressV1Beta1Tls ] Job \u00b6 Implements: cdk8s_plus_21.IPodTemplate A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel. Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Job ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , active_deadline : Duration = None , backoff_limit : typing . Union [ int , float ] = None , ttl_after_finished : Duration = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: typing.List[ cdk8s_plus_21.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_21.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata. active_deadline Optional \u00b6 Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoff_limit Optional \u00b6 Type: typing.Union[int, float] Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttl_after_finished Optional \u00b6 Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_21.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_21.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_21.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_21.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_21.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_21.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( volume : Volume ) volume Required \u00b6 Type: cdk8s_plus_21.Volume Properties \u00b6 containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_21.Container ] The containers belonging to the pod. Use addContainer to add containers. pod_metadata Required \u00b6 pod_metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_21.Volume ] The volumes associated with this pod. Use addVolume to add volumes. active_deadline Optional \u00b6 active_deadline : Duration Type: cdk8s.Duration Duration before job is terminated. If undefined, there is no deadline. backoff_limit Optional \u00b6 backoff_limit : typing . Union [ int , float ] Type: typing.Union[int, float] Number of retries before marking failed. restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_21.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_21.IServiceAccount The service account used to run this pod. ttl_after_finished Optional \u00b6 ttl_after_finished : Duration Type: cdk8s.Duration TTL before the job is deleted after it is finished. Pod \u00b6 Implements: cdk8s_plus_21.IPodSpec Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts. Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Pod ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: typing.List[ cdk8s_plus_21.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_21.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_21.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_21.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_21.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_21.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_21.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_21.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( volume : Volume ) volume Required \u00b6 Type: cdk8s_plus_21.Volume Properties \u00b6 containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_21.Container ] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_21.Volume ] The volumes associated with this pod. Use addVolume to add volumes. restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_21.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_21.IServiceAccount The service account used to run this pod. Resource \u00b6 Implements: cdk8s_plus_21.IResource Base class for all Kubernetes objects in stdk8s. Represents a single resource. Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Resource ( scope : Construct , id : str , node_factory : INodeFactory = None ) scope Required \u00b6 Type: constructs.Construct The scope in which to define this construct. id Required \u00b6 Type: str The scoped construct ID. Must be unique amongst siblings. If the ID includes a path separator ( / ), then it will be replaced by double dash -- . node_factory Optional \u00b6 Type: constructs.INodeFactory Default: the default Node is associated A factory for attaching Node s to the construct. Properties \u00b6 metadata Required \u00b6 metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition name Required \u00b6 name : str Type: str The name of this API object. Secret \u00b6 Implements: cdk8s_plus_21.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Secret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , string_data : typing . Mapping [ str ] = None , type : str = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. string_data Optional \u00b6 Type: typing.Mapping[ str ] stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 Type: str Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. Methods \u00b6 add_string_data \u00b6 def add_string_data ( key : str , value : str ) key Required \u00b6 Type: str Key. value Required \u00b6 Type: str Value. get_string_data \u00b6 def get_string_data ( key : str ) key Required \u00b6 Type: str Key. Static Functions \u00b6 from_secret_name \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Secret . from_secret_name ( name : str ) name Required \u00b6 Type: str The name of the secret to reference. Service \u00b6 An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods. Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Service ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , cluster_i_p : str = None , external_i_ps : typing . List [ str ] = None , external_name : str = None , load_balancer_source_ranges : typing . List [ str ] = None , ports : typing . List [ ServicePort ] = None , type : ServiceType = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. cluster_i_p Optional \u00b6 Type: str Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies external_i_ps Optional \u00b6 Type: typing.List[ str ] Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. external_name Optional \u00b6 Type: str Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. load_balancer_source_ranges Optional \u00b6 Type: typing.List[ str ] A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 Type: typing.List[ cdk8s_plus_21.ServicePort ] The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 Type: cdk8s_plus_21.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types Methods \u00b6 add_deployment \u00b6 def add_deployment ( deployment : Deployment , name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None , port : typing . Union [ int , float ] = None ) deployment Required \u00b6 Type: cdk8s_plus_21.Deployment The deployment to expose. name Optional \u00b6 Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 Type: cdk8s_plus_21.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. port Optional \u00b6 Type: typing.Union[int, float] Default: Copied from the first container of the deployment. The port number the service will bind to. add_selector \u00b6 def add_selector ( label : str , value : str ) label Required \u00b6 Type: str The label key. value Required \u00b6 Type: str The label value. expose_via_ingress \u00b6 def expose_via_ingress ( path : str , ingress : IngressV1Beta1 = None ) path Required \u00b6 Type: str The path to expose the service under. ingress Optional \u00b6 Type: cdk8s_plus_21.IngressV1Beta1 Default: An ingress will be automatically created. The ingress to add rules to. serve \u00b6 def serve ( port : typing . Union [ int , float ], name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None ) port Required \u00b6 Type: typing.Union[int, float] The port definition. name Optional \u00b6 Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 Type: cdk8s_plus_21.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. Properties \u00b6 ports Required \u00b6 ports : typing . List [ ServicePort ] Type: typing.List[ cdk8s_plus_21.ServicePort ] Ports for this service. Use serve() to expose additional service ports. selector Required \u00b6 selector : typing . Mapping [ str ] Type: typing.Mapping[ str ] Returns the labels which are used to select pods for this service. type Required \u00b6 type : ServiceType Type: cdk8s_plus_21.ServiceType Determines how the Service is exposed. cluster_i_p Optional \u00b6 cluster_i_p : str Type: str The IP address of the service and is usually assigned randomly by the master. external_name Optional \u00b6 external_name : str Type: str The externalName to be used for EXTERNAL_NAME types. ServiceAccount \u00b6 Implements: cdk8s_plus_21.IServiceAccount A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ServiceAccount ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , secrets : typing . List [ ISecret ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. secrets Optional \u00b6 Type: typing.List[ cdk8s_plus_21.ISecret ] List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret Methods \u00b6 add_secret \u00b6 def add_secret ( secret : ISecret ) secret Required \u00b6 Type: cdk8s_plus_21.ISecret The secret. Static Functions \u00b6 from_service_account_name \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ServiceAccount . from_service_account_name ( name : str ) name Required \u00b6 Type: str The name of the service account resource. Properties \u00b6 secrets Required \u00b6 secrets : typing . List [ ISecret ] Type: typing.List[ cdk8s_plus_21.ISecret ] List of secrets allowed to be used by pods running using this service account. Returns a copy. To add a secret, use addSecret() . StatefulSet \u00b6 Implements: cdk8s_plus_21.IPodTemplate StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed. Using StatefulSets \u00b6 StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates. Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . StatefulSet ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , service : Service , default_selector : bool = None , pod_management_policy : PodManagementPolicy = None , replicas : typing . Union [ int , float ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: typing.List[ cdk8s_plus_21.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_21.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata. service Required \u00b6 Type: cdk8s_plus_21.Service Service to associate with the statefulset. default_selector Optional \u00b6 Type: bool Default: true Automatically allocates a pod selector for this statefulset. If this is set to false you must define your selector through statefulset.podMetadata.addLabel() and statefulset.selectByLabel() . pod_management_policy Optional \u00b6 Type: cdk8s_plus_21.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 Type: typing.Union[int, float] Default: 1 Number of desired pods. Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_21.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_21.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_21.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_21.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_21.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_21.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( volume : Volume ) volume Required \u00b6 Type: cdk8s_plus_21.Volume select_by_label \u00b6 def select_by_label ( key : str , value : str ) key Required \u00b6 Type: str The label key. value Required \u00b6 Type: str The label value. Properties \u00b6 containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_21.Container ] The containers belonging to the pod. Use addContainer to add containers. label_selector Required \u00b6 label_selector : typing . Mapping [ str ] Type: typing.Mapping[ str ] The labels this statefulset will match against in order to select pods. Returns a a copy. Use selectByLabel() to add labels. pod_management_policy Required \u00b6 pod_management_policy : PodManagementPolicy Type: cdk8s_plus_21.PodManagementPolicy Management policy to use for the set. pod_metadata Required \u00b6 pod_metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. replicas Required \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Number of desired pods. volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_21.Volume ] The volumes associated with this pod. Use addVolume to add volumes. restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_21.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_21.IServiceAccount The service account used to run this pod. Structs \u00b6 AddDeploymentOptions \u00b6 Options to add a deployment to a service. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . AddDeploymentOptions ( name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None , port : typing . Union [ int , float ] = None ) name Optional \u00b6 name : str Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 node_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_21.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: Copied from the first container of the deployment. The port number the service will bind to. AddDirectoryOptions \u00b6 Options for configmap.addDirectory() . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . AddDirectoryOptions ( exclude : typing . List [ str ] = None , key_prefix : str = None ) exclude Optional \u00b6 exclude : typing . List [ str ] Type: typing.List[ str ] Default: include all files Glob patterns to exclude when adding files. key_prefix Optional \u00b6 key_prefix : str Type: str Default: \u201c\u201d A prefix to add to all keys in the config map. CommandProbeOptions \u00b6 Options for Probe.fromCommand() . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . CommandProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None ) failure_threshold Optional \u00b6 failure_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 initial_delay_seconds : Duration Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 period_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 success_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 timeout_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ConfigMapProps \u00b6 Properties for initialization of ConfigMap . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ConfigMapProps ( metadata : ApiObjectMetadata = None , binary_data : typing . Mapping [ str ] = None , data : typing . Mapping [ str ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binary_data Optional \u00b6 binary_data : typing . Mapping [ str ] Type: typing.Mapping[ str ] BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. Using this field will require 1.10+ apiserver and kubelet. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 data : typing . Mapping [ str ] Type: typing.Mapping[ str ] Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . ConfigMapVolumeOptions \u00b6 Options for the ConfigMap-based volume. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ConfigMapVolumeOptions ( default_mode : typing . Union [ int , float ] = None , items : typing . Mapping [ PathMapping ] = None , name : str = None , optional : bool = None ) default_mode Optional \u00b6 default_mode : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 items : typing . Mapping [ PathMapping ] Type: typing.Mapping[ cdk8s_plus_21.PathMapping ] Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 name : str Type: str Default: auto-generated The volume name. optional Optional \u00b6 optional : bool Type: bool Default: undocumented Specify whether the ConfigMap or its keys must be defined. ContainerProps \u00b6 Properties for creating a container. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ContainerProps ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 image : str Type: str Docker image name. args Optional \u00b6 args : typing . List [ str ] Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 command : typing . List [ str ] Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 env : typing . Mapping [ EnvValue ] Type: typing.Mapping[ cdk8s_plus_21.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 image_pull_policy : ImagePullPolicy Type: cdk8s_plus_21.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 liveness : Probe Type: cdk8s_plus_21.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 name : str Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 readiness : Probe Type: cdk8s_plus_21.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 startup : Probe Type: cdk8s_plus_21.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 volume_mounts : typing . List [ VolumeMount ] Type: typing.List[ cdk8s_plus_21.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 working_dir : str Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. DeploymentProps \u00b6 Properties for initialization of Deployment . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . DeploymentProps ( metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , default_selector : bool = None , replicas : typing . Union [ int , float ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_21.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_21.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata. default_selector Optional \u00b6 default_selector : bool Type: bool Default: true Automatically allocates a pod selector for this deployment. If this is set to false you must define your selector through deployment.podMetadata.addLabel() and deployment.selectByLabel() . replicas Optional \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Number of desired pods. EmptyDirVolumeOptions \u00b6 Options for volumes populated with an empty directory. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . EmptyDirVolumeOptions ( medium : EmptyDirMedium = None , size_limit : Size = None ) medium Optional \u00b6 medium : EmptyDirMedium Type: cdk8s_plus_21.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. size_limit Optional \u00b6 size_limit : Size Type: cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. EnvValueFromConfigMapOptions \u00b6 Options to specify an envionment variable value from a ConfigMap key. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . EnvValueFromConfigMapOptions ( optional : bool = None ) optional Optional \u00b6 optional : bool Type: bool Default: false Specify whether the ConfigMap or its key must be defined. EnvValueFromProcessOptions \u00b6 Options to specify an environment variable value from the process environment. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . EnvValueFromProcessOptions ( required : bool = None ) required Optional \u00b6 required : bool Type: bool Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. EnvValueFromSecretOptions \u00b6 Options to specify an environment variable value from a Secret. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . EnvValueFromSecretOptions ( optional : bool = None ) optional Optional \u00b6 optional : bool Type: bool Default: false Specify whether the Secret or its key must be defined. ExposeDeploymentViaIngressOptions \u00b6 Options for exposing a deployment via an ingress. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ExposeDeploymentViaIngressOptions ( name : str = None , port : typing . Union [ int , float ] = None , protocol : Protocol = None , service_type : ServiceType = None , target_port : typing . Union [ int , float ] = None , ingress : IngressV1Beta1 = None ) name Optional \u00b6 name : str Type: str Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_21.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. service_type Optional \u00b6 service_type : ServiceType Type: cdk8s_plus_21.ServiceType Default: ClusterIP. The type of the exposed service. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ingress Optional \u00b6 ingress : IngressV1Beta1 Type: cdk8s_plus_21.IngressV1Beta1 Default: An ingress will be automatically created. The ingress to add rules to. ExposeDeploymentViaServiceOptions \u00b6 Options for exposing a deployment via a service. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ExposeDeploymentViaServiceOptions ( name : str = None , port : typing . Union [ int , float ] = None , protocol : Protocol = None , service_type : ServiceType = None , target_port : typing . Union [ int , float ] = None ) name Optional \u00b6 name : str Type: str Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_21.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. service_type Optional \u00b6 service_type : ServiceType Type: cdk8s_plus_21.ServiceType Default: ClusterIP. The type of the exposed service. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ExposeServiceViaIngressOptions \u00b6 Options for exposing a service using an ingress. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ExposeServiceViaIngressOptions ( ingress : IngressV1Beta1 = None ) ingress Optional \u00b6 ingress : IngressV1Beta1 Type: cdk8s_plus_21.IngressV1Beta1 Default: An ingress will be automatically created. The ingress to add rules to. HttpGetProbeOptions \u00b6 Options for Probe.fromHttpGet() . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . HttpGetProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None , port : typing . Union [ int , float ] = None ) failure_threshold Optional \u00b6 failure_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 initial_delay_seconds : Duration Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 period_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 success_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 timeout_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to use when sending the GET request. IngressV1Beta1Props \u00b6 Properties for Ingress . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . IngressV1Beta1Props ( metadata : ApiObjectMetadata = None , default_backend : IngressV1Beta1Backend = None , rules : typing . List [ IngressV1Beta1Rule ] = None , tls : typing . List [ IngressV1Beta1Tls ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. default_backend Optional \u00b6 default_backend : IngressV1Beta1Backend Type: cdk8s_plus_21.IngressV1Beta1Backend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 rules : typing . List [ IngressV1Beta1Rule ] Type: typing.List[ cdk8s_plus_21.IngressV1Beta1Rule ] Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 tls : typing . List [ IngressV1Beta1Tls ] Type: typing.List[ cdk8s_plus_21.IngressV1Beta1Tls ] TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. IngressV1Beta1Rule \u00b6 Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . IngressV1Beta1Rule ( backend : IngressV1Beta1Backend , host : str = None , path : str = None ) backend Required \u00b6 backend : IngressV1Beta1Backend Type: cdk8s_plus_21.IngressV1Beta1Backend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 host : str Type: str Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 path : str Type: str Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. IngressV1Beta1Tls \u00b6 Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . IngressV1Beta1Tls ( hosts : typing . List [ str ] = None , secret : ISecret = None ) hosts Optional \u00b6 hosts : typing . List [ str ] Type: typing.List[ str ] Default: If unspecified, it defaults to the wildcard host setting for the loadbalancer controller fulfilling this Ingress. Hosts are a list of hosts included in the TLS certificate. The values in this list must match the name/s used in the TLS Secret. secret Optional \u00b6 secret : ISecret Type: cdk8s_plus_21.ISecret Default: If unspecified, it allows SSL routing based on SNI hostname. Secret is the secret that contains the certificate and key used to terminate SSL traffic on 443. If the SNI host in a listener conflicts with the \u201cHost\u201d header field used by an IngressRule, the SNI host is used for termination and value of the Host header is used for routing. JobProps \u00b6 Properties for initialization of Job . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . JobProps ( metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , active_deadline : Duration = None , backoff_limit : typing . Union [ int , float ] = None , ttl_after_finished : Duration = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_21.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_21.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata. active_deadline Optional \u00b6 active_deadline : Duration Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoff_limit Optional \u00b6 backoff_limit : typing . Union [ int , float ] Type: typing.Union[int, float] Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttl_after_finished Optional \u00b6 ttl_after_finished : Duration Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. MountOptions \u00b6 Options for mounts. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . MountOptions ( propagation : MountPropagation = None , read_only : bool = None , sub_path : str = None , sub_path_expr : str = None ) propagation Optional \u00b6 propagation : MountPropagation Type: cdk8s_plus_21.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. This field is beta in 1.10. read_only Optional \u00b6 read_only : bool Type: bool Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. sub_path Optional \u00b6 sub_path : str Type: str Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). sub_path_expr Optional \u00b6 sub_path_expr : str Type: str Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). SubPathExpr and SubPath are mutually exclusive. This field is beta in 1.15. subPathExpr and subPath are mutually exclusive. This field is beta in 1.15. PathMapping \u00b6 Maps a string key to a path within a volume. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . PathMapping ( path : str , mode : typing . Union [ int , float ] = None ) path Required \u00b6 path : str Type: str The relative path of the file to map the key to. May not be an absolute path. May not contain the path element \u2018..\u2019. May not start with the string \u2018..\u2019. mode Optional \u00b6 mode : typing . Union [ int , float ] Type: typing.Union[int, float] Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. PodProps \u00b6 Properties for initialization of Pod . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . PodProps ( metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_21.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_21.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodSpecProps \u00b6 Properties of a PodSpec . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . PodSpecProps ( containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_21.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_21.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodTemplateProps \u00b6 Properties of a PodTemplate . Adds metadata information on top of the spec. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . PodTemplateProps ( containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None ) containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_21.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_21.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata. ProbeOptions \u00b6 Probe options. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None ) failure_threshold Optional \u00b6 failure_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 initial_delay_seconds : Duration Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 period_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 success_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 timeout_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ResourceProps \u00b6 Initialization properties for resources. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ResourceProps ( metadata : ApiObjectMetadata = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. SecretProps \u00b6 Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . SecretProps ( metadata : ApiObjectMetadata = None , string_data : typing . Mapping [ str ] = None , type : str = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. string_data Optional \u00b6 string_data : typing . Mapping [ str ] Type: typing.Mapping[ str ] stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 type : str Type: str Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. SecretValue \u00b6 Represents a specific value in JSON secret. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . SecretValue ( key : str , secret : ISecret ) key Required \u00b6 key : str Type: str The JSON key. secret Required \u00b6 secret : ISecret Type: cdk8s_plus_21.ISecret The secret. ServiceAccountProps \u00b6 Properties for initialization of ServiceAccount . Properties for initialization of ServiceAccount . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ServiceAccountProps ( metadata : ApiObjectMetadata = None , secrets : typing . List [ ISecret ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. secrets Optional \u00b6 secrets : typing . List [ ISecret ] Type: typing.List[ cdk8s_plus_21.ISecret ] List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret ServiceIngressV1BetaBackendOptions \u00b6 Options for setting up backends for ingress rules. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ServiceIngressV1BetaBackendOptions ( port : typing . Union [ int , float ] = None ) port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. If the service exposes multiple ports, this option must be specified. If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. ServicePort \u00b6 Definition of a service port. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ServicePort ( name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None , port : typing . Union [ int , float ] ) name Optional \u00b6 name : str Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 node_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_21.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. port Required \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] The port number the service will bind to. ServicePortOptions \u00b6 Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ServicePortOptions ( name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None ) name Optional \u00b6 name : str Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 node_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_21.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. ServiceProps \u00b6 Properties for initialization of Service . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . ServiceProps ( metadata : ApiObjectMetadata = None , cluster_i_p : str = None , external_i_ps : typing . List [ str ] = None , external_name : str = None , load_balancer_source_ranges : typing . List [ str ] = None , ports : typing . List [ ServicePort ] = None , type : ServiceType = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. cluster_i_p Optional \u00b6 cluster_i_p : str Type: str Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies external_i_ps Optional \u00b6 external_i_ps : typing . List [ str ] Type: typing.List[ str ] Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. external_name Optional \u00b6 external_name : str Type: str Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. load_balancer_source_ranges Optional \u00b6 load_balancer_source_ranges : typing . List [ str ] Type: typing.List[ str ] A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 ports : typing . List [ ServicePort ] Type: typing.List[ cdk8s_plus_21.ServicePort ] The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 type : ServiceType Type: cdk8s_plus_21.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types StatefulSetProps \u00b6 Properties for initialization of StatefulSet . Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . StatefulSetProps ( metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , service : Service , default_selector : bool = None , pod_management_policy : PodManagementPolicy = None , replicas : typing . Union [ int , float ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_21.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_21.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata. service Required \u00b6 service : Service Type: cdk8s_plus_21.Service Service to associate with the statefulset. default_selector Optional \u00b6 default_selector : bool Type: bool Default: true Automatically allocates a pod selector for this statefulset. If this is set to false you must define your selector through statefulset.podMetadata.addLabel() and statefulset.selectByLabel() . pod_management_policy Optional \u00b6 pod_management_policy : PodManagementPolicy Type: cdk8s_plus_21.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Number of desired pods. VolumeMount \u00b6 Mount a volume from the pod to the container. Initializer \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . VolumeMount ( propagation : MountPropagation = None , read_only : bool = None , sub_path : str = None , sub_path_expr : str = None , path : str , volume : Volume ) propagation Optional \u00b6 propagation : MountPropagation Type: cdk8s_plus_21.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. This field is beta in 1.10. read_only Optional \u00b6 read_only : bool Type: bool Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. sub_path Optional \u00b6 sub_path : str Type: str Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). sub_path_expr Optional \u00b6 sub_path_expr : str Type: str Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). SubPathExpr and SubPath are mutually exclusive. This field is beta in 1.15. subPathExpr and subPath are mutually exclusive. This field is beta in 1.15. path Required \u00b6 path : str Type: str Path within the container at which the volume should be mounted. Must not contain \u2018:\u2019. volume Required \u00b6 volume : Volume Type: cdk8s_plus_21.Volume The volume to mount. Classes \u00b6 Container \u00b6 A single application container that you want to run within a pod. Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_21.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_21.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_21.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_21.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_21.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_21.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. Methods \u00b6 add_env \u00b6 def add_env ( name : str , value : EnvValue ) name Required \u00b6 Type: str The variable name. value Required \u00b6 Type: cdk8s_plus_21.EnvValue The variable value. mount \u00b6 def mount ( path : str , volume : Volume , propagation : MountPropagation = None , read_only : bool = None , sub_path : str = None , sub_path_expr : str = None ) path Required \u00b6 Type: str The desired path in the container. volume Required \u00b6 Type: cdk8s_plus_21.Volume The volume to mount. propagation Optional \u00b6 Type: cdk8s_plus_21.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. This field is beta in 1.10. read_only Optional \u00b6 Type: bool Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. sub_path Optional \u00b6 Type: str Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). sub_path_expr Optional \u00b6 Type: str Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). SubPathExpr and SubPath are mutually exclusive. This field is beta in 1.15. subPathExpr and subPath are mutually exclusive. This field is beta in 1.15. Properties \u00b6 env Required \u00b6 env : typing . Mapping [ EnvValue ] Type: typing.Mapping[ cdk8s_plus_21.EnvValue ] The environment variables for this container. Returns a copy. To add environment variables use addEnv() . image Required \u00b6 image : str Type: str The container image. image_pull_policy Required \u00b6 image_pull_policy : ImagePullPolicy Type: cdk8s_plus_21.ImagePullPolicy Image pull policy for this container. mounts Required \u00b6 mounts : typing . List [ VolumeMount ] Type: typing.List[ cdk8s_plus_21.VolumeMount ] Volume mounts configured for this container. name Required \u00b6 name : str Type: str The name of the container. args Optional \u00b6 args : typing . List [ str ] Type: typing.List[ str ] Arguments to the entrypoint. command Optional \u00b6 command : typing . List [ str ] Type: typing.List[ str ] Entrypoint array (the command to execute when the container starts). port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] The port this container exposes. working_dir Optional \u00b6 working_dir : str Type: str The working directory inside the container. EnvValue \u00b6 Utility class for creating reading env values from various sources. Static Functions \u00b6 from_config_map \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . EnvValue . from_config_map ( config_map : IConfigMap , key : str , optional : bool = None ) config_map Required \u00b6 Type: cdk8s_plus_21.IConfigMap The config map. key Required \u00b6 Type: str The key to extract the value from. optional Optional \u00b6 Type: bool Default: false Specify whether the ConfigMap or its key must be defined. from_process \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . EnvValue . from_process ( key : str , required : bool = None ) key Required \u00b6 Type: str The key to read. required Optional \u00b6 Type: bool Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. from_secret_value \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . EnvValue . from_secret_value ( key : str , secret : ISecret , optional : bool = None ) key Required \u00b6 Type: str The JSON key. secret Required \u00b6 Type: cdk8s_plus_21.ISecret The secret. optional Optional \u00b6 Type: bool Default: false Specify whether the Secret or its key must be defined. from_value \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . EnvValue . from_value ( value : str ) value Required \u00b6 Type: str The value. Properties \u00b6 value Optional \u00b6 value : typing . Any Type: typing.Any value_from Optional \u00b6 value_from : typing . Any Type: typing.Any IngressV1Beta1Backend \u00b6 The backend for an ingress path. Static Functions \u00b6 from_service \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . IngressV1Beta1Backend . from_service ( service : Service , port : typing . Union [ int , float ] = None ) service Required \u00b6 Type: cdk8s_plus_21.Service The service object. port Optional \u00b6 Type: typing.Union[int, float] Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. If the service exposes multiple ports, this option must be specified. If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. PodSpec \u00b6 Implements: cdk8s_plus_21.IPodSpec Provides read/write capabilities ontop of a PodSpecProps . Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . PodSpec ( containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) containers Optional \u00b6 Type: typing.List[ cdk8s_plus_21.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_21.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_21.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_21.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_21.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_21.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_21.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_21.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( volume : Volume ) volume Required \u00b6 Type: cdk8s_plus_21.Volume Properties \u00b6 containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_21.Container ] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_21.Volume ] The volumes associated with this pod. Use addVolume to add volumes. restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_21.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_21.IServiceAccount The service account used to run this pod. PodTemplate \u00b6 Implements: cdk8s_plus_21.IPodTemplate Provides read/write capabilities ontop of a PodTemplateProps . Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . PodTemplate ( containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None ) containers Optional \u00b6 Type: typing.List[ cdk8s_plus_21.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_21.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata. Properties \u00b6 pod_metadata Required \u00b6 pod_metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. Probe \u00b6 Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic. Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Probe () Static Functions \u00b6 from_command \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Probe . from_command ( command : typing . List [ str ], failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None ) command Required \u00b6 Type: typing.List[ str ] The command to execute. failure_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes from_http_get \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Probe . from_http_get ( path : str , failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None , port : typing . Union [ int , float ] = None ) path Required \u00b6 Type: str The URL path to hit. failure_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to use when sending the GET request. Volume \u00b6 Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes Initializers \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Volume ( name : str , config : typing . Any ) name Required \u00b6 Type: str config Required \u00b6 Type: typing.Any Static Functions \u00b6 from_config_map \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Volume . from_config_map ( config_map : IConfigMap , default_mode : typing . Union [ int , float ] = None , items : typing . Mapping [ PathMapping ] = None , name : str = None , optional : bool = None ) config_map Required \u00b6 Type: cdk8s_plus_21.IConfigMap The config map to use to populate the volume. default_mode Optional \u00b6 Type: typing.Union[int, float] Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_21.PathMapping ] Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 Type: str Default: auto-generated The volume name. optional Optional \u00b6 Type: bool Default: undocumented Specify whether the ConfigMap or its keys must be defined. from_empty_dir \u00b6 import cdk8s_plus_21 cdk8s_plus_21 . Volume . from_empty_dir ( name : str , medium : EmptyDirMedium = None , size_limit : Size = None ) name Required \u00b6 Type: str medium Optional \u00b6 Type: cdk8s_plus_21.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. size_limit Optional \u00b6 Type: cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. Properties \u00b6 name Required \u00b6 name : str Type: str Protocols \u00b6 IConfigMap \u00b6 Extends: cdk8s_plus_21.IResource Implemented By: cdk8s_plus_21.ConfigMap , cdk8s_plus_21.IConfigMap Represents a config map. Properties \u00b6 name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IPodSpec \u00b6 Implemented By: cdk8s_plus_21.Deployment , cdk8s_plus_21.Job , cdk8s_plus_21.Pod , cdk8s_plus_21.PodSpec , cdk8s_plus_21.PodTemplate , cdk8s_plus_21.StatefulSet , cdk8s_plus_21.IPodSpec , cdk8s_plus_21.IPodTemplate Represents a resource that can be configured with a kuberenets pod spec. (e.g Deployment , Job , Pod , \u2026). Use the PodSpec class as an implementation helper. Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_21.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_21.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_21.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_21.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_21.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_21.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( volume : Volume ) volume Required \u00b6 Type: cdk8s_plus_21.Volume The volume. Properties \u00b6 containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_21.Container ] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_21.Volume ] The volumes associated with this pod. Use addVolume to add volumes. restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_21.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_21.IServiceAccount The service account used to run this pod. IPodTemplate \u00b6 Extends: cdk8s_plus_21.IPodSpec Implemented By: cdk8s_plus_21.Deployment , cdk8s_plus_21.Job , cdk8s_plus_21.PodTemplate , cdk8s_plus_21.StatefulSet , cdk8s_plus_21.IPodTemplate Represents a resource that can be configured with a kuberenets pod template. (e.g Deployment , Job , \u2026). Use the PodTemplate class as an implementation helper. Properties \u00b6 containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_21.Container ] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_21.Volume ] The volumes associated with this pod. Use addVolume to add volumes. restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_21.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_21.IServiceAccount The service account used to run this pod. pod_metadata Required \u00b6 pod_metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. IResource \u00b6 Implemented By: cdk8s_plus_21.ConfigMap , cdk8s_plus_21.Deployment , cdk8s_plus_21.IngressV1Beta1 , cdk8s_plus_21.Job , cdk8s_plus_21.Pod , cdk8s_plus_21.Resource , cdk8s_plus_21.Secret , cdk8s_plus_21.Service , cdk8s_plus_21.ServiceAccount , cdk8s_plus_21.StatefulSet , cdk8s_plus_21.IConfigMap , cdk8s_plus_21.IResource , cdk8s_plus_21.ISecret , cdk8s_plus_21.IServiceAccount Represents a resource. Properties \u00b6 name Required \u00b6 name : str Type: str The Kubernetes name of this resource. ISecret \u00b6 Extends: cdk8s_plus_21.IResource Implemented By: cdk8s_plus_21.Secret , cdk8s_plus_21.ISecret Properties \u00b6 name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IServiceAccount \u00b6 Extends: cdk8s_plus_21.IResource Implemented By: cdk8s_plus_21.ServiceAccount , cdk8s_plus_21.IServiceAccount Properties \u00b6 name Required \u00b6 name : str Type: str The Kubernetes name of this resource. Enums \u00b6 EmptyDirMedium \u00b6 The medium on which to store the volume. DEFAULT \u00b6 The default volume of the backing node. MEMORY \u00b6 Mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. ImagePullPolicy \u00b6 ALWAYS \u00b6 Every time the kubelet launches a container, the kubelet queries the container image registry to resolve the name to an image digest. If the kubelet has a container image with that exact digest cached locally, the kubelet uses its cached image; otherwise, the kubelet downloads (pulls) the image with the resolved digest, and uses that image to launch the container. Default is Always if ImagePullPolicy is omitted and either the image tag is :latest or the image tag is omitted. IF_NOT_PRESENT \u00b6 The image is pulled only if it is not already present locally. Default is IfNotPresent if ImagePullPolicy is omitted and the image tag is present but not :latest NEVER \u00b6 The image is assumed to exist locally. No attempt is made to pull the image. MountPropagation \u00b6 NONE \u00b6 This volume mount will not receive any subsequent mounts that are mounted to this volume or any of its subdirectories by the host. In similar fashion, no mounts created by the Container will be visible on the host. This is the default mode. This mode is equal to private mount propagation as described in the Linux kernel documentation HOST_TO_CONTAINER \u00b6 This volume mount will receive all subsequent mounts that are mounted to this volume or any of its subdirectories. In other words, if the host mounts anything inside the volume mount, the Container will see it mounted there. Similarly, if any Pod with Bidirectional mount propagation to the same volume mounts anything there, the Container with HostToContainer mount propagation will see it. This mode is equal to rslave mount propagation as described in the Linux kernel documentation BIDIRECTIONAL \u00b6 This volume mount behaves the same the HostToContainer mount. In addition, all volume mounts created by the Container will be propagated back to the host and to all Containers of all Pods that use the same volume A typical use case for this mode is a Pod with a FlexVolume or CSI driver or a Pod that needs to mount something on the host using a hostPath volume. This mode is equal to rshared mount propagation as described in the Linux kernel documentation Caution: Bidirectional mount propagation can be dangerous. It can damage the host operating system and therefore it is allowed only in privileged Containers. Familiarity with Linux kernel behavior is strongly recommended. In addition, any volume mounts created by Containers in Pods must be destroyed (unmounted) by the Containers on termination. PodManagementPolicy \u00b6 Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once. ORDERED_READY \u00b6 PARALLEL \u00b6 Protocol \u00b6 TCP \u00b6 UDP \u00b6 SCTP \u00b6 RestartPolicy \u00b6 Restart policy for all containers within the pod. ALWAYS \u00b6 Always restart the pod after it exits. ON_FAILURE \u00b6 Only restart if the pod exits with a non-zero exit code. NEVER \u00b6 Never restart the pod. ServiceType \u00b6 For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP. CLUSTER_IP \u00b6 Exposes the Service on a cluster-internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default ServiceType NODE_PORT \u00b6 Exposes the Service on each Node\u2019s IP at a static port (the NodePort). A ClusterIP Service, to which the NodePort Service routes, is automatically created. You\u2019ll be able to contact the NodePort Service, from outside the cluster, by requesting : . LOAD_BALANCER \u00b6 Exposes the Service externally using a cloud provider\u2019s load balancer. NodePort and ClusterIP Services, to which the external load balancer routes, are automatically created. EXTERNAL_NAME \u00b6 Maps the Service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value. No proxying of any kind is set up. Note: You need either kube-dns version 1.7 or CoreDNS version 0.0.8 or higher to use the ExternalName type.","title":"Python"},{"location":"reference/cdk8s-plus-21/python/#cdk8s-plus-21-python","text":"","title":"cdk8s-plus-21 (Python) "},{"location":"reference/cdk8s-plus-21/python/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s-plus-21/python/#configmap","text":"Implements: cdk8s_plus_21.IConfigMap ConfigMap holds configuration data for pods to consume.","title":"ConfigMap "},{"location":"reference/cdk8s-plus-21/python/#deployment","text":"Implements: cdk8s_plus_21.IPodTemplate A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below.","title":"Deployment "},{"location":"reference/cdk8s-plus-21/python/#use-case","text":"The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore.","title":"Use Case"},{"location":"reference/cdk8s-plus-21/python/#ingressv1beta1","text":"Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.","title":"IngressV1Beta1 "},{"location":"reference/cdk8s-plus-21/python/#job","text":"Implements: cdk8s_plus_21.IPodTemplate A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel.","title":"Job "},{"location":"reference/cdk8s-plus-21/python/#pod","text":"Implements: cdk8s_plus_21.IPodSpec Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.","title":"Pod "},{"location":"reference/cdk8s-plus-21/python/#resource","text":"Implements: cdk8s_plus_21.IResource Base class for all Kubernetes objects in stdk8s. Represents a single resource.","title":"Resource "},{"location":"reference/cdk8s-plus-21/python/#secret","text":"Implements: cdk8s_plus_21.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret","title":"Secret "},{"location":"reference/cdk8s-plus-21/python/#service","text":"An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods.","title":"Service "},{"location":"reference/cdk8s-plus-21/python/#serviceaccount","text":"Implements: cdk8s_plus_21.IServiceAccount A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account","title":"ServiceAccount "},{"location":"reference/cdk8s-plus-21/python/#statefulset","text":"Implements: cdk8s_plus_21.IPodTemplate StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed.","title":"StatefulSet "},{"location":"reference/cdk8s-plus-21/python/#using-statefulsets","text":"StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates.","title":"Using StatefulSets"},{"location":"reference/cdk8s-plus-21/python/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s-plus-21/python/#adddeploymentoptions","text":"Options to add a deployment to a service.","title":"AddDeploymentOptions "},{"location":"reference/cdk8s-plus-21/python/#adddirectoryoptions","text":"Options for configmap.addDirectory() .","title":"AddDirectoryOptions "},{"location":"reference/cdk8s-plus-21/python/#commandprobeoptions","text":"Options for Probe.fromCommand() .","title":"CommandProbeOptions "},{"location":"reference/cdk8s-plus-21/python/#configmapprops","text":"Properties for initialization of ConfigMap .","title":"ConfigMapProps "},{"location":"reference/cdk8s-plus-21/python/#configmapvolumeoptions","text":"Options for the ConfigMap-based volume.","title":"ConfigMapVolumeOptions "},{"location":"reference/cdk8s-plus-21/python/#containerprops","text":"Properties for creating a container.","title":"ContainerProps "},{"location":"reference/cdk8s-plus-21/python/#deploymentprops","text":"Properties for initialization of Deployment .","title":"DeploymentProps "},{"location":"reference/cdk8s-plus-21/python/#emptydirvolumeoptions","text":"Options for volumes populated with an empty directory.","title":"EmptyDirVolumeOptions "},{"location":"reference/cdk8s-plus-21/python/#envvaluefromconfigmapoptions","text":"Options to specify an envionment variable value from a ConfigMap key.","title":"EnvValueFromConfigMapOptions "},{"location":"reference/cdk8s-plus-21/python/#envvaluefromprocessoptions","text":"Options to specify an environment variable value from the process environment.","title":"EnvValueFromProcessOptions "},{"location":"reference/cdk8s-plus-21/python/#envvaluefromsecretoptions","text":"Options to specify an environment variable value from a Secret.","title":"EnvValueFromSecretOptions "},{"location":"reference/cdk8s-plus-21/python/#exposedeploymentviaingressoptions","text":"Options for exposing a deployment via an ingress.","title":"ExposeDeploymentViaIngressOptions "},{"location":"reference/cdk8s-plus-21/python/#exposedeploymentviaserviceoptions","text":"Options for exposing a deployment via a service.","title":"ExposeDeploymentViaServiceOptions "},{"location":"reference/cdk8s-plus-21/python/#exposeserviceviaingressoptions","text":"Options for exposing a service using an ingress.","title":"ExposeServiceViaIngressOptions "},{"location":"reference/cdk8s-plus-21/python/#httpgetprobeoptions","text":"Options for Probe.fromHttpGet() .","title":"HttpGetProbeOptions "},{"location":"reference/cdk8s-plus-21/python/#ingressv1beta1props","text":"Properties for Ingress .","title":"IngressV1Beta1Props "},{"location":"reference/cdk8s-plus-21/python/#ingressv1beta1rule","text":"Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path.","title":"IngressV1Beta1Rule "},{"location":"reference/cdk8s-plus-21/python/#ingressv1beta1tls","text":"Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination.","title":"IngressV1Beta1Tls "},{"location":"reference/cdk8s-plus-21/python/#jobprops","text":"Properties for initialization of Job .","title":"JobProps "},{"location":"reference/cdk8s-plus-21/python/#mountoptions","text":"Options for mounts.","title":"MountOptions "},{"location":"reference/cdk8s-plus-21/python/#pathmapping","text":"Maps a string key to a path within a volume.","title":"PathMapping "},{"location":"reference/cdk8s-plus-21/python/#podprops","text":"Properties for initialization of Pod .","title":"PodProps "},{"location":"reference/cdk8s-plus-21/python/#podspecprops","text":"Properties of a PodSpec .","title":"PodSpecProps "},{"location":"reference/cdk8s-plus-21/python/#podtemplateprops","text":"Properties of a PodTemplate . Adds metadata information on top of the spec.","title":"PodTemplateProps "},{"location":"reference/cdk8s-plus-21/python/#probeoptions","text":"Probe options.","title":"ProbeOptions "},{"location":"reference/cdk8s-plus-21/python/#resourceprops","text":"Initialization properties for resources.","title":"ResourceProps "},{"location":"reference/cdk8s-plus-21/python/#secretprops","text":"","title":"SecretProps "},{"location":"reference/cdk8s-plus-21/python/#secretvalue","text":"Represents a specific value in JSON secret.","title":"SecretValue "},{"location":"reference/cdk8s-plus-21/python/#serviceaccountprops","text":"Properties for initialization of ServiceAccount . Properties for initialization of ServiceAccount .","title":"ServiceAccountProps "},{"location":"reference/cdk8s-plus-21/python/#serviceingressv1betabackendoptions","text":"Options for setting up backends for ingress rules.","title":"ServiceIngressV1BetaBackendOptions "},{"location":"reference/cdk8s-plus-21/python/#serviceport","text":"Definition of a service port.","title":"ServicePort "},{"location":"reference/cdk8s-plus-21/python/#serviceportoptions","text":"","title":"ServicePortOptions "},{"location":"reference/cdk8s-plus-21/python/#serviceprops","text":"Properties for initialization of Service .","title":"ServiceProps "},{"location":"reference/cdk8s-plus-21/python/#statefulsetprops","text":"Properties for initialization of StatefulSet .","title":"StatefulSetProps "},{"location":"reference/cdk8s-plus-21/python/#volumemount","text":"Mount a volume from the pod to the container.","title":"VolumeMount "},{"location":"reference/cdk8s-plus-21/python/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s-plus-21/python/#container","text":"A single application container that you want to run within a pod.","title":"Container "},{"location":"reference/cdk8s-plus-21/python/#envvalue","text":"Utility class for creating reading env values from various sources.","title":"EnvValue "},{"location":"reference/cdk8s-plus-21/python/#ingressv1beta1backend","text":"The backend for an ingress path.","title":"IngressV1Beta1Backend "},{"location":"reference/cdk8s-plus-21/python/#podspec","text":"Implements: cdk8s_plus_21.IPodSpec Provides read/write capabilities ontop of a PodSpecProps .","title":"PodSpec "},{"location":"reference/cdk8s-plus-21/python/#podtemplate","text":"Implements: cdk8s_plus_21.IPodTemplate Provides read/write capabilities ontop of a PodTemplateProps .","title":"PodTemplate "},{"location":"reference/cdk8s-plus-21/python/#probe","text":"Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.","title":"Probe "},{"location":"reference/cdk8s-plus-21/python/#volume","text":"Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes","title":"Volume "},{"location":"reference/cdk8s-plus-21/python/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s-plus-21/python/#iconfigmap","text":"Extends: cdk8s_plus_21.IResource Implemented By: cdk8s_plus_21.ConfigMap , cdk8s_plus_21.IConfigMap Represents a config map.","title":"IConfigMap "},{"location":"reference/cdk8s-plus-21/python/#ipodspec","text":"Implemented By: cdk8s_plus_21.Deployment , cdk8s_plus_21.Job , cdk8s_plus_21.Pod , cdk8s_plus_21.PodSpec , cdk8s_plus_21.PodTemplate , cdk8s_plus_21.StatefulSet , cdk8s_plus_21.IPodSpec , cdk8s_plus_21.IPodTemplate Represents a resource that can be configured with a kuberenets pod spec. (e.g Deployment , Job , Pod , \u2026). Use the PodSpec class as an implementation helper.","title":"IPodSpec "},{"location":"reference/cdk8s-plus-21/python/#ipodtemplate","text":"Extends: cdk8s_plus_21.IPodSpec Implemented By: cdk8s_plus_21.Deployment , cdk8s_plus_21.Job , cdk8s_plus_21.PodTemplate , cdk8s_plus_21.StatefulSet , cdk8s_plus_21.IPodTemplate Represents a resource that can be configured with a kuberenets pod template. (e.g Deployment , Job , \u2026). Use the PodTemplate class as an implementation helper.","title":"IPodTemplate "},{"location":"reference/cdk8s-plus-21/python/#iresource","text":"Implemented By: cdk8s_plus_21.ConfigMap , cdk8s_plus_21.Deployment , cdk8s_plus_21.IngressV1Beta1 , cdk8s_plus_21.Job , cdk8s_plus_21.Pod , cdk8s_plus_21.Resource , cdk8s_plus_21.Secret , cdk8s_plus_21.Service , cdk8s_plus_21.ServiceAccount , cdk8s_plus_21.StatefulSet , cdk8s_plus_21.IConfigMap , cdk8s_plus_21.IResource , cdk8s_plus_21.ISecret , cdk8s_plus_21.IServiceAccount Represents a resource.","title":"IResource "},{"location":"reference/cdk8s-plus-21/python/#isecret","text":"Extends: cdk8s_plus_21.IResource Implemented By: cdk8s_plus_21.Secret , cdk8s_plus_21.ISecret","title":"ISecret "},{"location":"reference/cdk8s-plus-21/python/#iserviceaccount","text":"Extends: cdk8s_plus_21.IResource Implemented By: cdk8s_plus_21.ServiceAccount , cdk8s_plus_21.IServiceAccount","title":"IServiceAccount "},{"location":"reference/cdk8s-plus-21/python/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s-plus-21/python/#emptydirmedium","text":"The medium on which to store the volume.","title":"EmptyDirMedium "},{"location":"reference/cdk8s-plus-21/python/#imagepullpolicy","text":"","title":"ImagePullPolicy "},{"location":"reference/cdk8s-plus-21/python/#mountpropagation","text":"","title":"MountPropagation "},{"location":"reference/cdk8s-plus-21/python/#podmanagementpolicy","text":"Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.","title":"PodManagementPolicy "},{"location":"reference/cdk8s-plus-21/python/#protocol","text":"","title":"Protocol "},{"location":"reference/cdk8s-plus-21/python/#restartpolicy","text":"Restart policy for all containers within the pod.","title":"RestartPolicy "},{"location":"reference/cdk8s-plus-21/python/#servicetype","text":"For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP.","title":"ServiceType "},{"location":"reference/cdk8s-plus-21/typescript/","text":"cdk8s-plus-21 (TypeScript) \u00b6 Constructs \u00b6 ConfigMap \u00b6 Implements: cdk8s-plus-21.IConfigMap ConfigMap holds configuration data for pods to consume. Initializers \u00b6 import { ConfigMap } from 'cdk8s-plus-21' new ConfigMap ( scope : Construct , id : string , props? : ConfigMapProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-21.ConfigMapProps Methods \u00b6 addBinaryData \u00b6 public addBinaryData ( key : string , value : string ) key Required \u00b6 Type: string The key. value Required \u00b6 Type: string The value. addData \u00b6 public addData ( key : string , value : string ) key Required \u00b6 Type: string The key. value Required \u00b6 Type: string The value. addDirectory \u00b6 public addDirectory ( localDir : string , options? : AddDirectoryOptions ) localDir Required \u00b6 Type: string A path to a local directory. options Optional \u00b6 Type: cdk8s-plus-21.AddDirectoryOptions Options. addFile \u00b6 public addFile ( localFile : string , key? : string ) localFile Required \u00b6 Type: string The path to the local file. key Optional \u00b6 Type: string The ConfigMap key (default to the file name). Static Functions \u00b6 fromConfigMapName \u00b6 import { ConfigMap } from 'cdk8s-plus-21' ConfigMap . fromConfigMapName ( name : string ) name Required \u00b6 Type: string The name of the config map to import. Properties \u00b6 binaryData Required \u00b6 public readonly binaryData : {[ key : string ] : string }; Type: {[ key: string ]: string } The binary data associated with this config map. Returns a copy. To add data records, use addBinaryData() or addData() . data Required \u00b6 public readonly data : {[ key : string ] : string }; Type: {[ key: string ]: string } The data associated with this config map. Returns an copy. To add data records, use addData() or addBinaryData() . Deployment \u00b6 Implements: cdk8s-plus-21.IPodTemplate A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case \u00b6 The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore. Initializers \u00b6 import { Deployment } from 'cdk8s-plus-21' new Deployment ( scope : Construct , id : string , props? : DeploymentProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-21.DeploymentProps Methods \u00b6 addContainer \u00b6 public addContainer ( container : ContainerProps ) container Required \u00b6 Type: cdk8s-plus-21.ContainerProps addVolume \u00b6 public addVolume ( volume : Volume ) volume Required \u00b6 Type: cdk8s-plus-21.Volume exposeViaIngress \u00b6 public exposeViaIngress ( path : string , options? : ExposeDeploymentViaIngressOptions ) path Required \u00b6 Type: string The ingress path to register under. options Optional \u00b6 Type: cdk8s-plus-21.ExposeDeploymentViaIngressOptions Additional options. exposeViaService \u00b6 public exposeViaService ( options? : ExposeDeploymentViaServiceOptions ) options Optional \u00b6 Type: cdk8s-plus-21.ExposeDeploymentViaServiceOptions Options to determine details of the service and port exposed. selectByLabel \u00b6 public selectByLabel ( key : string , value : string ) key Required \u00b6 Type: string The label key. value Required \u00b6 Type: string The label value. Properties \u00b6 containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-21.Container [] The containers belonging to the pod. Use addContainer to add containers. labelSelector Required \u00b6 public readonly labelSelector : {[ key : string ] : string }; Type: {[ key: string ]: string } The labels this deployment will match against in order to select pods. Returns a a copy. Use selectByLabel() to add labels. podMetadata Required \u00b6 public readonly podMetadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. replicas Required \u00b6 public readonly replicas : number ; Type: number Number of desired pods. volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-21.Volume [] The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-21.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-21.IServiceAccount The service account used to run this pod. IngressV1Beta1 \u00b6 Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. Initializers \u00b6 import { IngressV1Beta1 } from 'cdk8s-plus-21' new IngressV1Beta1 ( scope : Construct , id : string , props? : IngressV1Beta1Props ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-21.IngressV1Beta1Props Methods \u00b6 addDefaultBackend \u00b6 public addDefaultBackend ( backend : IngressV1Beta1Backend ) backend Required \u00b6 Type: cdk8s-plus-21.IngressV1Beta1Backend The backend to use for requests that do not match any rule. addHostDefaultBackend \u00b6 public addHostDefaultBackend ( host : string , backend : IngressV1Beta1Backend ) host Required \u00b6 Type: string The host name to match. backend Required \u00b6 Type: cdk8s-plus-21.IngressV1Beta1Backend The backend to route to. addHostRule \u00b6 public addHostRule ( host : string , path : string , backend : IngressV1Beta1Backend ) host Required \u00b6 Type: string The host name. path Required \u00b6 Type: string The HTTP path. backend Required \u00b6 Type: cdk8s-plus-21.IngressV1Beta1Backend The backend to route requests to. addRule \u00b6 public addRule ( path : string , backend : IngressV1Beta1Backend ) path Required \u00b6 Type: string The HTTP path. backend Required \u00b6 Type: cdk8s-plus-21.IngressV1Beta1Backend The backend to route requests to. addRules \u00b6 public addRules ( rules : IngressV1Beta1Rule ) rules Required \u00b6 Type: cdk8s-plus-21.IngressV1Beta1Rule The rules to add. addTls \u00b6 public addTls ( tls : IngressV1Beta1Tls []) tls Required \u00b6 Type: cdk8s-plus-21.IngressV1Beta1Tls [] Job \u00b6 Implements: cdk8s-plus-21.IPodTemplate A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel. Initializers \u00b6 import { Job } from 'cdk8s-plus-21' new Job ( scope : Construct , id : string , props? : JobProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-21.JobProps Methods \u00b6 addContainer \u00b6 public addContainer ( container : ContainerProps ) container Required \u00b6 Type: cdk8s-plus-21.ContainerProps addVolume \u00b6 public addVolume ( volume : Volume ) volume Required \u00b6 Type: cdk8s-plus-21.Volume Properties \u00b6 containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-21.Container [] The containers belonging to the pod. Use addContainer to add containers. podMetadata Required \u00b6 public readonly podMetadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-21.Volume [] The volumes associated with this pod. Use addVolume to add volumes. activeDeadline Optional \u00b6 public readonly activeDeadline : Duration ; Type: cdk8s.Duration Duration before job is terminated. If undefined, there is no deadline. backoffLimit Optional \u00b6 public readonly backoffLimit : number ; Type: number Number of retries before marking failed. restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-21.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-21.IServiceAccount The service account used to run this pod. ttlAfterFinished Optional \u00b6 public readonly ttlAfterFinished : Duration ; Type: cdk8s.Duration TTL before the job is deleted after it is finished. Pod \u00b6 Implements: cdk8s-plus-21.IPodSpec Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts. Initializers \u00b6 import { Pod } from 'cdk8s-plus-21' new Pod ( scope : Construct , id : string , props? : PodProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-21.PodProps Methods \u00b6 addContainer \u00b6 public addContainer ( container : ContainerProps ) container Required \u00b6 Type: cdk8s-plus-21.ContainerProps addVolume \u00b6 public addVolume ( volume : Volume ) volume Required \u00b6 Type: cdk8s-plus-21.Volume Properties \u00b6 containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-21.Container [] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-21.Volume [] The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-21.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-21.IServiceAccount The service account used to run this pod. Resource \u00b6 Implements: cdk8s-plus-21.IResource Base class for all Kubernetes objects in stdk8s. Represents a single resource. Initializers \u00b6 import { Resource } from 'cdk8s-plus-21' new Resource ( scope : Construct , id : string , options? : ConstructOptions ) scope Required \u00b6 Type: constructs.Construct The scope in which to define this construct. id Required \u00b6 Type: string The scoped construct ID. Must be unique amongst siblings. If the ID includes a path separator ( / ), then it will be replaced by double dash -- . options Optional \u00b6 Type: constructs.ConstructOptions Options. Properties \u00b6 metadata Required \u00b6 public readonly metadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition name Required \u00b6 public readonly name : string ; Type: string The name of this API object. Secret \u00b6 Implements: cdk8s-plus-21.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret Initializers \u00b6 import { Secret } from 'cdk8s-plus-21' new Secret ( scope : Construct , id : string , props? : SecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-21.SecretProps Methods \u00b6 addStringData \u00b6 public addStringData ( key : string , value : string ) key Required \u00b6 Type: string Key. value Required \u00b6 Type: string Value. getStringData \u00b6 public getStringData ( key : string ) key Required \u00b6 Type: string Key. Static Functions \u00b6 fromSecretName \u00b6 import { Secret } from 'cdk8s-plus-21' Secret . fromSecretName ( name : string ) name Required \u00b6 Type: string The name of the secret to reference. Service \u00b6 An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods. Initializers \u00b6 import { Service } from 'cdk8s-plus-21' new Service ( scope : Construct , id : string , props? : ServiceProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-21.ServiceProps Methods \u00b6 addDeployment \u00b6 public addDeployment ( deployment : Deployment , options? : AddDeploymentOptions ) deployment Required \u00b6 Type: cdk8s-plus-21.Deployment The deployment to expose. options Optional \u00b6 Type: cdk8s-plus-21.AddDeploymentOptions Optional settings for the port. addSelector \u00b6 public addSelector ( label : string , value : string ) label Required \u00b6 Type: string The label key. value Required \u00b6 Type: string The label value. exposeViaIngress \u00b6 public exposeViaIngress ( path : string , options? : ExposeServiceViaIngressOptions ) path Required \u00b6 Type: string The path to expose the service under. options Optional \u00b6 Type: cdk8s-plus-21.ExposeServiceViaIngressOptions Additional options. serve \u00b6 public serve ( port : number , options? : ServicePortOptions ) port Required \u00b6 Type: number The port definition. options Optional \u00b6 Type: cdk8s-plus-21.ServicePortOptions Properties \u00b6 ports Required \u00b6 public readonly ports : ServicePort []; Type: cdk8s-plus-21.ServicePort [] Ports for this service. Use serve() to expose additional service ports. selector Required \u00b6 public readonly selector : {[ key : string ] : string }; Type: {[ key: string ]: string } Returns the labels which are used to select pods for this service. type Required \u00b6 public readonly type : ServiceType ; Type: cdk8s-plus-21.ServiceType Determines how the Service is exposed. clusterIP Optional \u00b6 public readonly clusterIP : string ; Type: string The IP address of the service and is usually assigned randomly by the master. externalName Optional \u00b6 public readonly externalName : string ; Type: string The externalName to be used for EXTERNAL_NAME types. ServiceAccount \u00b6 Implements: cdk8s-plus-21.IServiceAccount A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account Initializers \u00b6 import { ServiceAccount } from 'cdk8s-plus-21' new ServiceAccount ( scope : Construct , id : string , props? : ServiceAccountProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-21.ServiceAccountProps Methods \u00b6 addSecret \u00b6 public addSecret ( secret : ISecret ) secret Required \u00b6 Type: cdk8s-plus-21.ISecret The secret. Static Functions \u00b6 fromServiceAccountName \u00b6 import { ServiceAccount } from 'cdk8s-plus-21' ServiceAccount . fromServiceAccountName ( name : string ) name Required \u00b6 Type: string The name of the service account resource. Properties \u00b6 secrets Required \u00b6 public readonly secrets : ISecret []; Type: cdk8s-plus-21.ISecret [] List of secrets allowed to be used by pods running using this service account. Returns a copy. To add a secret, use addSecret() . StatefulSet \u00b6 Implements: cdk8s-plus-21.IPodTemplate StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed. Using StatefulSets \u00b6 StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates. Initializers \u00b6 import { StatefulSet } from 'cdk8s-plus-21' new StatefulSet ( scope : Construct , id : string , props : StatefulSetProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-21.StatefulSetProps Methods \u00b6 addContainer \u00b6 public addContainer ( container : ContainerProps ) container Required \u00b6 Type: cdk8s-plus-21.ContainerProps addVolume \u00b6 public addVolume ( volume : Volume ) volume Required \u00b6 Type: cdk8s-plus-21.Volume selectByLabel \u00b6 public selectByLabel ( key : string , value : string ) key Required \u00b6 Type: string The label key. value Required \u00b6 Type: string The label value. Properties \u00b6 containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-21.Container [] The containers belonging to the pod. Use addContainer to add containers. labelSelector Required \u00b6 public readonly labelSelector : {[ key : string ] : string }; Type: {[ key: string ]: string } The labels this statefulset will match against in order to select pods. Returns a a copy. Use selectByLabel() to add labels. podManagementPolicy Required \u00b6 public readonly podManagementPolicy : PodManagementPolicy ; Type: cdk8s-plus-21.PodManagementPolicy Management policy to use for the set. podMetadata Required \u00b6 public readonly podMetadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. replicas Required \u00b6 public readonly replicas : number ; Type: number Number of desired pods. volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-21.Volume [] The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-21.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-21.IServiceAccount The service account used to run this pod. Structs \u00b6 AddDeploymentOptions \u00b6 Options to add a deployment to a service. Initializer \u00b6 import { AddDeploymentOptions } from 'cdk8s-plus-21' const addDeploymentOptions : AddDeploymentOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public readonly nodePort : number ; Type: number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-21.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The value of port will be used. The port number the service will redirect to. port Optional \u00b6 public readonly port : number ; Type: number Default: Copied from the first container of the deployment. The port number the service will bind to. AddDirectoryOptions \u00b6 Options for configmap.addDirectory() . Initializer \u00b6 import { AddDirectoryOptions } from 'cdk8s-plus-21' const addDirectoryOptions : AddDirectoryOptions = { ... } exclude Optional \u00b6 public readonly exclude : string []; Type: string [] Default: include all files Glob patterns to exclude when adding files. keyPrefix Optional \u00b6 public readonly keyPrefix : string ; Type: string Default: \u201c\u201d A prefix to add to all keys in the config map. CommandProbeOptions \u00b6 Options for Probe.fromCommand() . Initializer \u00b6 import { CommandProbeOptions } from 'cdk8s-plus-21' const commandProbeOptions : CommandProbeOptions = { ... } failureThreshold Optional \u00b6 public readonly failureThreshold : number ; Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public readonly initialDelaySeconds : Duration ; Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public readonly periodSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public readonly successThreshold : number ; Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public readonly timeoutSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ConfigMapProps \u00b6 Properties for initialization of ConfigMap . Initializer \u00b6 import { ConfigMapProps } from 'cdk8s-plus-21' const configMapProps : ConfigMapProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binaryData Optional \u00b6 public readonly binaryData : {[ key : string ] : string }; Type: {[ key: string ]: string } BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. Using this field will require 1.10+ apiserver and kubelet. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 public readonly data : {[ key : string ] : string }; Type: {[ key: string ]: string } Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . ConfigMapVolumeOptions \u00b6 Options for the ConfigMap-based volume. Initializer \u00b6 import { ConfigMapVolumeOptions } from 'cdk8s-plus-21' const configMapVolumeOptions : ConfigMapVolumeOptions = { ... } defaultMode Optional \u00b6 public readonly defaultMode : number ; Type: number Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 public readonly items : {[ key : string ] : PathMapping }; Type: {[ key: string ]: cdk8s-plus-21.PathMapping } Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 public readonly name : string ; Type: string Default: auto-generated The volume name. optional Optional \u00b6 public readonly optional : boolean ; Type: boolean Default: undocumented Specify whether the ConfigMap or its keys must be defined. ContainerProps \u00b6 Properties for creating a container. Initializer \u00b6 import { ContainerProps } from 'cdk8s-plus-21' const containerProps : ContainerProps = { ... } image Required \u00b6 public readonly image : string ; Type: string Docker image name. args Optional \u00b6 public readonly args : string []; Type: string [] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 public readonly command : string []; Type: string [] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 public readonly env : {[ key : string ] : EnvValue }; Type: {[ key: string ]: cdk8s-plus-21.EnvValue } Default: No environment variables. List of environment variables to set in the container. Cannot be updated. imagePullPolicy Optional \u00b6 public readonly imagePullPolicy : ImagePullPolicy ; Type: cdk8s-plus-21.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 public readonly liveness : Probe ; Type: cdk8s-plus-21.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 public readonly name : string ; Type: string Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 public readonly port : number ; Type: number Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 public readonly readiness : Probe ; Type: cdk8s-plus-21.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 public readonly startup : Probe ; Type: cdk8s-plus-21.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volumeMounts Optional \u00b6 public readonly volumeMounts : VolumeMount []; Type: cdk8s-plus-21.VolumeMount [] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. workingDir Optional \u00b6 public readonly workingDir : string ; Type: string Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. DeploymentProps \u00b6 Properties for initialization of Deployment . Initializer \u00b6 import { DeploymentProps } from 'cdk8s-plus-21' const deploymentProps : DeploymentProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-21.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-21.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata. defaultSelector Optional \u00b6 public readonly defaultSelector : boolean ; Type: boolean Default: true Automatically allocates a pod selector for this deployment. If this is set to false you must define your selector through deployment.podMetadata.addLabel() and deployment.selectByLabel() . replicas Optional \u00b6 public readonly replicas : number ; Type: number Default: 1 Number of desired pods. EmptyDirVolumeOptions \u00b6 Options for volumes populated with an empty directory. Initializer \u00b6 import { EmptyDirVolumeOptions } from 'cdk8s-plus-21' const emptyDirVolumeOptions : EmptyDirVolumeOptions = { ... } medium Optional \u00b6 public readonly medium : EmptyDirMedium ; Type: cdk8s-plus-21.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. sizeLimit Optional \u00b6 public readonly sizeLimit : Size ; Type: cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. EnvValueFromConfigMapOptions \u00b6 Options to specify an envionment variable value from a ConfigMap key. Initializer \u00b6 import { EnvValueFromConfigMapOptions } from 'cdk8s-plus-21' const envValueFromConfigMapOptions : EnvValueFromConfigMapOptions = { ... } optional Optional \u00b6 public readonly optional : boolean ; Type: boolean Default: false Specify whether the ConfigMap or its key must be defined. EnvValueFromProcessOptions \u00b6 Options to specify an environment variable value from the process environment. Initializer \u00b6 import { EnvValueFromProcessOptions } from 'cdk8s-plus-21' const envValueFromProcessOptions : EnvValueFromProcessOptions = { ... } required Optional \u00b6 public readonly required : boolean ; Type: boolean Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. EnvValueFromSecretOptions \u00b6 Options to specify an environment variable value from a Secret. Initializer \u00b6 import { EnvValueFromSecretOptions } from 'cdk8s-plus-21' const envValueFromSecretOptions : EnvValueFromSecretOptions = { ... } optional Optional \u00b6 public readonly optional : boolean ; Type: boolean Default: false Specify whether the Secret or its key must be defined. ExposeDeploymentViaIngressOptions \u00b6 Options for exposing a deployment via an ingress. Initializer \u00b6 import { ExposeDeploymentViaIngressOptions } from 'cdk8s-plus-21' const exposeDeploymentViaIngressOptions : ExposeDeploymentViaIngressOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 public readonly port : number ; Type: number Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-21.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. serviceType Optional \u00b6 public readonly serviceType : ServiceType ; Type: cdk8s-plus-21.ServiceType Default: ClusterIP. The type of the exposed service. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ingress Optional \u00b6 public readonly ingress : IngressV1Beta1 ; Type: cdk8s-plus-21.IngressV1Beta1 Default: An ingress will be automatically created. The ingress to add rules to. ExposeDeploymentViaServiceOptions \u00b6 Options for exposing a deployment via a service. Initializer \u00b6 import { ExposeDeploymentViaServiceOptions } from 'cdk8s-plus-21' const exposeDeploymentViaServiceOptions : ExposeDeploymentViaServiceOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 public readonly port : number ; Type: number Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-21.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. serviceType Optional \u00b6 public readonly serviceType : ServiceType ; Type: cdk8s-plus-21.ServiceType Default: ClusterIP. The type of the exposed service. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ExposeServiceViaIngressOptions \u00b6 Options for exposing a service using an ingress. Initializer \u00b6 import { ExposeServiceViaIngressOptions } from 'cdk8s-plus-21' const exposeServiceViaIngressOptions : ExposeServiceViaIngressOptions = { ... } ingress Optional \u00b6 public readonly ingress : IngressV1Beta1 ; Type: cdk8s-plus-21.IngressV1Beta1 Default: An ingress will be automatically created. The ingress to add rules to. HttpGetProbeOptions \u00b6 Options for Probe.fromHttpGet() . Initializer \u00b6 import { HttpGetProbeOptions } from 'cdk8s-plus-21' const httpGetProbeOptions : HttpGetProbeOptions = { ... } failureThreshold Optional \u00b6 public readonly failureThreshold : number ; Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public readonly initialDelaySeconds : Duration ; Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public readonly periodSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public readonly successThreshold : number ; Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public readonly timeoutSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 public readonly port : number ; Type: number Default: defaults to container.port . The TCP port to use when sending the GET request. IngressV1Beta1Props \u00b6 Properties for Ingress . Initializer \u00b6 import { IngressV1Beta1Props } from 'cdk8s-plus-21' const ingressV1Beta1Props : IngressV1Beta1Props = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. defaultBackend Optional \u00b6 public readonly defaultBackend : IngressV1Beta1Backend ; Type: cdk8s-plus-21.IngressV1Beta1Backend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 public readonly rules : IngressV1Beta1Rule []; Type: cdk8s-plus-21.IngressV1Beta1Rule [] Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 public readonly tls : IngressV1Beta1Tls []; Type: cdk8s-plus-21.IngressV1Beta1Tls [] TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. IngressV1Beta1Rule \u00b6 Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path. Initializer \u00b6 import { IngressV1Beta1Rule } from 'cdk8s-plus-21' const ingressV1Beta1Rule : IngressV1Beta1Rule = { ... } backend Required \u00b6 public readonly backend : IngressV1Beta1Backend ; Type: cdk8s-plus-21.IngressV1Beta1Backend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 public readonly host : string ; Type: string Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 public readonly path : string ; Type: string Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. IngressV1Beta1Tls \u00b6 Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination. Initializer \u00b6 import { IngressV1Beta1Tls } from 'cdk8s-plus-21' const ingressV1Beta1Tls : IngressV1Beta1Tls = { ... } hosts Optional \u00b6 public readonly hosts : string []; Type: string [] Default: If unspecified, it defaults to the wildcard host setting for the loadbalancer controller fulfilling this Ingress. Hosts are a list of hosts included in the TLS certificate. The values in this list must match the name/s used in the TLS Secret. secret Optional \u00b6 public readonly secret : ISecret ; Type: cdk8s-plus-21.ISecret Default: If unspecified, it allows SSL routing based on SNI hostname. Secret is the secret that contains the certificate and key used to terminate SSL traffic on 443. If the SNI host in a listener conflicts with the \u201cHost\u201d header field used by an IngressRule, the SNI host is used for termination and value of the Host header is used for routing. JobProps \u00b6 Properties for initialization of Job . Initializer \u00b6 import { JobProps } from 'cdk8s-plus-21' const jobProps : JobProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-21.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-21.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata. activeDeadline Optional \u00b6 public readonly activeDeadline : Duration ; Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 public readonly backoffLimit : number ; Type: number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 public readonly ttlAfterFinished : Duration ; Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. MountOptions \u00b6 Options for mounts. Initializer \u00b6 import { MountOptions } from 'cdk8s-plus-21' const mountOptions : MountOptions = { ... } propagation Optional \u00b6 public readonly propagation : MountPropagation ; Type: cdk8s-plus-21.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. This field is beta in 1.10. readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public readonly subPath : string ; Type: string Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public readonly subPathExpr : string ; Type: string Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). SubPathExpr and SubPath are mutually exclusive. This field is beta in 1.15. subPathExpr and subPath are mutually exclusive. This field is beta in 1.15. PathMapping \u00b6 Maps a string key to a path within a volume. Initializer \u00b6 import { PathMapping } from 'cdk8s-plus-21' const pathMapping : PathMapping = { ... } path Required \u00b6 public readonly path : string ; Type: string The relative path of the file to map the key to. May not be an absolute path. May not contain the path element \u2018..\u2019. May not start with the string \u2018..\u2019. mode Optional \u00b6 public readonly mode : number ; Type: number Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. PodProps \u00b6 Properties for initialization of Pod . Initializer \u00b6 import { PodProps } from 'cdk8s-plus-21' const podProps : PodProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-21.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-21.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodSpecProps \u00b6 Properties of a PodSpec . Initializer \u00b6 import { PodSpecProps } from 'cdk8s-plus-21' const podSpecProps : PodSpecProps = { ... } containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-21.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-21.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodTemplateProps \u00b6 Properties of a PodTemplate . Adds metadata information on top of the spec. Initializer \u00b6 import { PodTemplateProps } from 'cdk8s-plus-21' const podTemplateProps : PodTemplateProps = { ... } containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-21.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-21.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata. ProbeOptions \u00b6 Probe options. Initializer \u00b6 import { ProbeOptions } from 'cdk8s-plus-21' const probeOptions : ProbeOptions = { ... } failureThreshold Optional \u00b6 public readonly failureThreshold : number ; Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public readonly initialDelaySeconds : Duration ; Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public readonly periodSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public readonly successThreshold : number ; Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public readonly timeoutSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ResourceProps \u00b6 Initialization properties for resources. Initializer \u00b6 import { ResourceProps } from 'cdk8s-plus-21' const resourceProps : ResourceProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. SecretProps \u00b6 Initializer \u00b6 import { SecretProps } from 'cdk8s-plus-21' const secretProps : SecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. stringData Optional \u00b6 public readonly stringData : {[ key : string ] : string }; Type: {[ key: string ]: string } stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 public readonly type : string ; Type: string Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. SecretValue \u00b6 Represents a specific value in JSON secret. Initializer \u00b6 import { SecretValue } from 'cdk8s-plus-21' const secretValue : SecretValue = { ... } key Required \u00b6 public readonly key : string ; Type: string The JSON key. secret Required \u00b6 public readonly secret : ISecret ; Type: cdk8s-plus-21.ISecret The secret. ServiceAccountProps \u00b6 Properties for initialization of ServiceAccount . Properties for initialization of ServiceAccount . Initializer \u00b6 import { ServiceAccountProps } from 'cdk8s-plus-21' const serviceAccountProps : ServiceAccountProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. secrets Optional \u00b6 public readonly secrets : ISecret []; Type: cdk8s-plus-21.ISecret [] List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret ServiceIngressV1BetaBackendOptions \u00b6 Options for setting up backends for ingress rules. Initializer \u00b6 import { ServiceIngressV1BetaBackendOptions } from 'cdk8s-plus-21' const serviceIngressV1BetaBackendOptions : ServiceIngressV1BetaBackendOptions = { ... } port Optional \u00b6 public readonly port : number ; Type: number Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. - If the service exposes multiple ports, this option must be specified. - If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. ServicePort \u00b6 Definition of a service port. Initializer \u00b6 import { ServicePort } from 'cdk8s-plus-21' const servicePort : ServicePort = { ... } name Optional \u00b6 public readonly name : string ; Type: string The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public readonly nodePort : number ; Type: number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-21.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The value of port will be used. The port number the service will redirect to. port Required \u00b6 public readonly port : number ; Type: number The port number the service will bind to. ServicePortOptions \u00b6 Initializer \u00b6 import { ServicePortOptions } from 'cdk8s-plus-21' const servicePortOptions : ServicePortOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public readonly nodePort : number ; Type: number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-21.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The value of port will be used. The port number the service will redirect to. ServiceProps \u00b6 Properties for initialization of Service . Initializer \u00b6 import { ServiceProps } from 'cdk8s-plus-21' const serviceProps : ServiceProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. clusterIP Optional \u00b6 public readonly clusterIP : string ; Type: string Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies externalIPs Optional \u00b6 public readonly externalIPs : string []; Type: string [] Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. externalName Optional \u00b6 public readonly externalName : string ; Type: string Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. loadBalancerSourceRanges Optional \u00b6 public readonly loadBalancerSourceRanges : string []; Type: string [] A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 public readonly ports : ServicePort []; Type: cdk8s-plus-21.ServicePort [] The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 public readonly type : ServiceType ; Type: cdk8s-plus-21.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types StatefulSetProps \u00b6 Properties for initialization of StatefulSet . Initializer \u00b6 import { StatefulSetProps } from 'cdk8s-plus-21' const statefulSetProps : StatefulSetProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-21.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-21.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-21.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-21.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata. service Required \u00b6 public readonly service : Service ; Type: cdk8s-plus-21.Service Service to associate with the statefulset. defaultSelector Optional \u00b6 public readonly defaultSelector : boolean ; Type: boolean Default: true Automatically allocates a pod selector for this statefulset. If this is set to false you must define your selector through statefulset.podMetadata.addLabel() and statefulset.selectByLabel() . podManagementPolicy Optional \u00b6 public readonly podManagementPolicy : PodManagementPolicy ; Type: cdk8s-plus-21.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 public readonly replicas : number ; Type: number Default: 1 Number of desired pods. VolumeMount \u00b6 Mount a volume from the pod to the container. Initializer \u00b6 import { VolumeMount } from 'cdk8s-plus-21' const volumeMount : VolumeMount = { ... } propagation Optional \u00b6 public readonly propagation : MountPropagation ; Type: cdk8s-plus-21.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. This field is beta in 1.10. readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public readonly subPath : string ; Type: string Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public readonly subPathExpr : string ; Type: string Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). SubPathExpr and SubPath are mutually exclusive. This field is beta in 1.15. subPathExpr and subPath are mutually exclusive. This field is beta in 1.15. path Required \u00b6 public readonly path : string ; Type: string Path within the container at which the volume should be mounted. Must not contain \u2018:\u2019. volume Required \u00b6 public readonly volume : Volume ; Type: cdk8s-plus-21.Volume The volume to mount. Classes \u00b6 Container \u00b6 A single application container that you want to run within a pod. Initializers \u00b6 import { Container } from 'cdk8s-plus-21' new Container ( props : ContainerProps ) props Required \u00b6 Type: cdk8s-plus-21.ContainerProps Methods \u00b6 addEnv \u00b6 public addEnv ( name : string , value : EnvValue ) name Required \u00b6 Type: string The variable name. value Required \u00b6 Type: cdk8s-plus-21.EnvValue The variable value. mount \u00b6 public mount ( path : string , volume : Volume , options? : MountOptions ) path Required \u00b6 Type: string The desired path in the container. volume Required \u00b6 Type: cdk8s-plus-21.Volume The volume to mount. options Optional \u00b6 Type: cdk8s-plus-21.MountOptions Properties \u00b6 env Required \u00b6 public readonly env : {[ key : string ] : EnvValue }; Type: {[ key: string ]: cdk8s-plus-21.EnvValue } The environment variables for this container. Returns a copy. To add environment variables use addEnv() . image Required \u00b6 public readonly image : string ; Type: string The container image. imagePullPolicy Required \u00b6 public readonly imagePullPolicy : ImagePullPolicy ; Type: cdk8s-plus-21.ImagePullPolicy Image pull policy for this container. mounts Required \u00b6 public readonly mounts : VolumeMount []; Type: cdk8s-plus-21.VolumeMount [] Volume mounts configured for this container. name Required \u00b6 public readonly name : string ; Type: string The name of the container. args Optional \u00b6 public readonly args : string []; Type: string [] Arguments to the entrypoint. command Optional \u00b6 public readonly command : string []; Type: string [] Entrypoint array (the command to execute when the container starts). port Optional \u00b6 public readonly port : number ; Type: number The port this container exposes. workingDir Optional \u00b6 public readonly workingDir : string ; Type: string The working directory inside the container. EnvValue \u00b6 Utility class for creating reading env values from various sources. Static Functions \u00b6 fromConfigMap \u00b6 import { EnvValue } from 'cdk8s-plus-21' EnvValue . fromConfigMap ( configMap : IConfigMap , key : string , options? : EnvValueFromConfigMapOptions ) configMap Required \u00b6 Type: cdk8s-plus-21.IConfigMap The config map. key Required \u00b6 Type: string The key to extract the value from. options Optional \u00b6 Type: cdk8s-plus-21.EnvValueFromConfigMapOptions Additional options. fromProcess \u00b6 import { EnvValue } from 'cdk8s-plus-21' EnvValue . fromProcess ( key : string , options? : EnvValueFromProcessOptions ) key Required \u00b6 Type: string The key to read. options Optional \u00b6 Type: cdk8s-plus-21.EnvValueFromProcessOptions Additional options. fromSecretValue \u00b6 import { EnvValue } from 'cdk8s-plus-21' EnvValue . fromSecretValue ( secretValue : SecretValue , options? : EnvValueFromSecretOptions ) secretValue Required \u00b6 Type: cdk8s-plus-21.SecretValue The secret value (secrent + key). options Optional \u00b6 Type: cdk8s-plus-21.EnvValueFromSecretOptions Additional options. fromValue \u00b6 import { EnvValue } from 'cdk8s-plus-21' EnvValue . fromValue ( value : string ) value Required \u00b6 Type: string The value. Properties \u00b6 value Optional \u00b6 public readonly value : any ; Type: any valueFrom Optional \u00b6 public readonly valueFrom : any ; Type: any IngressV1Beta1Backend \u00b6 The backend for an ingress path. Static Functions \u00b6 fromService \u00b6 import { IngressV1Beta1Backend } from 'cdk8s-plus-21' IngressV1Beta1Backend . fromService ( service : Service , options? : ServiceIngressV1BetaBackendOptions ) service Required \u00b6 Type: cdk8s-plus-21.Service The service object. options Optional \u00b6 Type: cdk8s-plus-21.ServiceIngressV1BetaBackendOptions PodSpec \u00b6 Implements: cdk8s-plus-21.IPodSpec Provides read/write capabilities ontop of a PodSpecProps . Initializers \u00b6 import { PodSpec } from 'cdk8s-plus-21' new PodSpec ( props? : PodSpecProps ) props Optional \u00b6 Type: cdk8s-plus-21.PodSpecProps Methods \u00b6 addContainer \u00b6 public addContainer ( container : ContainerProps ) container Required \u00b6 Type: cdk8s-plus-21.ContainerProps addVolume \u00b6 public addVolume ( volume : Volume ) volume Required \u00b6 Type: cdk8s-plus-21.Volume Properties \u00b6 containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-21.Container [] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-21.Volume [] The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-21.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-21.IServiceAccount The service account used to run this pod. PodTemplate \u00b6 Implements: cdk8s-plus-21.IPodTemplate Provides read/write capabilities ontop of a PodTemplateProps . Initializers \u00b6 import { PodTemplate } from 'cdk8s-plus-21' new PodTemplate ( props? : PodTemplateProps ) props Optional \u00b6 Type: cdk8s-plus-21.PodTemplateProps Properties \u00b6 podMetadata Required \u00b6 public readonly podMetadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. Probe \u00b6 Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic. Initializers \u00b6 import { Probe } from 'cdk8s-plus-21' new Probe () Static Functions \u00b6 fromCommand \u00b6 import { Probe } from 'cdk8s-plus-21' Probe . fromCommand ( command : string [], options? : CommandProbeOptions ) command Required \u00b6 Type: string [] The command to execute. options Optional \u00b6 Type: cdk8s-plus-21.CommandProbeOptions Options. fromHttpGet \u00b6 import { Probe } from 'cdk8s-plus-21' Probe . fromHttpGet ( path : string , options? : HttpGetProbeOptions ) path Required \u00b6 Type: string The URL path to hit. options Optional \u00b6 Type: cdk8s-plus-21.HttpGetProbeOptions Options. Volume \u00b6 Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes Initializers \u00b6 import { Volume } from 'cdk8s-plus-21' new Volume ( name : string , config : any ) name Required \u00b6 Type: string config Required \u00b6 Type: any Static Functions \u00b6 fromConfigMap \u00b6 import { Volume } from 'cdk8s-plus-21' Volume . fromConfigMap ( configMap : IConfigMap , options? : ConfigMapVolumeOptions ) configMap Required \u00b6 Type: cdk8s-plus-21.IConfigMap The config map to use to populate the volume. options Optional \u00b6 Type: cdk8s-plus-21.ConfigMapVolumeOptions Options. fromEmptyDir \u00b6 import { Volume } from 'cdk8s-plus-21' Volume . fromEmptyDir ( name : string , options? : EmptyDirVolumeOptions ) name Required \u00b6 Type: string options Optional \u00b6 Type: cdk8s-plus-21.EmptyDirVolumeOptions Additional options. Properties \u00b6 name Required \u00b6 public readonly name : string ; Type: string Protocols \u00b6 IConfigMap \u00b6 Extends: cdk8s-plus-21.IResource Implemented By: cdk8s-plus-21.ConfigMap , cdk8s-plus-21.IConfigMap Represents a config map. Properties \u00b6 name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IPodSpec \u00b6 Implemented By: cdk8s-plus-21.Deployment , cdk8s-plus-21.Job , cdk8s-plus-21.Pod , cdk8s-plus-21.PodSpec , cdk8s-plus-21.PodTemplate , cdk8s-plus-21.StatefulSet , cdk8s-plus-21.IPodSpec , cdk8s-plus-21.IPodTemplate Represents a resource that can be configured with a kuberenets pod spec. (e.g Deployment , Job , Pod , \u2026). Use the PodSpec class as an implementation helper. Methods \u00b6 addContainer \u00b6 public addContainer ( container : ContainerProps ) container Required \u00b6 Type: cdk8s-plus-21.ContainerProps The container. addVolume \u00b6 public addVolume ( volume : Volume ) volume Required \u00b6 Type: cdk8s-plus-21.Volume The volume. Properties \u00b6 containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-21.Container [] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-21.Volume [] The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-21.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-21.IServiceAccount The service account used to run this pod. IPodTemplate \u00b6 Extends: cdk8s-plus-21.IPodSpec Implemented By: cdk8s-plus-21.Deployment , cdk8s-plus-21.Job , cdk8s-plus-21.PodTemplate , cdk8s-plus-21.StatefulSet , cdk8s-plus-21.IPodTemplate Represents a resource that can be configured with a kuberenets pod template. (e.g Deployment , Job , \u2026). Use the PodTemplate class as an implementation helper. Properties \u00b6 containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-21.Container [] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-21.Volume [] The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-21.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-21.IServiceAccount The service account used to run this pod. podMetadata Required \u00b6 public readonly podMetadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. IResource \u00b6 Implemented By: cdk8s-plus-21.ConfigMap , cdk8s-plus-21.Deployment , cdk8s-plus-21.IngressV1Beta1 , cdk8s-plus-21.Job , cdk8s-plus-21.Pod , cdk8s-plus-21.Resource , cdk8s-plus-21.Secret , cdk8s-plus-21.Service , cdk8s-plus-21.ServiceAccount , cdk8s-plus-21.StatefulSet , cdk8s-plus-21.IConfigMap , cdk8s-plus-21.IResource , cdk8s-plus-21.ISecret , cdk8s-plus-21.IServiceAccount Represents a resource. Properties \u00b6 name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. ISecret \u00b6 Extends: cdk8s-plus-21.IResource Implemented By: cdk8s-plus-21.Secret , cdk8s-plus-21.ISecret Properties \u00b6 name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IServiceAccount \u00b6 Extends: cdk8s-plus-21.IResource Implemented By: cdk8s-plus-21.ServiceAccount , cdk8s-plus-21.IServiceAccount Properties \u00b6 name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. Enums \u00b6 EmptyDirMedium \u00b6 The medium on which to store the volume. DEFAULT \u00b6 The default volume of the backing node. MEMORY \u00b6 Mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. ImagePullPolicy \u00b6 ALWAYS \u00b6 Every time the kubelet launches a container, the kubelet queries the container image registry to resolve the name to an image digest. If the kubelet has a container image with that exact digest cached locally, the kubelet uses its cached image; otherwise, the kubelet downloads (pulls) the image with the resolved digest, and uses that image to launch the container. Default is Always if ImagePullPolicy is omitted and either the image tag is :latest or the image tag is omitted. IF_NOT_PRESENT \u00b6 The image is pulled only if it is not already present locally. Default is IfNotPresent if ImagePullPolicy is omitted and the image tag is present but not :latest NEVER \u00b6 The image is assumed to exist locally. No attempt is made to pull the image. MountPropagation \u00b6 NONE \u00b6 This volume mount will not receive any subsequent mounts that are mounted to this volume or any of its subdirectories by the host. In similar fashion, no mounts created by the Container will be visible on the host. This is the default mode. This mode is equal to private mount propagation as described in the Linux kernel documentation HOST_TO_CONTAINER \u00b6 This volume mount will receive all subsequent mounts that are mounted to this volume or any of its subdirectories. In other words, if the host mounts anything inside the volume mount, the Container will see it mounted there. Similarly, if any Pod with Bidirectional mount propagation to the same volume mounts anything there, the Container with HostToContainer mount propagation will see it. This mode is equal to rslave mount propagation as described in the Linux kernel documentation BIDIRECTIONAL \u00b6 This volume mount behaves the same the HostToContainer mount. In addition, all volume mounts created by the Container will be propagated back to the host and to all Containers of all Pods that use the same volume A typical use case for this mode is a Pod with a FlexVolume or CSI driver or a Pod that needs to mount something on the host using a hostPath volume. This mode is equal to rshared mount propagation as described in the Linux kernel documentation Caution: Bidirectional mount propagation can be dangerous. It can damage the host operating system and therefore it is allowed only in privileged Containers. Familiarity with Linux kernel behavior is strongly recommended. In addition, any volume mounts created by Containers in Pods must be destroyed (unmounted) by the Containers on termination. PodManagementPolicy \u00b6 Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once. ORDERED_READY \u00b6 PARALLEL \u00b6 Protocol \u00b6 TCP \u00b6 UDP \u00b6 SCTP \u00b6 RestartPolicy \u00b6 Restart policy for all containers within the pod. ALWAYS \u00b6 Always restart the pod after it exits. ON_FAILURE \u00b6 Only restart if the pod exits with a non-zero exit code. NEVER \u00b6 Never restart the pod. ServiceType \u00b6 For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP. CLUSTER_IP \u00b6 Exposes the Service on a cluster-internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default ServiceType NODE_PORT \u00b6 Exposes the Service on each Node\u2019s IP at a static port (the NodePort). A ClusterIP Service, to which the NodePort Service routes, is automatically created. You\u2019ll be able to contact the NodePort Service, from outside the cluster, by requesting : . LOAD_BALANCER \u00b6 Exposes the Service externally using a cloud provider\u2019s load balancer. NodePort and ClusterIP Services, to which the external load balancer routes, are automatically created. EXTERNAL_NAME \u00b6 Maps the Service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value. No proxying of any kind is set up. Note: You need either kube-dns version 1.7 or CoreDNS version 0.0.8 or higher to use the ExternalName type.","title":"TypeScript"},{"location":"reference/cdk8s-plus-21/typescript/#cdk8s-plus-21-typescript","text":"","title":"cdk8s-plus-21 (TypeScript) "},{"location":"reference/cdk8s-plus-21/typescript/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s-plus-21/typescript/#configmap","text":"Implements: cdk8s-plus-21.IConfigMap ConfigMap holds configuration data for pods to consume.","title":"ConfigMap "},{"location":"reference/cdk8s-plus-21/typescript/#deployment","text":"Implements: cdk8s-plus-21.IPodTemplate A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below.","title":"Deployment "},{"location":"reference/cdk8s-plus-21/typescript/#use-case","text":"The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore.","title":"Use Case"},{"location":"reference/cdk8s-plus-21/typescript/#ingressv1beta1","text":"Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.","title":"IngressV1Beta1 "},{"location":"reference/cdk8s-plus-21/typescript/#job","text":"Implements: cdk8s-plus-21.IPodTemplate A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel.","title":"Job "},{"location":"reference/cdk8s-plus-21/typescript/#pod","text":"Implements: cdk8s-plus-21.IPodSpec Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.","title":"Pod "},{"location":"reference/cdk8s-plus-21/typescript/#resource","text":"Implements: cdk8s-plus-21.IResource Base class for all Kubernetes objects in stdk8s. Represents a single resource.","title":"Resource "},{"location":"reference/cdk8s-plus-21/typescript/#secret","text":"Implements: cdk8s-plus-21.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret","title":"Secret "},{"location":"reference/cdk8s-plus-21/typescript/#service","text":"An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods.","title":"Service "},{"location":"reference/cdk8s-plus-21/typescript/#serviceaccount","text":"Implements: cdk8s-plus-21.IServiceAccount A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account","title":"ServiceAccount "},{"location":"reference/cdk8s-plus-21/typescript/#statefulset","text":"Implements: cdk8s-plus-21.IPodTemplate StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed.","title":"StatefulSet "},{"location":"reference/cdk8s-plus-21/typescript/#using-statefulsets","text":"StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates.","title":"Using StatefulSets"},{"location":"reference/cdk8s-plus-21/typescript/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s-plus-21/typescript/#adddeploymentoptions","text":"Options to add a deployment to a service.","title":"AddDeploymentOptions "},{"location":"reference/cdk8s-plus-21/typescript/#adddirectoryoptions","text":"Options for configmap.addDirectory() .","title":"AddDirectoryOptions "},{"location":"reference/cdk8s-plus-21/typescript/#commandprobeoptions","text":"Options for Probe.fromCommand() .","title":"CommandProbeOptions "},{"location":"reference/cdk8s-plus-21/typescript/#configmapprops","text":"Properties for initialization of ConfigMap .","title":"ConfigMapProps "},{"location":"reference/cdk8s-plus-21/typescript/#configmapvolumeoptions","text":"Options for the ConfigMap-based volume.","title":"ConfigMapVolumeOptions "},{"location":"reference/cdk8s-plus-21/typescript/#containerprops","text":"Properties for creating a container.","title":"ContainerProps "},{"location":"reference/cdk8s-plus-21/typescript/#deploymentprops","text":"Properties for initialization of Deployment .","title":"DeploymentProps "},{"location":"reference/cdk8s-plus-21/typescript/#emptydirvolumeoptions","text":"Options for volumes populated with an empty directory.","title":"EmptyDirVolumeOptions "},{"location":"reference/cdk8s-plus-21/typescript/#envvaluefromconfigmapoptions","text":"Options to specify an envionment variable value from a ConfigMap key.","title":"EnvValueFromConfigMapOptions "},{"location":"reference/cdk8s-plus-21/typescript/#envvaluefromprocessoptions","text":"Options to specify an environment variable value from the process environment.","title":"EnvValueFromProcessOptions "},{"location":"reference/cdk8s-plus-21/typescript/#envvaluefromsecretoptions","text":"Options to specify an environment variable value from a Secret.","title":"EnvValueFromSecretOptions "},{"location":"reference/cdk8s-plus-21/typescript/#exposedeploymentviaingressoptions","text":"Options for exposing a deployment via an ingress.","title":"ExposeDeploymentViaIngressOptions "},{"location":"reference/cdk8s-plus-21/typescript/#exposedeploymentviaserviceoptions","text":"Options for exposing a deployment via a service.","title":"ExposeDeploymentViaServiceOptions "},{"location":"reference/cdk8s-plus-21/typescript/#exposeserviceviaingressoptions","text":"Options for exposing a service using an ingress.","title":"ExposeServiceViaIngressOptions "},{"location":"reference/cdk8s-plus-21/typescript/#httpgetprobeoptions","text":"Options for Probe.fromHttpGet() .","title":"HttpGetProbeOptions "},{"location":"reference/cdk8s-plus-21/typescript/#ingressv1beta1props","text":"Properties for Ingress .","title":"IngressV1Beta1Props "},{"location":"reference/cdk8s-plus-21/typescript/#ingressv1beta1rule","text":"Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path.","title":"IngressV1Beta1Rule "},{"location":"reference/cdk8s-plus-21/typescript/#ingressv1beta1tls","text":"Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination.","title":"IngressV1Beta1Tls "},{"location":"reference/cdk8s-plus-21/typescript/#jobprops","text":"Properties for initialization of Job .","title":"JobProps "},{"location":"reference/cdk8s-plus-21/typescript/#mountoptions","text":"Options for mounts.","title":"MountOptions "},{"location":"reference/cdk8s-plus-21/typescript/#pathmapping","text":"Maps a string key to a path within a volume.","title":"PathMapping "},{"location":"reference/cdk8s-plus-21/typescript/#podprops","text":"Properties for initialization of Pod .","title":"PodProps "},{"location":"reference/cdk8s-plus-21/typescript/#podspecprops","text":"Properties of a PodSpec .","title":"PodSpecProps "},{"location":"reference/cdk8s-plus-21/typescript/#podtemplateprops","text":"Properties of a PodTemplate . Adds metadata information on top of the spec.","title":"PodTemplateProps "},{"location":"reference/cdk8s-plus-21/typescript/#probeoptions","text":"Probe options.","title":"ProbeOptions "},{"location":"reference/cdk8s-plus-21/typescript/#resourceprops","text":"Initialization properties for resources.","title":"ResourceProps "},{"location":"reference/cdk8s-plus-21/typescript/#secretprops","text":"","title":"SecretProps "},{"location":"reference/cdk8s-plus-21/typescript/#secretvalue","text":"Represents a specific value in JSON secret.","title":"SecretValue "},{"location":"reference/cdk8s-plus-21/typescript/#serviceaccountprops","text":"Properties for initialization of ServiceAccount . Properties for initialization of ServiceAccount .","title":"ServiceAccountProps "},{"location":"reference/cdk8s-plus-21/typescript/#serviceingressv1betabackendoptions","text":"Options for setting up backends for ingress rules.","title":"ServiceIngressV1BetaBackendOptions "},{"location":"reference/cdk8s-plus-21/typescript/#serviceport","text":"Definition of a service port.","title":"ServicePort "},{"location":"reference/cdk8s-plus-21/typescript/#serviceportoptions","text":"","title":"ServicePortOptions "},{"location":"reference/cdk8s-plus-21/typescript/#serviceprops","text":"Properties for initialization of Service .","title":"ServiceProps "},{"location":"reference/cdk8s-plus-21/typescript/#statefulsetprops","text":"Properties for initialization of StatefulSet .","title":"StatefulSetProps "},{"location":"reference/cdk8s-plus-21/typescript/#volumemount","text":"Mount a volume from the pod to the container.","title":"VolumeMount "},{"location":"reference/cdk8s-plus-21/typescript/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s-plus-21/typescript/#container","text":"A single application container that you want to run within a pod.","title":"Container "},{"location":"reference/cdk8s-plus-21/typescript/#envvalue","text":"Utility class for creating reading env values from various sources.","title":"EnvValue "},{"location":"reference/cdk8s-plus-21/typescript/#ingressv1beta1backend","text":"The backend for an ingress path.","title":"IngressV1Beta1Backend "},{"location":"reference/cdk8s-plus-21/typescript/#podspec","text":"Implements: cdk8s-plus-21.IPodSpec Provides read/write capabilities ontop of a PodSpecProps .","title":"PodSpec "},{"location":"reference/cdk8s-plus-21/typescript/#podtemplate","text":"Implements: cdk8s-plus-21.IPodTemplate Provides read/write capabilities ontop of a PodTemplateProps .","title":"PodTemplate "},{"location":"reference/cdk8s-plus-21/typescript/#probe","text":"Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.","title":"Probe "},{"location":"reference/cdk8s-plus-21/typescript/#volume","text":"Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes","title":"Volume "},{"location":"reference/cdk8s-plus-21/typescript/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s-plus-21/typescript/#iconfigmap","text":"Extends: cdk8s-plus-21.IResource Implemented By: cdk8s-plus-21.ConfigMap , cdk8s-plus-21.IConfigMap Represents a config map.","title":"IConfigMap "},{"location":"reference/cdk8s-plus-21/typescript/#ipodspec","text":"Implemented By: cdk8s-plus-21.Deployment , cdk8s-plus-21.Job , cdk8s-plus-21.Pod , cdk8s-plus-21.PodSpec , cdk8s-plus-21.PodTemplate , cdk8s-plus-21.StatefulSet , cdk8s-plus-21.IPodSpec , cdk8s-plus-21.IPodTemplate Represents a resource that can be configured with a kuberenets pod spec. (e.g Deployment , Job , Pod , \u2026). Use the PodSpec class as an implementation helper.","title":"IPodSpec "},{"location":"reference/cdk8s-plus-21/typescript/#ipodtemplate","text":"Extends: cdk8s-plus-21.IPodSpec Implemented By: cdk8s-plus-21.Deployment , cdk8s-plus-21.Job , cdk8s-plus-21.PodTemplate , cdk8s-plus-21.StatefulSet , cdk8s-plus-21.IPodTemplate Represents a resource that can be configured with a kuberenets pod template. (e.g Deployment , Job , \u2026). Use the PodTemplate class as an implementation helper.","title":"IPodTemplate "},{"location":"reference/cdk8s-plus-21/typescript/#iresource","text":"Implemented By: cdk8s-plus-21.ConfigMap , cdk8s-plus-21.Deployment , cdk8s-plus-21.IngressV1Beta1 , cdk8s-plus-21.Job , cdk8s-plus-21.Pod , cdk8s-plus-21.Resource , cdk8s-plus-21.Secret , cdk8s-plus-21.Service , cdk8s-plus-21.ServiceAccount , cdk8s-plus-21.StatefulSet , cdk8s-plus-21.IConfigMap , cdk8s-plus-21.IResource , cdk8s-plus-21.ISecret , cdk8s-plus-21.IServiceAccount Represents a resource.","title":"IResource "},{"location":"reference/cdk8s-plus-21/typescript/#isecret","text":"Extends: cdk8s-plus-21.IResource Implemented By: cdk8s-plus-21.Secret , cdk8s-plus-21.ISecret","title":"ISecret "},{"location":"reference/cdk8s-plus-21/typescript/#iserviceaccount","text":"Extends: cdk8s-plus-21.IResource Implemented By: cdk8s-plus-21.ServiceAccount , cdk8s-plus-21.IServiceAccount","title":"IServiceAccount "},{"location":"reference/cdk8s-plus-21/typescript/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s-plus-21/typescript/#emptydirmedium","text":"The medium on which to store the volume.","title":"EmptyDirMedium "},{"location":"reference/cdk8s-plus-21/typescript/#imagepullpolicy","text":"","title":"ImagePullPolicy "},{"location":"reference/cdk8s-plus-21/typescript/#mountpropagation","text":"","title":"MountPropagation "},{"location":"reference/cdk8s-plus-21/typescript/#podmanagementpolicy","text":"Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.","title":"PodManagementPolicy "},{"location":"reference/cdk8s-plus-21/typescript/#protocol","text":"","title":"Protocol "},{"location":"reference/cdk8s-plus-21/typescript/#restartpolicy","text":"Restart policy for all containers within the pod.","title":"RestartPolicy "},{"location":"reference/cdk8s-plus-21/typescript/#servicetype","text":"For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP.","title":"ServiceType "},{"location":"reference/cdk8s-plus-22/go/","text":"cdk8s-plus-22 (Go) \u00b6 For Go API reference, please visit https://pkg.go.dev/github.com/cdk8s-team/cdk8s-plus-go/cdk8splus22 .","title":"Go"},{"location":"reference/cdk8s-plus-22/go/#cdk8s-plus-22-go","text":"For Go API reference, please visit https://pkg.go.dev/github.com/cdk8s-team/cdk8s-plus-go/cdk8splus22 .","title":"cdk8s-plus-22 (Go) "},{"location":"reference/cdk8s-plus-22/java/","text":"cdk8s-plus-22 (Java) \u00b6 Constructs \u00b6 ConfigMap \u00b6 Implements: org.cdk8s.plus22.IConfigMap ConfigMap holds configuration data for pods to consume. Initializers \u00b6 import org.cdk8s.plus22.ConfigMap ; ConfigMap . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .binaryData(java.util.Map<java.lang.String, java.lang.String>) // .data(java.util.Map<java.lang.String, java.lang.String>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binaryData Optional \u00b6 Type: java.util.Map java.lang.String > BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. Using this field will require 1.10+ apiserver and kubelet. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 Type: java.util.Map java.lang.String > Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . Methods \u00b6 addBinaryData \u00b6 public addBinaryData ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String The key. value Required \u00b6 Type: java.lang.String The value. addData \u00b6 public addData ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String The key. value Required \u00b6 Type: java.lang.String The value. addDirectory \u00b6 public addDirectory ( java . lang . String localDir ) public addDirectory ( java . lang . String localDir , AddDirectoryOptions options ) localDir Required \u00b6 Type: java.lang.String A path to a local directory. options Optional \u00b6 Type: org.cdk8s.plus22.AddDirectoryOptions Options. addFile \u00b6 public addFile ( java . lang . String localFile ) public addFile ( java . lang . String localFile , java . lang . String key ) localFile Required \u00b6 Type: java.lang.String The path to the local file. key Optional \u00b6 Type: java.lang.String The ConfigMap key (default to the file name). Static Functions \u00b6 fromConfigMapName \u00b6 import org.cdk8s.plus22.ConfigMap ; ConfigMap . fromConfigMapName ( java . lang . String name ) name Required \u00b6 Type: java.lang.String The name of the config map to import. Properties \u00b6 binaryData Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getBinaryData (); Type: java.util.Map java.lang.String > The binary data associated with this config map. Returns a copy. To add data records, use addBinaryData() or addData() . data Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getData (); Type: java.util.Map java.lang.String > The data associated with this config map. Returns an copy. To add data records, use addData() or addBinaryData() . Deployment \u00b6 Implements: org.cdk8s.plus22.IPodTemplate A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case \u00b6 The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore. Initializers \u00b6 import org.cdk8s.plus22.Deployment ; Deployment . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .defaultSelector(java.lang.Boolean) // .replicas(java.lang.Number) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata. defaultSelector Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod selector for this deployment. If this is set to false you must define your selector through deployment.podMetadata.addLabel() and deployment.selectByLabel() . replicas Optional \u00b6 Type: java.lang.Number Default: 1 Number of desired pods. Methods \u00b6 addContainer \u00b6 public addContainer ( ContainerProps container ) container Required \u00b6 Type: org.cdk8s.plus22.ContainerProps addVolume \u00b6 public addVolume ( Volume volume ) volume Required \u00b6 Type: org.cdk8s.plus22.Volume exposeViaIngress \u00b6 public exposeViaIngress ( java . lang . String path ) public exposeViaIngress ( java . lang . String path , ExposeDeploymentViaIngressOptions options ) path Required \u00b6 Type: java.lang.String The ingress path to register under. options Optional \u00b6 Type: org.cdk8s.plus22.ExposeDeploymentViaIngressOptions Additional options. exposeViaService \u00b6 public exposeViaService () public exposeViaService ( ExposeDeploymentViaServiceOptions options ) options Optional \u00b6 Type: org.cdk8s.plus22.ExposeDeploymentViaServiceOptions Options to determine details of the service and port exposed. selectByLabel \u00b6 public selectByLabel ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String The label key. value Required \u00b6 Type: java.lang.String The label value. Properties \u00b6 containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus22.Container > The containers belonging to the pod. Use addContainer to add containers. labelSelector Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getLabelSelector (); Type: java.util.Map java.lang.String > The labels this deployment will match against in order to select pods. Returns a a copy. Use selectByLabel() to add labels. podMetadata Required \u00b6 public ApiObjectMetadataDefinition getPodMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. replicas Required \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Number of desired pods. volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus22.Volume > The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus22.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus22.IServiceAccount The service account used to run this pod. Ingress \u00b6 Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. Initializers \u00b6 import org.cdk8s.plus22.Ingress ; Ingress . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .defaultBackend(IngressBackend) // .rules(java.util.List<IngressRule>) // .tls(java.util.List<IngressTls>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. defaultBackend Optional \u00b6 Type: org.cdk8s.plus22.IngressBackend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.IngressRule > Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.IngressTls > TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. Methods \u00b6 addDefaultBackend \u00b6 public addDefaultBackend ( IngressBackend backend ) backend Required \u00b6 Type: org.cdk8s.plus22.IngressBackend The backend to use for requests that do not match any rule. addHostDefaultBackend \u00b6 public addHostDefaultBackend ( java . lang . String host , IngressBackend backend ) host Required \u00b6 Type: java.lang.String The host name to match. backend Required \u00b6 Type: org.cdk8s.plus22.IngressBackend The backend to route to. addHostRule \u00b6 public addHostRule ( java . lang . String host , java . lang . String path , IngressBackend backend ) public addHostRule ( java . lang . String host , java . lang . String path , IngressBackend backend , HttpIngressPathType pathType ) host Required \u00b6 Type: java.lang.String The host name. path Required \u00b6 Type: java.lang.String The HTTP path. backend Required \u00b6 Type: org.cdk8s.plus22.IngressBackend The backend to route requests to. pathType Optional \u00b6 Type: org.cdk8s.plus22.HttpIngressPathType How the path is matched against request paths. addRule \u00b6 public addRule ( java . lang . String path , IngressBackend backend ) public addRule ( java . lang . String path , IngressBackend backend , HttpIngressPathType pathType ) path Required \u00b6 Type: java.lang.String The HTTP path. backend Required \u00b6 Type: org.cdk8s.plus22.IngressBackend The backend to route requests to. pathType Optional \u00b6 Type: org.cdk8s.plus22.HttpIngressPathType How the path is matched against request paths. addRules \u00b6 public addRules ( IngressRule rules ) rules Required \u00b6 Type: org.cdk8s.plus22.IngressRule The rules to add. addTls \u00b6 public addTls ( java . util . List < IngressTls > tls ) tls Required \u00b6 Type: java.util.List< org.cdk8s.plus22.IngressTls > Job \u00b6 Implements: org.cdk8s.plus22.IPodTemplate A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel. Initializers \u00b6 import org.cdk8s.plus22.Job ; Job . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .activeDeadline(Duration) // .backoffLimit(java.lang.Number) // .ttlAfterFinished(Duration) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata. activeDeadline Optional \u00b6 Type: org.cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 Type: java.lang.Number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 Type: org.cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. Methods \u00b6 addContainer \u00b6 public addContainer ( ContainerProps container ) container Required \u00b6 Type: org.cdk8s.plus22.ContainerProps addVolume \u00b6 public addVolume ( Volume volume ) volume Required \u00b6 Type: org.cdk8s.plus22.Volume Properties \u00b6 containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus22.Container > The containers belonging to the pod. Use addContainer to add containers. podMetadata Required \u00b6 public ApiObjectMetadataDefinition getPodMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus22.Volume > The volumes associated with this pod. Use addVolume to add volumes. activeDeadline Optional \u00b6 public Duration getActiveDeadline (); Type: org.cdk8s.Duration Duration before job is terminated. If undefined, there is no deadline. backoffLimit Optional \u00b6 public java . lang . Number getBackoffLimit (); Type: java.lang.Number Number of retries before marking failed. restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus22.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus22.IServiceAccount The service account used to run this pod. ttlAfterFinished Optional \u00b6 public Duration getTtlAfterFinished (); Type: org.cdk8s.Duration TTL before the job is deleted after it is finished. Pod \u00b6 Implements: org.cdk8s.plus22.IPodSpec Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts. Initializers \u00b6 import org.cdk8s.plus22.Pod ; Pod . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Methods \u00b6 addContainer \u00b6 public addContainer ( ContainerProps container ) container Required \u00b6 Type: org.cdk8s.plus22.ContainerProps addVolume \u00b6 public addVolume ( Volume volume ) volume Required \u00b6 Type: org.cdk8s.plus22.Volume Properties \u00b6 containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus22.Container > The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus22.Volume > The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus22.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus22.IServiceAccount The service account used to run this pod. Resource \u00b6 Implements: org.cdk8s.plus22.IResource Base class for all Kubernetes objects in stdk8s. Represents a single resource. Initializers \u00b6 import org.cdk8s.plus22.Resource ; Resource . Builder . create ( Construct scope , java . lang . String id ) // .nodeFactory(INodeFactory) . build (); scope Required \u00b6 Type: software.constructs.Construct The scope in which to define this construct. id Required \u00b6 Type: java.lang.String The scoped construct ID. Must be unique amongst siblings. If the ID includes a path separator ( / ), then it will be replaced by double dash -- . nodeFactory Optional \u00b6 Type: software.constructs.INodeFactory Default: the default Node is associated A factory for attaching Node s to the construct. Properties \u00b6 metadata Required \u00b6 public ApiObjectMetadataDefinition getMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this API object. Secret \u00b6 Implements: org.cdk8s.plus22.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret Initializers \u00b6 import org.cdk8s.plus22.Secret ; Secret . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .stringData(java.util.Map<java.lang.String, java.lang.String>) // .type(java.lang.String) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. stringData Optional \u00b6 Type: java.util.Map java.lang.String > stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 Type: java.lang.String Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. Methods \u00b6 addStringData \u00b6 public addStringData ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String Key. value Required \u00b6 Type: java.lang.String Value. getStringData \u00b6 public getStringData ( java . lang . String key ) key Required \u00b6 Type: java.lang.String Key. Static Functions \u00b6 fromSecretName \u00b6 import org.cdk8s.plus22.Secret ; Secret . fromSecretName ( java . lang . String name ) name Required \u00b6 Type: java.lang.String The name of the secret to reference. Service \u00b6 An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods. Initializers \u00b6 import org.cdk8s.plus22.Service ; Service . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .clusterIP(java.lang.String) // .externalIPs(java.util.List<java.lang.String>) // .externalName(java.lang.String) // .loadBalancerSourceRanges(java.util.List<java.lang.String>) // .ports(java.util.List<ServicePort>) // .type(ServiceType) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. clusterIP Optional \u00b6 Type: java.lang.String Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies externalIPs Optional \u00b6 Type: java.util.List< java.lang.String > Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. externalName Optional \u00b6 Type: java.lang.String Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. loadBalancerSourceRanges Optional \u00b6 Type: java.util.List< java.lang.String > A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ServicePort > The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 Type: org.cdk8s.plus22.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types Methods \u00b6 addDeployment \u00b6 public addDeployment ( Deployment deployment ) public addDeployment ( Deployment deployment , AddDeploymentOptions options ) deployment Required \u00b6 Type: org.cdk8s.plus22.Deployment The deployment to expose. options Optional \u00b6 Type: org.cdk8s.plus22.AddDeploymentOptions Optional settings for the port. addSelector \u00b6 public addSelector ( java . lang . String label , java . lang . String value ) label Required \u00b6 Type: java.lang.String The label key. value Required \u00b6 Type: java.lang.String The label value. exposeViaIngress \u00b6 public exposeViaIngress ( java . lang . String path ) public exposeViaIngress ( java . lang . String path , ExposeServiceViaIngressOptions options ) path Required \u00b6 Type: java.lang.String The path to expose the service under. options Optional \u00b6 Type: org.cdk8s.plus22.ExposeServiceViaIngressOptions Additional options. serve \u00b6 public serve ( java . lang . Number port ) public serve ( java . lang . Number port , ServicePortOptions options ) port Required \u00b6 Type: java.lang.Number The port definition. options Optional \u00b6 Type: org.cdk8s.plus22.ServicePortOptions Properties \u00b6 ports Required \u00b6 public java . util . List < ServicePort > getPorts (); Type: java.util.List< org.cdk8s.plus22.ServicePort > Ports for this service. Use serve() to expose additional service ports. selector Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getSelector (); Type: java.util.Map java.lang.String > Returns the labels which are used to select pods for this service. type Required \u00b6 public ServiceType getType (); Type: org.cdk8s.plus22.ServiceType Determines how the Service is exposed. clusterIP Optional \u00b6 public java . lang . String getClusterIP (); Type: java.lang.String The IP address of the service and is usually assigned randomly by the master. externalName Optional \u00b6 public java . lang . String getExternalName (); Type: java.lang.String The externalName to be used for EXTERNAL_NAME types. ServiceAccount \u00b6 Implements: org.cdk8s.plus22.IServiceAccount A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account Initializers \u00b6 import org.cdk8s.plus22.ServiceAccount ; ServiceAccount . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .secrets(java.util.List<ISecret>) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. secrets Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ISecret > List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret Methods \u00b6 addSecret \u00b6 public addSecret ( ISecret secret ) secret Required \u00b6 Type: org.cdk8s.plus22.ISecret The secret. Static Functions \u00b6 fromServiceAccountName \u00b6 import org.cdk8s.plus22.ServiceAccount ; ServiceAccount . fromServiceAccountName ( java . lang . String name ) name Required \u00b6 Type: java.lang.String The name of the service account resource. Properties \u00b6 secrets Required \u00b6 public java . util . List < ISecret > getSecrets (); Type: java.util.List< org.cdk8s.plus22.ISecret > List of secrets allowed to be used by pods running using this service account. Returns a copy. To add a secret, use addSecret() . StatefulSet \u00b6 Implements: org.cdk8s.plus22.IPodTemplate StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed. Using StatefulSets \u00b6 StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates. Initializers \u00b6 import org.cdk8s.plus22.StatefulSet ; StatefulSet . Builder . create ( Construct scope , java . lang . String id ) // .metadata(ApiObjectMetadata) // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) . service ( Service ) // .defaultSelector(java.lang.Boolean) // .podManagementPolicy(PodManagementPolicy) // .replicas(java.lang.Number) . build (); scope Required \u00b6 Type: software.constructs.Construct id Required \u00b6 Type: java.lang.String metadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata. service Required \u00b6 Type: org.cdk8s.plus22.Service Service to associate with the statefulset. defaultSelector Optional \u00b6 Type: java.lang.Boolean Default: true Automatically allocates a pod selector for this statefulset. If this is set to false you must define your selector through statefulset.podMetadata.addLabel() and statefulset.selectByLabel() . podManagementPolicy Optional \u00b6 Type: org.cdk8s.plus22.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 Type: java.lang.Number Default: 1 Number of desired pods. Methods \u00b6 addContainer \u00b6 public addContainer ( ContainerProps container ) container Required \u00b6 Type: org.cdk8s.plus22.ContainerProps addVolume \u00b6 public addVolume ( Volume volume ) volume Required \u00b6 Type: org.cdk8s.plus22.Volume selectByLabel \u00b6 public selectByLabel ( java . lang . String key , java . lang . String value ) key Required \u00b6 Type: java.lang.String The label key. value Required \u00b6 Type: java.lang.String The label value. Properties \u00b6 containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus22.Container > The containers belonging to the pod. Use addContainer to add containers. labelSelector Required \u00b6 public java . util . Map < java . lang . String , java . lang . String > getLabelSelector (); Type: java.util.Map java.lang.String > The labels this statefulset will match against in order to select pods. Returns a a copy. Use selectByLabel() to add labels. podManagementPolicy Required \u00b6 public PodManagementPolicy getPodManagementPolicy (); Type: org.cdk8s.plus22.PodManagementPolicy Management policy to use for the set. podMetadata Required \u00b6 public ApiObjectMetadataDefinition getPodMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. replicas Required \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Number of desired pods. volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus22.Volume > The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus22.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus22.IServiceAccount The service account used to run this pod. Structs \u00b6 AddDeploymentOptions \u00b6 Options to add a deployment to a service. Initializer \u00b6 import org.cdk8s.plus22.AddDeploymentOptions ; AddDeploymentOptions . builder () // .name(java.lang.String) // .nodePort(java.lang.Number) // .protocol(Protocol) // .targetPort(java.lang.Number) // .port(java.lang.Number) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public java . lang . Number getNodePort (); Type: java.lang.Number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The value of port will be used. The port number the service will redirect to. port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: Copied from the first container of the deployment. The port number the service will bind to. AddDirectoryOptions \u00b6 Options for configmap.addDirectory() . Initializer \u00b6 import org.cdk8s.plus22.AddDirectoryOptions ; AddDirectoryOptions . builder () // .exclude(java.util.List<java.lang.String>) // .keyPrefix(java.lang.String) . build (); exclude Optional \u00b6 public java . util . List < java . lang . String > getExclude (); Type: java.util.List< java.lang.String > Default: include all files Glob patterns to exclude when adding files. keyPrefix Optional \u00b6 public java . lang . String getKeyPrefix (); Type: java.lang.String Default: \u201c\u201d A prefix to add to all keys in the config map. CommandProbeOptions \u00b6 Options for Probe.fromCommand() . Initializer \u00b6 import org.cdk8s.plus22.CommandProbeOptions ; CommandProbeOptions . builder () // .failureThreshold(java.lang.Number) // .initialDelaySeconds(Duration) // .periodSeconds(Duration) // .successThreshold(java.lang.Number) // .timeoutSeconds(Duration) . build (); failureThreshold Optional \u00b6 public java . lang . Number getFailureThreshold (); Type: java.lang.Number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public Duration getInitialDelaySeconds (); Type: org.cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public Duration getPeriodSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public java . lang . Number getSuccessThreshold (); Type: java.lang.Number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public Duration getTimeoutSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ConfigMapProps \u00b6 Properties for initialization of ConfigMap . Initializer \u00b6 import org.cdk8s.plus22.ConfigMapProps ; ConfigMapProps . builder () // .metadata(ApiObjectMetadata) // .binaryData(java.util.Map<java.lang.String, java.lang.String>) // .data(java.util.Map<java.lang.String, java.lang.String>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binaryData Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getBinaryData (); Type: java.util.Map java.lang.String > BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. Using this field will require 1.10+ apiserver and kubelet. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getData (); Type: java.util.Map java.lang.String > Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . ConfigMapVolumeOptions \u00b6 Options for the ConfigMap-based volume. Initializer \u00b6 import org.cdk8s.plus22.ConfigMapVolumeOptions ; ConfigMapVolumeOptions . builder () // .defaultMode(java.lang.Number) // .items(java.util.Map<java.lang.String, PathMapping>) // .name(java.lang.String) // .optional(java.lang.Boolean) . build (); defaultMode Optional \u00b6 public java . lang . Number getDefaultMode (); Type: java.lang.Number Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 public java . util . Map < java . lang . String , PathMapping > getItems (); Type: java.util.Map \u0002klzzwxh:3362\u0003 > Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: auto-generated The volume name. optional Optional \u00b6 public java . lang . Boolean getOptional (); Type: java.lang.Boolean Default: undocumented Specify whether the ConfigMap or its keys must be defined. ContainerProps \u00b6 Properties for creating a container. Initializer \u00b6 import org.cdk8s.plus22.ContainerProps ; ContainerProps . builder () . image ( java . lang . String ) // .args(java.util.List<java.lang.String>) // .command(java.util.List<java.lang.String>) // .env(java.util.Map<java.lang.String, EnvValue>) // .imagePullPolicy(ImagePullPolicy) // .liveness(Probe) // .name(java.lang.String) // .port(java.lang.Number) // .readiness(Probe) // .startup(Probe) // .volumeMounts(java.util.List<VolumeMount>) // .workingDir(java.lang.String) . build (); image Required \u00b6 public java . lang . String getImage (); Type: java.lang.String Docker image name. args Optional \u00b6 public java . util . List < java . lang . String > getArgs (); Type: java.util.List< java.lang.String > Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 public java . util . List < java . lang . String > getCommand (); Type: java.util.List< java.lang.String > Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 public java . util . Map < java . lang . String , EnvValue > getEnv (); Type: java.util.Map \u0002klzzwxh:3343\u0003 > Default: No environment variables. List of environment variables to set in the container. Cannot be updated. imagePullPolicy Optional \u00b6 public ImagePullPolicy getImagePullPolicy (); Type: org.cdk8s.plus22.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 public Probe getLiveness (); Type: org.cdk8s.plus22.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 public Probe getReadiness (); Type: org.cdk8s.plus22.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 public Probe getStartup (); Type: org.cdk8s.plus22.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volumeMounts Optional \u00b6 public java . util . List < VolumeMount > getVolumeMounts (); Type: java.util.List< org.cdk8s.plus22.VolumeMount > Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. workingDir Optional \u00b6 public java . lang . String getWorkingDir (); Type: java.lang.String Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. DeploymentProps \u00b6 Properties for initialization of Deployment . Initializer \u00b6 import org.cdk8s.plus22.DeploymentProps ; DeploymentProps . builder () // .metadata(ApiObjectMetadata) // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .defaultSelector(java.lang.Boolean) // .replicas(java.lang.Number) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata. defaultSelector Optional \u00b6 public java . lang . Boolean getDefaultSelector (); Type: java.lang.Boolean Default: true Automatically allocates a pod selector for this deployment. If this is set to false you must define your selector through deployment.podMetadata.addLabel() and deployment.selectByLabel() . replicas Optional \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Default: 1 Number of desired pods. EmptyDirVolumeOptions \u00b6 Options for volumes populated with an empty directory. Initializer \u00b6 import org.cdk8s.plus22.EmptyDirVolumeOptions ; EmptyDirVolumeOptions . builder () // .medium(EmptyDirMedium) // .sizeLimit(Size) . build (); medium Optional \u00b6 public EmptyDirMedium getMedium (); Type: org.cdk8s.plus22.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. sizeLimit Optional \u00b6 public Size getSizeLimit (); Type: org.cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. EnvValueFromConfigMapOptions \u00b6 Options to specify an envionment variable value from a ConfigMap key. Initializer \u00b6 import org.cdk8s.plus22.EnvValueFromConfigMapOptions ; EnvValueFromConfigMapOptions . builder () // .optional(java.lang.Boolean) . build (); optional Optional \u00b6 public java . lang . Boolean getOptional (); Type: java.lang.Boolean Default: false Specify whether the ConfigMap or its key must be defined. EnvValueFromProcessOptions \u00b6 Options to specify an environment variable value from the process environment. Initializer \u00b6 import org.cdk8s.plus22.EnvValueFromProcessOptions ; EnvValueFromProcessOptions . builder () // .required(java.lang.Boolean) . build (); required Optional \u00b6 public java . lang . Boolean getRequired (); Type: java.lang.Boolean Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. EnvValueFromSecretOptions \u00b6 Options to specify an environment variable value from a Secret. Initializer \u00b6 import org.cdk8s.plus22.EnvValueFromSecretOptions ; EnvValueFromSecretOptions . builder () // .optional(java.lang.Boolean) . build (); optional Optional \u00b6 public java . lang . Boolean getOptional (); Type: java.lang.Boolean Default: false Specify whether the Secret or its key must be defined. ExposeDeploymentViaIngressOptions \u00b6 Options for exposing a deployment via an ingress. Initializer \u00b6 import org.cdk8s.plus22.ExposeDeploymentViaIngressOptions ; ExposeDeploymentViaIngressOptions . builder () // .name(java.lang.String) // .port(java.lang.Number) // .protocol(Protocol) // .serviceType(ServiceType) // .targetPort(java.lang.Number) // .ingress(Ingress) // .pathType(HttpIngressPathType) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. serviceType Optional \u00b6 public ServiceType getServiceType (); Type: org.cdk8s.plus22.ServiceType Default: ClusterIP. The type of the exposed service. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ingress Optional \u00b6 public Ingress getIngress (); Type: org.cdk8s.plus22.Ingress Default: An ingress will be automatically created. The ingress to add rules to. pathType Optional \u00b6 public HttpIngressPathType getPathType (); Type: org.cdk8s.plus22.HttpIngressPathType Default: HttpIngressPathType.PREFIX The type of the path. ExposeDeploymentViaServiceOptions \u00b6 Options for exposing a deployment via a service. Initializer \u00b6 import org.cdk8s.plus22.ExposeDeploymentViaServiceOptions ; ExposeDeploymentViaServiceOptions . builder () // .name(java.lang.String) // .port(java.lang.Number) // .protocol(Protocol) // .serviceType(ServiceType) // .targetPort(java.lang.Number) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. serviceType Optional \u00b6 public ServiceType getServiceType (); Type: org.cdk8s.plus22.ServiceType Default: ClusterIP. The type of the exposed service. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ExposeServiceViaIngressOptions \u00b6 Options for exposing a service using an ingress. Initializer \u00b6 import org.cdk8s.plus22.ExposeServiceViaIngressOptions ; ExposeServiceViaIngressOptions . builder () // .ingress(Ingress) // .pathType(HttpIngressPathType) . build (); ingress Optional \u00b6 public Ingress getIngress (); Type: org.cdk8s.plus22.Ingress Default: An ingress will be automatically created. The ingress to add rules to. pathType Optional \u00b6 public HttpIngressPathType getPathType (); Type: org.cdk8s.plus22.HttpIngressPathType Default: HttpIngressPathType.PREFIX The type of the path. HttpGetProbeOptions \u00b6 Options for Probe.fromHttpGet() . Initializer \u00b6 import org.cdk8s.plus22.HttpGetProbeOptions ; HttpGetProbeOptions . builder () // .failureThreshold(java.lang.Number) // .initialDelaySeconds(Duration) // .periodSeconds(Duration) // .successThreshold(java.lang.Number) // .timeoutSeconds(Duration) // .port(java.lang.Number) . build (); failureThreshold Optional \u00b6 public java . lang . Number getFailureThreshold (); Type: java.lang.Number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public Duration getInitialDelaySeconds (); Type: org.cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public Duration getPeriodSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public java . lang . Number getSuccessThreshold (); Type: java.lang.Number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public Duration getTimeoutSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: defaults to container.port . The TCP port to use when sending the GET request. IngressProps \u00b6 Properties for Ingress . Initializer \u00b6 import org.cdk8s.plus22.IngressProps ; IngressProps . builder () // .metadata(ApiObjectMetadata) // .defaultBackend(IngressBackend) // .rules(java.util.List<IngressRule>) // .tls(java.util.List<IngressTls>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. defaultBackend Optional \u00b6 public IngressBackend getDefaultBackend (); Type: org.cdk8s.plus22.IngressBackend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 public java . util . List < IngressRule > getRules (); Type: java.util.List< org.cdk8s.plus22.IngressRule > Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 public java . util . List < IngressTls > getTls (); Type: java.util.List< org.cdk8s.plus22.IngressTls > TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. IngressRule \u00b6 Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path. Initializer \u00b6 import org.cdk8s.plus22.IngressRule ; IngressRule . builder () . backend ( IngressBackend ) // .host(java.lang.String) // .path(java.lang.String) // .pathType(HttpIngressPathType) . build (); backend Required \u00b6 public IngressBackend getBackend (); Type: org.cdk8s.plus22.IngressBackend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 public java . lang . String getHost (); Type: java.lang.String Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 public java . lang . String getPath (); Type: java.lang.String Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. pathType Optional \u00b6 public HttpIngressPathType getPathType (); Type: org.cdk8s.plus22.HttpIngressPathType Specify how the path is matched against request paths. By default, path types will be matched by prefix. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types IngressTls \u00b6 Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination. Initializer \u00b6 import org.cdk8s.plus22.IngressTls ; IngressTls . builder () // .hosts(java.util.List<java.lang.String>) // .secret(ISecret) . build (); hosts Optional \u00b6 public java . util . List < java . lang . String > getHosts (); Type: java.util.List< java.lang.String > Default: If unspecified, it defaults to the wildcard host setting for the loadbalancer controller fulfilling this Ingress. Hosts are a list of hosts included in the TLS certificate. The values in this list must match the name/s used in the TLS Secret. secret Optional \u00b6 public ISecret getSecret (); Type: org.cdk8s.plus22.ISecret Default: If unspecified, it allows SSL routing based on SNI hostname. Secret is the secret that contains the certificate and key used to terminate SSL traffic on 443. If the SNI host in a listener conflicts with the \u201cHost\u201d header field used by an IngressRule, the SNI host is used for termination and value of the Host header is used for routing. JobProps \u00b6 Properties for initialization of Job . Initializer \u00b6 import org.cdk8s.plus22.JobProps ; JobProps . builder () // .metadata(ApiObjectMetadata) // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) // .activeDeadline(Duration) // .backoffLimit(java.lang.Number) // .ttlAfterFinished(Duration) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata. activeDeadline Optional \u00b6 public Duration getActiveDeadline (); Type: org.cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 public java . lang . Number getBackoffLimit (); Type: java.lang.Number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 public Duration getTtlAfterFinished (); Type: org.cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. MountOptions \u00b6 Options for mounts. Initializer \u00b6 import org.cdk8s.plus22.MountOptions ; MountOptions . builder () // .propagation(MountPropagation) // .readOnly(java.lang.Boolean) // .subPath(java.lang.String) // .subPathExpr(java.lang.String) . build (); propagation Optional \u00b6 public MountPropagation getPropagation (); Type: org.cdk8s.plus22.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. This field is beta in 1.10. readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public java . lang . String getSubPath (); Type: java.lang.String Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public java . lang . String getSubPathExpr (); Type: java.lang.String Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). SubPathExpr and SubPath are mutually exclusive. This field is beta in 1.15. subPathExpr and subPath are mutually exclusive. This field is beta in 1.15. PathMapping \u00b6 Maps a string key to a path within a volume. Initializer \u00b6 import org.cdk8s.plus22.PathMapping ; PathMapping . builder () . path ( java . lang . String ) // .mode(java.lang.Number) . build (); path Required \u00b6 public java . lang . String getPath (); Type: java.lang.String The relative path of the file to map the key to. May not be an absolute path. May not contain the path element \u2018..\u2019. May not start with the string \u2018..\u2019. mode Optional \u00b6 public java . lang . Number getMode (); Type: java.lang.Number Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. PodProps \u00b6 Properties for initialization of Pod . Initializer \u00b6 import org.cdk8s.plus22.PodProps ; PodProps . builder () // .metadata(ApiObjectMetadata) // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodSpecProps \u00b6 Properties of a PodSpec . Initializer \u00b6 import org.cdk8s.plus22.PodSpecProps ; PodSpecProps . builder () // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodTemplateProps \u00b6 Properties of a PodTemplate . Adds metadata information on top of the spec. Initializer \u00b6 import org.cdk8s.plus22.PodTemplateProps ; PodTemplateProps . builder () // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) . build (); containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata. ProbeOptions \u00b6 Probe options. Initializer \u00b6 import org.cdk8s.plus22.ProbeOptions ; ProbeOptions . builder () // .failureThreshold(java.lang.Number) // .initialDelaySeconds(Duration) // .periodSeconds(Duration) // .successThreshold(java.lang.Number) // .timeoutSeconds(Duration) . build (); failureThreshold Optional \u00b6 public java . lang . Number getFailureThreshold (); Type: java.lang.Number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public Duration getInitialDelaySeconds (); Type: org.cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public Duration getPeriodSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public java . lang . Number getSuccessThreshold (); Type: java.lang.Number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public Duration getTimeoutSeconds (); Type: org.cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ResourceProps \u00b6 Initialization properties for resources. Initializer \u00b6 import org.cdk8s.plus22.ResourceProps ; ResourceProps . builder () // .metadata(ApiObjectMetadata) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. SecretProps \u00b6 Initializer \u00b6 import org.cdk8s.plus22.SecretProps ; SecretProps . builder () // .metadata(ApiObjectMetadata) // .stringData(java.util.Map<java.lang.String, java.lang.String>) // .type(java.lang.String) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. stringData Optional \u00b6 public java . util . Map < java . lang . String , java . lang . String > getStringData (); Type: java.util.Map java.lang.String > stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 public java . lang . String getType (); Type: java.lang.String Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. SecretValue \u00b6 Represents a specific value in JSON secret. Initializer \u00b6 import org.cdk8s.plus22.SecretValue ; SecretValue . builder () . key ( java . lang . String ) . secret ( ISecret ) . build (); key Required \u00b6 public java . lang . String getKey (); Type: java.lang.String The JSON key. secret Required \u00b6 public ISecret getSecret (); Type: org.cdk8s.plus22.ISecret The secret. ServiceAccountProps \u00b6 Properties for initialization of ServiceAccount . Properties for initialization of ServiceAccount . Initializer \u00b6 import org.cdk8s.plus22.ServiceAccountProps ; ServiceAccountProps . builder () // .metadata(ApiObjectMetadata) // .secrets(java.util.List<ISecret>) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. secrets Optional \u00b6 public java . util . List < ISecret > getSecrets (); Type: java.util.List< org.cdk8s.plus22.ISecret > List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret ServiceIngressBackendOptions \u00b6 Options for setting up backends for ingress rules. Initializer \u00b6 import org.cdk8s.plus22.ServiceIngressBackendOptions ; ServiceIngressBackendOptions . builder () // .port(java.lang.Number) . build (); port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. If the service exposes multiple ports, this option must be specified. If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. ServicePort \u00b6 Definition of a service port. Initializer \u00b6 import org.cdk8s.plus22.ServicePort ; ServicePort . builder () // .name(java.lang.String) // .nodePort(java.lang.Number) // .protocol(Protocol) // .targetPort(java.lang.Number) . port ( java . lang . Number ) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public java . lang . Number getNodePort (); Type: java.lang.Number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The value of port will be used. The port number the service will redirect to. port Required \u00b6 public java . lang . Number getPort (); Type: java.lang.Number The port number the service will bind to. ServicePortOptions \u00b6 Initializer \u00b6 import org.cdk8s.plus22.ServicePortOptions ; ServicePortOptions . builder () // .name(java.lang.String) // .nodePort(java.lang.Number) // .protocol(Protocol) // .targetPort(java.lang.Number) . build (); name Optional \u00b6 public java . lang . String getName (); Type: java.lang.String The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public java . lang . Number getNodePort (); Type: java.lang.Number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public Protocol getProtocol (); Type: org.cdk8s.plus22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public java . lang . Number getTargetPort (); Type: java.lang.Number Default: The value of port will be used. The port number the service will redirect to. ServiceProps \u00b6 Properties for initialization of Service . Initializer \u00b6 import org.cdk8s.plus22.ServiceProps ; ServiceProps . builder () // .metadata(ApiObjectMetadata) // .clusterIP(java.lang.String) // .externalIPs(java.util.List<java.lang.String>) // .externalName(java.lang.String) // .loadBalancerSourceRanges(java.util.List<java.lang.String>) // .ports(java.util.List<ServicePort>) // .type(ServiceType) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. clusterIP Optional \u00b6 public java . lang . String getClusterIP (); Type: java.lang.String Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies externalIPs Optional \u00b6 public java . util . List < java . lang . String > getExternalIPs (); Type: java.util.List< java.lang.String > Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. externalName Optional \u00b6 public java . lang . String getExternalName (); Type: java.lang.String Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. loadBalancerSourceRanges Optional \u00b6 public java . util . List < java . lang . String > getLoadBalancerSourceRanges (); Type: java.util.List< java.lang.String > A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 public java . util . List < ServicePort > getPorts (); Type: java.util.List< org.cdk8s.plus22.ServicePort > The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 public ServiceType getType (); Type: org.cdk8s.plus22.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types StatefulSetProps \u00b6 Properties for initialization of StatefulSet . Initializer \u00b6 import org.cdk8s.plus22.StatefulSetProps ; StatefulSetProps . builder () // .metadata(ApiObjectMetadata) // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) . service ( Service ) // .defaultSelector(java.lang.Boolean) // .podManagementPolicy(PodManagementPolicy) // .replicas(java.lang.Number) . build (); metadata Optional \u00b6 public ApiObjectMetadata getMetadata (); Type: org.cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 public java . util . List < ContainerProps > getContainers (); Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public ApiObjectMetadata getPodMetadata (); Type: org.cdk8s.ApiObjectMetadata The pod metadata. service Required \u00b6 public Service getService (); Type: org.cdk8s.plus22.Service Service to associate with the statefulset. defaultSelector Optional \u00b6 public java . lang . Boolean getDefaultSelector (); Type: java.lang.Boolean Default: true Automatically allocates a pod selector for this statefulset. If this is set to false you must define your selector through statefulset.podMetadata.addLabel() and statefulset.selectByLabel() . podManagementPolicy Optional \u00b6 public PodManagementPolicy getPodManagementPolicy (); Type: org.cdk8s.plus22.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 public java . lang . Number getReplicas (); Type: java.lang.Number Default: 1 Number of desired pods. VolumeMount \u00b6 Mount a volume from the pod to the container. Initializer \u00b6 import org.cdk8s.plus22.VolumeMount ; VolumeMount . builder () // .propagation(MountPropagation) // .readOnly(java.lang.Boolean) // .subPath(java.lang.String) // .subPathExpr(java.lang.String) . path ( java . lang . String ) . volume ( Volume ) . build (); propagation Optional \u00b6 public MountPropagation getPropagation (); Type: org.cdk8s.plus22.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. This field is beta in 1.10. readOnly Optional \u00b6 public java . lang . Boolean getReadOnly (); Type: java.lang.Boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public java . lang . String getSubPath (); Type: java.lang.String Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public java . lang . String getSubPathExpr (); Type: java.lang.String Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). SubPathExpr and SubPath are mutually exclusive. This field is beta in 1.15. subPathExpr and subPath are mutually exclusive. This field is beta in 1.15. path Required \u00b6 public java . lang . String getPath (); Type: java.lang.String Path within the container at which the volume should be mounted. Must not contain \u2018:\u2019. volume Required \u00b6 public Volume getVolume (); Type: org.cdk8s.plus22.Volume The volume to mount. Classes \u00b6 Container \u00b6 A single application container that you want to run within a pod. Initializers \u00b6 import org.cdk8s.plus22.Container ; Container . Builder . create () . image ( java . lang . String ) // .args(java.util.List<java.lang.String>) // .command(java.util.List<java.lang.String>) // .env(java.util.Map<java.lang.String, EnvValue>) // .imagePullPolicy(ImagePullPolicy) // .liveness(Probe) // .name(java.lang.String) // .port(java.lang.Number) // .readiness(Probe) // .startup(Probe) // .volumeMounts(java.util.List<VolumeMount>) // .workingDir(java.lang.String) . build (); image Required \u00b6 Type: java.lang.String Docker image name. args Optional \u00b6 Type: java.util.List< java.lang.String > Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: java.util.List< java.lang.String > Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: java.util.Map \u0002klzzwxh:2904\u0003 > Default: No environment variables. List of environment variables to set in the container. Cannot be updated. imagePullPolicy Optional \u00b6 Type: org.cdk8s.plus22.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: org.cdk8s.plus22.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: java.lang.String Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: java.lang.Number Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: org.cdk8s.plus22.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: org.cdk8s.plus22.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volumeMounts Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.VolumeMount > Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. workingDir Optional \u00b6 Type: java.lang.String Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. Methods \u00b6 addEnv \u00b6 public addEnv ( java . lang . String name , EnvValue value ) name Required \u00b6 Type: java.lang.String The variable name. value Required \u00b6 Type: org.cdk8s.plus22.EnvValue The variable value. mount \u00b6 public mount ( java . lang . String path , Volume volume ) public mount ( java . lang . String path , Volume volume , MountOptions options ) path Required \u00b6 Type: java.lang.String The desired path in the container. volume Required \u00b6 Type: org.cdk8s.plus22.Volume The volume to mount. options Optional \u00b6 Type: org.cdk8s.plus22.MountOptions Properties \u00b6 env Required \u00b6 public java . util . Map < java . lang . String , EnvValue > getEnv (); Type: java.util.Map \u0002klzzwxh:2859\u0003 > The environment variables for this container. Returns a copy. To add environment variables use addEnv() . image Required \u00b6 public java . lang . String getImage (); Type: java.lang.String The container image. imagePullPolicy Required \u00b6 public ImagePullPolicy getImagePullPolicy (); Type: org.cdk8s.plus22.ImagePullPolicy Image pull policy for this container. mounts Required \u00b6 public java . util . List < VolumeMount > getMounts (); Type: java.util.List< org.cdk8s.plus22.VolumeMount > Volume mounts configured for this container. name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The name of the container. args Optional \u00b6 public java . util . List < java . lang . String > getArgs (); Type: java.util.List< java.lang.String > Arguments to the entrypoint. command Optional \u00b6 public java . util . List < java . lang . String > getCommand (); Type: java.util.List< java.lang.String > Entrypoint array (the command to execute when the container starts). port Optional \u00b6 public java . lang . Number getPort (); Type: java.lang.Number The port this container exposes. workingDir Optional \u00b6 public java . lang . String getWorkingDir (); Type: java.lang.String The working directory inside the container. EnvValue \u00b6 Utility class for creating reading env values from various sources. Static Functions \u00b6 fromConfigMap \u00b6 import org.cdk8s.plus22.EnvValue ; EnvValue . fromConfigMap ( IConfigMap configMap , java . lang . String key ) EnvValue . fromConfigMap ( IConfigMap configMap , java . lang . String key , EnvValueFromConfigMapOptions options ) configMap Required \u00b6 Type: org.cdk8s.plus22.IConfigMap The config map. key Required \u00b6 Type: java.lang.String The key to extract the value from. options Optional \u00b6 Type: org.cdk8s.plus22.EnvValueFromConfigMapOptions Additional options. fromProcess \u00b6 import org.cdk8s.plus22.EnvValue ; EnvValue . fromProcess ( java . lang . String key ) EnvValue . fromProcess ( java . lang . String key , EnvValueFromProcessOptions options ) key Required \u00b6 Type: java.lang.String The key to read. options Optional \u00b6 Type: org.cdk8s.plus22.EnvValueFromProcessOptions Additional options. fromSecretValue \u00b6 import org.cdk8s.plus22.EnvValue ; EnvValue . fromSecretValue ( SecretValue secretValue ) EnvValue . fromSecretValue ( SecretValue secretValue , EnvValueFromSecretOptions options ) secretValue Required \u00b6 Type: org.cdk8s.plus22.SecretValue The secret value (secrent + key). options Optional \u00b6 Type: org.cdk8s.plus22.EnvValueFromSecretOptions Additional options. fromValue \u00b6 import org.cdk8s.plus22.EnvValue ; EnvValue . fromValue ( java . lang . String value ) value Required \u00b6 Type: java.lang.String The value. Properties \u00b6 value Optional \u00b6 public java . lang . Object getValue (); Type: java.lang.Object valueFrom Optional \u00b6 public java . lang . Object getValueFrom (); Type: java.lang.Object IngressBackend \u00b6 The backend for an ingress path. Static Functions \u00b6 fromService \u00b6 import org.cdk8s.plus22.IngressBackend ; IngressBackend . fromService ( Service service ) IngressBackend . fromService ( Service service , ServiceIngressBackendOptions options ) service Required \u00b6 Type: org.cdk8s.plus22.Service The service object. options Optional \u00b6 Type: org.cdk8s.plus22.ServiceIngressBackendOptions PodSpec \u00b6 Implements: org.cdk8s.plus22.IPodSpec Provides read/write capabilities ontop of a PodSpecProps . Initializers \u00b6 import org.cdk8s.plus22.PodSpec ; PodSpec . Builder . create () // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) . build (); containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Methods \u00b6 addContainer \u00b6 public addContainer ( ContainerProps container ) container Required \u00b6 Type: org.cdk8s.plus22.ContainerProps addVolume \u00b6 public addVolume ( Volume volume ) volume Required \u00b6 Type: org.cdk8s.plus22.Volume Properties \u00b6 containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus22.Container > The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus22.Volume > The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus22.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus22.IServiceAccount The service account used to run this pod. PodTemplate \u00b6 Implements: org.cdk8s.plus22.IPodTemplate Provides read/write capabilities ontop of a PodTemplateProps . Initializers \u00b6 import org.cdk8s.plus22.PodTemplate ; PodTemplate . Builder . create () // .containers(java.util.List<ContainerProps>) // .restartPolicy(RestartPolicy) // .serviceAccount(IServiceAccount) // .volumes(java.util.List<Volume>) // .podMetadata(ApiObjectMetadata) . build (); containers Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.ContainerProps > Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 Type: org.cdk8s.plus22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 Type: org.cdk8s.plus22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: java.util.List< org.cdk8s.plus22.Volume > Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 Type: org.cdk8s.ApiObjectMetadata The pod metadata. Properties \u00b6 podMetadata Required \u00b6 public ApiObjectMetadataDefinition getPodMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. Probe \u00b6 Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic. Initializers \u00b6 import org.cdk8s.plus22.Probe ; new Probe (); Static Functions \u00b6 fromCommand \u00b6 import org.cdk8s.plus22.Probe ; Probe . fromCommand ( java . util . List < java . lang . String > command ) Probe . fromCommand ( java . util . List < java . lang . String > command , CommandProbeOptions options ) command Required \u00b6 Type: java.util.List< java.lang.String > The command to execute. options Optional \u00b6 Type: org.cdk8s.plus22.CommandProbeOptions Options. fromHttpGet \u00b6 import org.cdk8s.plus22.Probe ; Probe . fromHttpGet ( java . lang . String path ) Probe . fromHttpGet ( java . lang . String path , HttpGetProbeOptions options ) path Required \u00b6 Type: java.lang.String The URL path to hit. options Optional \u00b6 Type: org.cdk8s.plus22.HttpGetProbeOptions Options. Volume \u00b6 Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes Initializers \u00b6 import org.cdk8s.plus22.Volume ; new Volume ( java . lang . String name , java . lang . Object config ); name Required \u00b6 Type: java.lang.String config Required \u00b6 Type: java.lang.Object Static Functions \u00b6 fromConfigMap \u00b6 import org.cdk8s.plus22.Volume ; Volume . fromConfigMap ( IConfigMap configMap ) Volume . fromConfigMap ( IConfigMap configMap , ConfigMapVolumeOptions options ) configMap Required \u00b6 Type: org.cdk8s.plus22.IConfigMap The config map to use to populate the volume. options Optional \u00b6 Type: org.cdk8s.plus22.ConfigMapVolumeOptions Options. fromEmptyDir \u00b6 import org.cdk8s.plus22.Volume ; Volume . fromEmptyDir ( java . lang . String name ) Volume . fromEmptyDir ( java . lang . String name , EmptyDirVolumeOptions options ) name Required \u00b6 Type: java.lang.String options Optional \u00b6 Type: org.cdk8s.plus22.EmptyDirVolumeOptions Additional options. Properties \u00b6 name Required \u00b6 public java . lang . String getName (); Type: java.lang.String Protocols \u00b6 IConfigMap \u00b6 Extends: org.cdk8s.plus22.IResource Implemented By: org.cdk8s.plus22.ConfigMap , org.cdk8s.plus22.IConfigMap Represents a config map. Properties \u00b6 name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IPodSpec \u00b6 Implemented By: org.cdk8s.plus22.Deployment , org.cdk8s.plus22.Job , org.cdk8s.plus22.Pod , org.cdk8s.plus22.PodSpec , org.cdk8s.plus22.PodTemplate , org.cdk8s.plus22.StatefulSet , org.cdk8s.plus22.IPodSpec , org.cdk8s.plus22.IPodTemplate Represents a resource that can be configured with a kuberenets pod spec. (e.g Deployment , Job , Pod , \u2026). Use the PodSpec class as an implementation helper. Methods \u00b6 addContainer \u00b6 public addContainer ( ContainerProps container ) container Required \u00b6 Type: org.cdk8s.plus22.ContainerProps The container. addVolume \u00b6 public addVolume ( Volume volume ) volume Required \u00b6 Type: org.cdk8s.plus22.Volume The volume. Properties \u00b6 containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus22.Container > The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus22.Volume > The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus22.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus22.IServiceAccount The service account used to run this pod. IPodTemplate \u00b6 Extends: org.cdk8s.plus22.IPodSpec Implemented By: org.cdk8s.plus22.Deployment , org.cdk8s.plus22.Job , org.cdk8s.plus22.PodTemplate , org.cdk8s.plus22.StatefulSet , org.cdk8s.plus22.IPodTemplate Represents a resource that can be configured with a kuberenets pod template. (e.g Deployment , Job , \u2026). Use the PodTemplate class as an implementation helper. Properties \u00b6 containers Required \u00b6 public java . util . List < Container > getContainers (); Type: java.util.List< org.cdk8s.plus22.Container > The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 public java . util . List < Volume > getVolumes (); Type: java.util.List< org.cdk8s.plus22.Volume > The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public RestartPolicy getRestartPolicy (); Type: org.cdk8s.plus22.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public IServiceAccount getServiceAccount (); Type: org.cdk8s.plus22.IServiceAccount The service account used to run this pod. podMetadata Required \u00b6 public ApiObjectMetadataDefinition getPodMetadata (); Type: org.cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. IResource \u00b6 Implemented By: org.cdk8s.plus22.ConfigMap , org.cdk8s.plus22.Deployment , org.cdk8s.plus22.Ingress , org.cdk8s.plus22.Job , org.cdk8s.plus22.Pod , org.cdk8s.plus22.Resource , org.cdk8s.plus22.Secret , org.cdk8s.plus22.Service , org.cdk8s.plus22.ServiceAccount , org.cdk8s.plus22.StatefulSet , org.cdk8s.plus22.IConfigMap , org.cdk8s.plus22.IResource , org.cdk8s.plus22.ISecret , org.cdk8s.plus22.IServiceAccount Represents a resource. Properties \u00b6 name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. ISecret \u00b6 Extends: org.cdk8s.plus22.IResource Implemented By: org.cdk8s.plus22.Secret , org.cdk8s.plus22.ISecret Properties \u00b6 name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. IServiceAccount \u00b6 Extends: org.cdk8s.plus22.IResource Implemented By: org.cdk8s.plus22.ServiceAccount , org.cdk8s.plus22.IServiceAccount Properties \u00b6 name Required \u00b6 public java . lang . String getName (); Type: java.lang.String The Kubernetes name of this resource. Enums \u00b6 EmptyDirMedium \u00b6 The medium on which to store the volume. DEFAULT \u00b6 The default volume of the backing node. MEMORY \u00b6 Mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. HttpIngressPathType \u00b6 Specify how the path is matched against request paths. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types PREFIX \u00b6 Matches the URL path exactly. EXACT \u00b6 Matches based on a URL path prefix split by \u2018/\u2019. IMPLEMENTATION_SPECIFIC \u00b6 Matching is specified by the underlying IngressClass. ImagePullPolicy \u00b6 ALWAYS \u00b6 Every time the kubelet launches a container, the kubelet queries the container image registry to resolve the name to an image digest. If the kubelet has a container image with that exact digest cached locally, the kubelet uses its cached image; otherwise, the kubelet downloads (pulls) the image with the resolved digest, and uses that image to launch the container. Default is Always if ImagePullPolicy is omitted and either the image tag is :latest or the image tag is omitted. IF_NOT_PRESENT \u00b6 The image is pulled only if it is not already present locally. Default is IfNotPresent if ImagePullPolicy is omitted and the image tag is present but not :latest NEVER \u00b6 The image is assumed to exist locally. No attempt is made to pull the image. MountPropagation \u00b6 NONE \u00b6 This volume mount will not receive any subsequent mounts that are mounted to this volume or any of its subdirectories by the host. In similar fashion, no mounts created by the Container will be visible on the host. This is the default mode. This mode is equal to private mount propagation as described in the Linux kernel documentation HOST_TO_CONTAINER \u00b6 This volume mount will receive all subsequent mounts that are mounted to this volume or any of its subdirectories. In other words, if the host mounts anything inside the volume mount, the Container will see it mounted there. Similarly, if any Pod with Bidirectional mount propagation to the same volume mounts anything there, the Container with HostToContainer mount propagation will see it. This mode is equal to rslave mount propagation as described in the Linux kernel documentation BIDIRECTIONAL \u00b6 This volume mount behaves the same the HostToContainer mount. In addition, all volume mounts created by the Container will be propagated back to the host and to all Containers of all Pods that use the same volume A typical use case for this mode is a Pod with a FlexVolume or CSI driver or a Pod that needs to mount something on the host using a hostPath volume. This mode is equal to rshared mount propagation as described in the Linux kernel documentation Caution: Bidirectional mount propagation can be dangerous. It can damage the host operating system and therefore it is allowed only in privileged Containers. Familiarity with Linux kernel behavior is strongly recommended. In addition, any volume mounts created by Containers in Pods must be destroyed (unmounted) by the Containers on termination. PodManagementPolicy \u00b6 Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once. ORDERED_READY \u00b6 PARALLEL \u00b6 Protocol \u00b6 TCP \u00b6 UDP \u00b6 SCTP \u00b6 RestartPolicy \u00b6 Restart policy for all containers within the pod. ALWAYS \u00b6 Always restart the pod after it exits. ON_FAILURE \u00b6 Only restart if the pod exits with a non-zero exit code. NEVER \u00b6 Never restart the pod. ServiceType \u00b6 For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP. CLUSTER_IP \u00b6 Exposes the Service on a cluster-internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default ServiceType NODE_PORT \u00b6 Exposes the Service on each Node\u2019s IP at a static port (the NodePort). A ClusterIP Service, to which the NodePort Service routes, is automatically created. You\u2019ll be able to contact the NodePort Service, from outside the cluster, by requesting : . LOAD_BALANCER \u00b6 Exposes the Service externally using a cloud provider\u2019s load balancer. NodePort and ClusterIP Services, to which the external load balancer routes, are automatically created. EXTERNAL_NAME \u00b6 Maps the Service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value. No proxying of any kind is set up. Note: You need either kube-dns version 1.7 or CoreDNS version 0.0.8 or higher to use the ExternalName type.","title":"Java"},{"location":"reference/cdk8s-plus-22/java/#cdk8s-plus-22-java","text":"","title":"cdk8s-plus-22 (Java) "},{"location":"reference/cdk8s-plus-22/java/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s-plus-22/java/#configmap","text":"Implements: org.cdk8s.plus22.IConfigMap ConfigMap holds configuration data for pods to consume.","title":"ConfigMap "},{"location":"reference/cdk8s-plus-22/java/#deployment","text":"Implements: org.cdk8s.plus22.IPodTemplate A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below.","title":"Deployment "},{"location":"reference/cdk8s-plus-22/java/#use-case","text":"The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore.","title":"Use Case"},{"location":"reference/cdk8s-plus-22/java/#ingress","text":"Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.","title":"Ingress "},{"location":"reference/cdk8s-plus-22/java/#job","text":"Implements: org.cdk8s.plus22.IPodTemplate A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel.","title":"Job "},{"location":"reference/cdk8s-plus-22/java/#pod","text":"Implements: org.cdk8s.plus22.IPodSpec Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.","title":"Pod "},{"location":"reference/cdk8s-plus-22/java/#resource","text":"Implements: org.cdk8s.plus22.IResource Base class for all Kubernetes objects in stdk8s. Represents a single resource.","title":"Resource "},{"location":"reference/cdk8s-plus-22/java/#secret","text":"Implements: org.cdk8s.plus22.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret","title":"Secret "},{"location":"reference/cdk8s-plus-22/java/#service","text":"An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods.","title":"Service "},{"location":"reference/cdk8s-plus-22/java/#serviceaccount","text":"Implements: org.cdk8s.plus22.IServiceAccount A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account","title":"ServiceAccount "},{"location":"reference/cdk8s-plus-22/java/#statefulset","text":"Implements: org.cdk8s.plus22.IPodTemplate StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed.","title":"StatefulSet "},{"location":"reference/cdk8s-plus-22/java/#using-statefulsets","text":"StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates.","title":"Using StatefulSets"},{"location":"reference/cdk8s-plus-22/java/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s-plus-22/java/#adddeploymentoptions","text":"Options to add a deployment to a service.","title":"AddDeploymentOptions "},{"location":"reference/cdk8s-plus-22/java/#adddirectoryoptions","text":"Options for configmap.addDirectory() .","title":"AddDirectoryOptions "},{"location":"reference/cdk8s-plus-22/java/#commandprobeoptions","text":"Options for Probe.fromCommand() .","title":"CommandProbeOptions "},{"location":"reference/cdk8s-plus-22/java/#configmapprops","text":"Properties for initialization of ConfigMap .","title":"ConfigMapProps "},{"location":"reference/cdk8s-plus-22/java/#configmapvolumeoptions","text":"Options for the ConfigMap-based volume.","title":"ConfigMapVolumeOptions "},{"location":"reference/cdk8s-plus-22/java/#containerprops","text":"Properties for creating a container.","title":"ContainerProps "},{"location":"reference/cdk8s-plus-22/java/#deploymentprops","text":"Properties for initialization of Deployment .","title":"DeploymentProps "},{"location":"reference/cdk8s-plus-22/java/#emptydirvolumeoptions","text":"Options for volumes populated with an empty directory.","title":"EmptyDirVolumeOptions "},{"location":"reference/cdk8s-plus-22/java/#envvaluefromconfigmapoptions","text":"Options to specify an envionment variable value from a ConfigMap key.","title":"EnvValueFromConfigMapOptions "},{"location":"reference/cdk8s-plus-22/java/#envvaluefromprocessoptions","text":"Options to specify an environment variable value from the process environment.","title":"EnvValueFromProcessOptions "},{"location":"reference/cdk8s-plus-22/java/#envvaluefromsecretoptions","text":"Options to specify an environment variable value from a Secret.","title":"EnvValueFromSecretOptions "},{"location":"reference/cdk8s-plus-22/java/#exposedeploymentviaingressoptions","text":"Options for exposing a deployment via an ingress.","title":"ExposeDeploymentViaIngressOptions "},{"location":"reference/cdk8s-plus-22/java/#exposedeploymentviaserviceoptions","text":"Options for exposing a deployment via a service.","title":"ExposeDeploymentViaServiceOptions "},{"location":"reference/cdk8s-plus-22/java/#exposeserviceviaingressoptions","text":"Options for exposing a service using an ingress.","title":"ExposeServiceViaIngressOptions "},{"location":"reference/cdk8s-plus-22/java/#httpgetprobeoptions","text":"Options for Probe.fromHttpGet() .","title":"HttpGetProbeOptions "},{"location":"reference/cdk8s-plus-22/java/#ingressprops","text":"Properties for Ingress .","title":"IngressProps "},{"location":"reference/cdk8s-plus-22/java/#ingressrule","text":"Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path.","title":"IngressRule "},{"location":"reference/cdk8s-plus-22/java/#ingresstls","text":"Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination.","title":"IngressTls "},{"location":"reference/cdk8s-plus-22/java/#jobprops","text":"Properties for initialization of Job .","title":"JobProps "},{"location":"reference/cdk8s-plus-22/java/#mountoptions","text":"Options for mounts.","title":"MountOptions "},{"location":"reference/cdk8s-plus-22/java/#pathmapping","text":"Maps a string key to a path within a volume.","title":"PathMapping "},{"location":"reference/cdk8s-plus-22/java/#podprops","text":"Properties for initialization of Pod .","title":"PodProps "},{"location":"reference/cdk8s-plus-22/java/#podspecprops","text":"Properties of a PodSpec .","title":"PodSpecProps "},{"location":"reference/cdk8s-plus-22/java/#podtemplateprops","text":"Properties of a PodTemplate . Adds metadata information on top of the spec.","title":"PodTemplateProps "},{"location":"reference/cdk8s-plus-22/java/#probeoptions","text":"Probe options.","title":"ProbeOptions "},{"location":"reference/cdk8s-plus-22/java/#resourceprops","text":"Initialization properties for resources.","title":"ResourceProps "},{"location":"reference/cdk8s-plus-22/java/#secretprops","text":"","title":"SecretProps "},{"location":"reference/cdk8s-plus-22/java/#secretvalue","text":"Represents a specific value in JSON secret.","title":"SecretValue "},{"location":"reference/cdk8s-plus-22/java/#serviceaccountprops","text":"Properties for initialization of ServiceAccount . Properties for initialization of ServiceAccount .","title":"ServiceAccountProps "},{"location":"reference/cdk8s-plus-22/java/#serviceingressbackendoptions","text":"Options for setting up backends for ingress rules.","title":"ServiceIngressBackendOptions "},{"location":"reference/cdk8s-plus-22/java/#serviceport","text":"Definition of a service port.","title":"ServicePort "},{"location":"reference/cdk8s-plus-22/java/#serviceportoptions","text":"","title":"ServicePortOptions "},{"location":"reference/cdk8s-plus-22/java/#serviceprops","text":"Properties for initialization of Service .","title":"ServiceProps "},{"location":"reference/cdk8s-plus-22/java/#statefulsetprops","text":"Properties for initialization of StatefulSet .","title":"StatefulSetProps "},{"location":"reference/cdk8s-plus-22/java/#volumemount","text":"Mount a volume from the pod to the container.","title":"VolumeMount "},{"location":"reference/cdk8s-plus-22/java/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s-plus-22/java/#container","text":"A single application container that you want to run within a pod.","title":"Container "},{"location":"reference/cdk8s-plus-22/java/#envvalue","text":"Utility class for creating reading env values from various sources.","title":"EnvValue "},{"location":"reference/cdk8s-plus-22/java/#ingressbackend","text":"The backend for an ingress path.","title":"IngressBackend "},{"location":"reference/cdk8s-plus-22/java/#podspec","text":"Implements: org.cdk8s.plus22.IPodSpec Provides read/write capabilities ontop of a PodSpecProps .","title":"PodSpec "},{"location":"reference/cdk8s-plus-22/java/#podtemplate","text":"Implements: org.cdk8s.plus22.IPodTemplate Provides read/write capabilities ontop of a PodTemplateProps .","title":"PodTemplate "},{"location":"reference/cdk8s-plus-22/java/#probe","text":"Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.","title":"Probe "},{"location":"reference/cdk8s-plus-22/java/#volume","text":"Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes","title":"Volume "},{"location":"reference/cdk8s-plus-22/java/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s-plus-22/java/#iconfigmap","text":"Extends: org.cdk8s.plus22.IResource Implemented By: org.cdk8s.plus22.ConfigMap , org.cdk8s.plus22.IConfigMap Represents a config map.","title":"IConfigMap "},{"location":"reference/cdk8s-plus-22/java/#ipodspec","text":"Implemented By: org.cdk8s.plus22.Deployment , org.cdk8s.plus22.Job , org.cdk8s.plus22.Pod , org.cdk8s.plus22.PodSpec , org.cdk8s.plus22.PodTemplate , org.cdk8s.plus22.StatefulSet , org.cdk8s.plus22.IPodSpec , org.cdk8s.plus22.IPodTemplate Represents a resource that can be configured with a kuberenets pod spec. (e.g Deployment , Job , Pod , \u2026). Use the PodSpec class as an implementation helper.","title":"IPodSpec "},{"location":"reference/cdk8s-plus-22/java/#ipodtemplate","text":"Extends: org.cdk8s.plus22.IPodSpec Implemented By: org.cdk8s.plus22.Deployment , org.cdk8s.plus22.Job , org.cdk8s.plus22.PodTemplate , org.cdk8s.plus22.StatefulSet , org.cdk8s.plus22.IPodTemplate Represents a resource that can be configured with a kuberenets pod template. (e.g Deployment , Job , \u2026). Use the PodTemplate class as an implementation helper.","title":"IPodTemplate "},{"location":"reference/cdk8s-plus-22/java/#iresource","text":"Implemented By: org.cdk8s.plus22.ConfigMap , org.cdk8s.plus22.Deployment , org.cdk8s.plus22.Ingress , org.cdk8s.plus22.Job , org.cdk8s.plus22.Pod , org.cdk8s.plus22.Resource , org.cdk8s.plus22.Secret , org.cdk8s.plus22.Service , org.cdk8s.plus22.ServiceAccount , org.cdk8s.plus22.StatefulSet , org.cdk8s.plus22.IConfigMap , org.cdk8s.plus22.IResource , org.cdk8s.plus22.ISecret , org.cdk8s.plus22.IServiceAccount Represents a resource.","title":"IResource "},{"location":"reference/cdk8s-plus-22/java/#isecret","text":"Extends: org.cdk8s.plus22.IResource Implemented By: org.cdk8s.plus22.Secret , org.cdk8s.plus22.ISecret","title":"ISecret "},{"location":"reference/cdk8s-plus-22/java/#iserviceaccount","text":"Extends: org.cdk8s.plus22.IResource Implemented By: org.cdk8s.plus22.ServiceAccount , org.cdk8s.plus22.IServiceAccount","title":"IServiceAccount "},{"location":"reference/cdk8s-plus-22/java/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s-plus-22/java/#emptydirmedium","text":"The medium on which to store the volume.","title":"EmptyDirMedium "},{"location":"reference/cdk8s-plus-22/java/#httpingresspathtype","text":"Specify how the path is matched against request paths. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types","title":"HttpIngressPathType "},{"location":"reference/cdk8s-plus-22/java/#imagepullpolicy","text":"","title":"ImagePullPolicy "},{"location":"reference/cdk8s-plus-22/java/#mountpropagation","text":"","title":"MountPropagation "},{"location":"reference/cdk8s-plus-22/java/#podmanagementpolicy","text":"Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.","title":"PodManagementPolicy "},{"location":"reference/cdk8s-plus-22/java/#protocol","text":"","title":"Protocol "},{"location":"reference/cdk8s-plus-22/java/#restartpolicy","text":"Restart policy for all containers within the pod.","title":"RestartPolicy "},{"location":"reference/cdk8s-plus-22/java/#servicetype","text":"For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP.","title":"ServiceType "},{"location":"reference/cdk8s-plus-22/python/","text":"cdk8s-plus-22 (Python) \u00b6 Constructs \u00b6 ConfigMap \u00b6 Implements: cdk8s_plus_22.IConfigMap ConfigMap holds configuration data for pods to consume. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ConfigMap ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , binary_data : typing . Mapping [ str ] = None , data : typing . Mapping [ str ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binary_data Optional \u00b6 Type: typing.Mapping[ str ] BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. Using this field will require 1.10+ apiserver and kubelet. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 Type: typing.Mapping[ str ] Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . Methods \u00b6 add_binary_data \u00b6 def add_binary_data ( key : str , value : str ) key Required \u00b6 Type: str The key. value Required \u00b6 Type: str The value. add_data \u00b6 def add_data ( key : str , value : str ) key Required \u00b6 Type: str The key. value Required \u00b6 Type: str The value. add_directory \u00b6 def add_directory ( local_dir : str , exclude : typing . List [ str ] = None , key_prefix : str = None ) local_dir Required \u00b6 Type: str A path to a local directory. exclude Optional \u00b6 Type: typing.List[ str ] Default: include all files Glob patterns to exclude when adding files. key_prefix Optional \u00b6 Type: str Default: \u201c\u201d A prefix to add to all keys in the config map. add_file \u00b6 def add_file ( local_file : str , key : str = None ) local_file Required \u00b6 Type: str The path to the local file. key Optional \u00b6 Type: str The ConfigMap key (default to the file name). Static Functions \u00b6 from_config_map_name \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ConfigMap . from_config_map_name ( name : str ) name Required \u00b6 Type: str The name of the config map to import. Properties \u00b6 binary_data Required \u00b6 binary_data : typing . Mapping [ str ] Type: typing.Mapping[ str ] The binary data associated with this config map. Returns a copy. To add data records, use addBinaryData() or addData() . data Required \u00b6 data : typing . Mapping [ str ] Type: typing.Mapping[ str ] The data associated with this config map. Returns an copy. To add data records, use addData() or addBinaryData() . Deployment \u00b6 Implements: cdk8s_plus_22.IPodTemplate A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case \u00b6 The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Deployment ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , default_selector : bool = None , replicas : typing . Union [ int , float ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata. default_selector Optional \u00b6 Type: bool Default: true Automatically allocates a pod selector for this deployment. If this is set to false you must define your selector through deployment.podMetadata.addLabel() and deployment.selectByLabel() . replicas Optional \u00b6 Type: typing.Union[int, float] Default: 1 Number of desired pods. Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_22.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_22.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_22.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_22.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_22.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_22.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( volume : Volume ) volume Required \u00b6 Type: cdk8s_plus_22.Volume expose_via_ingress \u00b6 def expose_via_ingress ( path : str , name : str = None , port : typing . Union [ int , float ] = None , protocol : Protocol = None , service_type : ServiceType = None , target_port : typing . Union [ int , float ] = None , ingress : Ingress = None , path_type : HttpIngressPathType = None ) path Required \u00b6 Type: str The ingress path to register under. name Optional \u00b6 Type: str Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 Type: typing.Union[int, float] Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 Type: cdk8s_plus_22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. service_type Optional \u00b6 Type: cdk8s_plus_22.ServiceType Default: ClusterIP. The type of the exposed service. target_port Optional \u00b6 Type: typing.Union[int, float] Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ingress Optional \u00b6 Type: cdk8s_plus_22.Ingress Default: An ingress will be automatically created. The ingress to add rules to. path_type Optional \u00b6 Type: cdk8s_plus_22.HttpIngressPathType Default: HttpIngressPathType.PREFIX The type of the path. expose_via_service \u00b6 def expose_via_service ( name : str = None , port : typing . Union [ int , float ] = None , protocol : Protocol = None , service_type : ServiceType = None , target_port : typing . Union [ int , float ] = None ) name Optional \u00b6 Type: str Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 Type: typing.Union[int, float] Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 Type: cdk8s_plus_22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. service_type Optional \u00b6 Type: cdk8s_plus_22.ServiceType Default: ClusterIP. The type of the exposed service. target_port Optional \u00b6 Type: typing.Union[int, float] Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. select_by_label \u00b6 def select_by_label ( key : str , value : str ) key Required \u00b6 Type: str The label key. value Required \u00b6 Type: str The label value. Properties \u00b6 containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_22.Container ] The containers belonging to the pod. Use addContainer to add containers. label_selector Required \u00b6 label_selector : typing . Mapping [ str ] Type: typing.Mapping[ str ] The labels this deployment will match against in order to select pods. Returns a a copy. Use selectByLabel() to add labels. pod_metadata Required \u00b6 pod_metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. replicas Required \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Number of desired pods. volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_22.Volume ] The volumes associated with this pod. Use addVolume to add volumes. restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_22.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_22.IServiceAccount The service account used to run this pod. Ingress \u00b6 Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Ingress ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , default_backend : IngressBackend = None , rules : typing . List [ IngressRule ] = None , tls : typing . List [ IngressTls ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. default_backend Optional \u00b6 Type: cdk8s_plus_22.IngressBackend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 Type: typing.List[ cdk8s_plus_22.IngressRule ] Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 Type: typing.List[ cdk8s_plus_22.IngressTls ] TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. Methods \u00b6 add_default_backend \u00b6 def add_default_backend ( backend : IngressBackend ) backend Required \u00b6 Type: cdk8s_plus_22.IngressBackend The backend to use for requests that do not match any rule. add_host_default_backend \u00b6 def add_host_default_backend ( host : str , backend : IngressBackend ) host Required \u00b6 Type: str The host name to match. backend Required \u00b6 Type: cdk8s_plus_22.IngressBackend The backend to route to. add_host_rule \u00b6 def add_host_rule ( host : str , path : str , backend : IngressBackend , path_type : HttpIngressPathType = None ) host Required \u00b6 Type: str The host name. path Required \u00b6 Type: str The HTTP path. backend Required \u00b6 Type: cdk8s_plus_22.IngressBackend The backend to route requests to. path_type Optional \u00b6 Type: cdk8s_plus_22.HttpIngressPathType How the path is matched against request paths. add_rule \u00b6 def add_rule ( path : str , backend : IngressBackend , path_type : HttpIngressPathType = None ) path Required \u00b6 Type: str The HTTP path. backend Required \u00b6 Type: cdk8s_plus_22.IngressBackend The backend to route requests to. path_type Optional \u00b6 Type: cdk8s_plus_22.HttpIngressPathType How the path is matched against request paths. add_rules \u00b6 def add_rules ( backend : IngressBackend , host : str = None , path : str = None , path_type : HttpIngressPathType = None ) backend Required \u00b6 Type: cdk8s_plus_22.IngressBackend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 Type: str Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 Type: str Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. path_type Optional \u00b6 Type: cdk8s_plus_22.HttpIngressPathType Specify how the path is matched against request paths. By default, path types will be matched by prefix. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types add_tls \u00b6 def add_tls ( tls : typing . List [ IngressTls ] ) tls Required \u00b6 Type: typing.List[ cdk8s_plus_22.IngressTls ] Job \u00b6 Implements: cdk8s_plus_22.IPodTemplate A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Job ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , active_deadline : Duration = None , backoff_limit : typing . Union [ int , float ] = None , ttl_after_finished : Duration = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata. active_deadline Optional \u00b6 Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoff_limit Optional \u00b6 Type: typing.Union[int, float] Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttl_after_finished Optional \u00b6 Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_22.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_22.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_22.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_22.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_22.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_22.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( volume : Volume ) volume Required \u00b6 Type: cdk8s_plus_22.Volume Properties \u00b6 containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_22.Container ] The containers belonging to the pod. Use addContainer to add containers. pod_metadata Required \u00b6 pod_metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_22.Volume ] The volumes associated with this pod. Use addVolume to add volumes. active_deadline Optional \u00b6 active_deadline : Duration Type: cdk8s.Duration Duration before job is terminated. If undefined, there is no deadline. backoff_limit Optional \u00b6 backoff_limit : typing . Union [ int , float ] Type: typing.Union[int, float] Number of retries before marking failed. restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_22.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_22.IServiceAccount The service account used to run this pod. ttl_after_finished Optional \u00b6 ttl_after_finished : Duration Type: cdk8s.Duration TTL before the job is deleted after it is finished. Pod \u00b6 Implements: cdk8s_plus_22.IPodSpec Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Pod ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_22.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_22.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_22.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_22.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_22.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_22.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( volume : Volume ) volume Required \u00b6 Type: cdk8s_plus_22.Volume Properties \u00b6 containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_22.Container ] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_22.Volume ] The volumes associated with this pod. Use addVolume to add volumes. restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_22.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_22.IServiceAccount The service account used to run this pod. Resource \u00b6 Implements: cdk8s_plus_22.IResource Base class for all Kubernetes objects in stdk8s. Represents a single resource. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Resource ( scope : Construct , id : str , node_factory : INodeFactory = None ) scope Required \u00b6 Type: constructs.Construct The scope in which to define this construct. id Required \u00b6 Type: str The scoped construct ID. Must be unique amongst siblings. If the ID includes a path separator ( / ), then it will be replaced by double dash -- . node_factory Optional \u00b6 Type: constructs.INodeFactory Default: the default Node is associated A factory for attaching Node s to the construct. Properties \u00b6 metadata Required \u00b6 metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition name Required \u00b6 name : str Type: str The name of this API object. Secret \u00b6 Implements: cdk8s_plus_22.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Secret ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , string_data : typing . Mapping [ str ] = None , type : str = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. string_data Optional \u00b6 Type: typing.Mapping[ str ] stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 Type: str Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. Methods \u00b6 add_string_data \u00b6 def add_string_data ( key : str , value : str ) key Required \u00b6 Type: str Key. value Required \u00b6 Type: str Value. get_string_data \u00b6 def get_string_data ( key : str ) key Required \u00b6 Type: str Key. Static Functions \u00b6 from_secret_name \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Secret . from_secret_name ( name : str ) name Required \u00b6 Type: str The name of the secret to reference. Service \u00b6 An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Service ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , cluster_i_p : str = None , external_i_ps : typing . List [ str ] = None , external_name : str = None , load_balancer_source_ranges : typing . List [ str ] = None , ports : typing . List [ ServicePort ] = None , type : ServiceType = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. cluster_i_p Optional \u00b6 Type: str Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies external_i_ps Optional \u00b6 Type: typing.List[ str ] Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. external_name Optional \u00b6 Type: str Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. load_balancer_source_ranges Optional \u00b6 Type: typing.List[ str ] A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ServicePort ] The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 Type: cdk8s_plus_22.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types Methods \u00b6 add_deployment \u00b6 def add_deployment ( deployment : Deployment , name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None , port : typing . Union [ int , float ] = None ) deployment Required \u00b6 Type: cdk8s_plus_22.Deployment The deployment to expose. name Optional \u00b6 Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 Type: cdk8s_plus_22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. port Optional \u00b6 Type: typing.Union[int, float] Default: Copied from the first container of the deployment. The port number the service will bind to. add_selector \u00b6 def add_selector ( label : str , value : str ) label Required \u00b6 Type: str The label key. value Required \u00b6 Type: str The label value. expose_via_ingress \u00b6 def expose_via_ingress ( path : str , ingress : Ingress = None , path_type : HttpIngressPathType = None ) path Required \u00b6 Type: str The path to expose the service under. ingress Optional \u00b6 Type: cdk8s_plus_22.Ingress Default: An ingress will be automatically created. The ingress to add rules to. path_type Optional \u00b6 Type: cdk8s_plus_22.HttpIngressPathType Default: HttpIngressPathType.PREFIX The type of the path. serve \u00b6 def serve ( port : typing . Union [ int , float ], name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None ) port Required \u00b6 Type: typing.Union[int, float] The port definition. name Optional \u00b6 Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 Type: cdk8s_plus_22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. Properties \u00b6 ports Required \u00b6 ports : typing . List [ ServicePort ] Type: typing.List[ cdk8s_plus_22.ServicePort ] Ports for this service. Use serve() to expose additional service ports. selector Required \u00b6 selector : typing . Mapping [ str ] Type: typing.Mapping[ str ] Returns the labels which are used to select pods for this service. type Required \u00b6 type : ServiceType Type: cdk8s_plus_22.ServiceType Determines how the Service is exposed. cluster_i_p Optional \u00b6 cluster_i_p : str Type: str The IP address of the service and is usually assigned randomly by the master. external_name Optional \u00b6 external_name : str Type: str The externalName to be used for EXTERNAL_NAME types. ServiceAccount \u00b6 Implements: cdk8s_plus_22.IServiceAccount A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ServiceAccount ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , secrets : typing . List [ ISecret ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. secrets Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ISecret ] List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret Methods \u00b6 add_secret \u00b6 def add_secret ( secret : ISecret ) secret Required \u00b6 Type: cdk8s_plus_22.ISecret The secret. Static Functions \u00b6 from_service_account_name \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ServiceAccount . from_service_account_name ( name : str ) name Required \u00b6 Type: str The name of the service account resource. Properties \u00b6 secrets Required \u00b6 secrets : typing . List [ ISecret ] Type: typing.List[ cdk8s_plus_22.ISecret ] List of secrets allowed to be used by pods running using this service account. Returns a copy. To add a secret, use addSecret() . StatefulSet \u00b6 Implements: cdk8s_plus_22.IPodTemplate StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed. Using StatefulSets \u00b6 StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . StatefulSet ( scope : Construct , id : str , metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , service : Service , default_selector : bool = None , pod_management_policy : PodManagementPolicy = None , replicas : typing . Union [ int , float ] = None ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: str metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata. service Required \u00b6 Type: cdk8s_plus_22.Service Service to associate with the statefulset. default_selector Optional \u00b6 Type: bool Default: true Automatically allocates a pod selector for this statefulset. If this is set to false you must define your selector through statefulset.podMetadata.addLabel() and statefulset.selectByLabel() . pod_management_policy Optional \u00b6 Type: cdk8s_plus_22.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 Type: typing.Union[int, float] Default: 1 Number of desired pods. Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_22.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_22.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_22.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_22.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_22.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_22.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( volume : Volume ) volume Required \u00b6 Type: cdk8s_plus_22.Volume select_by_label \u00b6 def select_by_label ( key : str , value : str ) key Required \u00b6 Type: str The label key. value Required \u00b6 Type: str The label value. Properties \u00b6 containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_22.Container ] The containers belonging to the pod. Use addContainer to add containers. label_selector Required \u00b6 label_selector : typing . Mapping [ str ] Type: typing.Mapping[ str ] The labels this statefulset will match against in order to select pods. Returns a a copy. Use selectByLabel() to add labels. pod_management_policy Required \u00b6 pod_management_policy : PodManagementPolicy Type: cdk8s_plus_22.PodManagementPolicy Management policy to use for the set. pod_metadata Required \u00b6 pod_metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. replicas Required \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Number of desired pods. volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_22.Volume ] The volumes associated with this pod. Use addVolume to add volumes. restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_22.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_22.IServiceAccount The service account used to run this pod. Structs \u00b6 AddDeploymentOptions \u00b6 Options to add a deployment to a service. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . AddDeploymentOptions ( name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None , port : typing . Union [ int , float ] = None ) name Optional \u00b6 name : str Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 node_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: Copied from the first container of the deployment. The port number the service will bind to. AddDirectoryOptions \u00b6 Options for configmap.addDirectory() . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . AddDirectoryOptions ( exclude : typing . List [ str ] = None , key_prefix : str = None ) exclude Optional \u00b6 exclude : typing . List [ str ] Type: typing.List[ str ] Default: include all files Glob patterns to exclude when adding files. key_prefix Optional \u00b6 key_prefix : str Type: str Default: \u201c\u201d A prefix to add to all keys in the config map. CommandProbeOptions \u00b6 Options for Probe.fromCommand() . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . CommandProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None ) failure_threshold Optional \u00b6 failure_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 initial_delay_seconds : Duration Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 period_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 success_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 timeout_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ConfigMapProps \u00b6 Properties for initialization of ConfigMap . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ConfigMapProps ( metadata : ApiObjectMetadata = None , binary_data : typing . Mapping [ str ] = None , data : typing . Mapping [ str ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binary_data Optional \u00b6 binary_data : typing . Mapping [ str ] Type: typing.Mapping[ str ] BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. Using this field will require 1.10+ apiserver and kubelet. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 data : typing . Mapping [ str ] Type: typing.Mapping[ str ] Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . ConfigMapVolumeOptions \u00b6 Options for the ConfigMap-based volume. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ConfigMapVolumeOptions ( default_mode : typing . Union [ int , float ] = None , items : typing . Mapping [ PathMapping ] = None , name : str = None , optional : bool = None ) default_mode Optional \u00b6 default_mode : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 items : typing . Mapping [ PathMapping ] Type: typing.Mapping[ cdk8s_plus_22.PathMapping ] Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 name : str Type: str Default: auto-generated The volume name. optional Optional \u00b6 optional : bool Type: bool Default: undocumented Specify whether the ConfigMap or its keys must be defined. ContainerProps \u00b6 Properties for creating a container. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ContainerProps ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 image : str Type: str Docker image name. args Optional \u00b6 args : typing . List [ str ] Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 command : typing . List [ str ] Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 env : typing . Mapping [ EnvValue ] Type: typing.Mapping[ cdk8s_plus_22.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 image_pull_policy : ImagePullPolicy Type: cdk8s_plus_22.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 liveness : Probe Type: cdk8s_plus_22.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 name : str Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 readiness : Probe Type: cdk8s_plus_22.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 startup : Probe Type: cdk8s_plus_22.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 volume_mounts : typing . List [ VolumeMount ] Type: typing.List[ cdk8s_plus_22.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 working_dir : str Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. DeploymentProps \u00b6 Properties for initialization of Deployment . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . DeploymentProps ( metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , default_selector : bool = None , replicas : typing . Union [ int , float ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata. default_selector Optional \u00b6 default_selector : bool Type: bool Default: true Automatically allocates a pod selector for this deployment. If this is set to false you must define your selector through deployment.podMetadata.addLabel() and deployment.selectByLabel() . replicas Optional \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Number of desired pods. EmptyDirVolumeOptions \u00b6 Options for volumes populated with an empty directory. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . EmptyDirVolumeOptions ( medium : EmptyDirMedium = None , size_limit : Size = None ) medium Optional \u00b6 medium : EmptyDirMedium Type: cdk8s_plus_22.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. size_limit Optional \u00b6 size_limit : Size Type: cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. EnvValueFromConfigMapOptions \u00b6 Options to specify an envionment variable value from a ConfigMap key. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . EnvValueFromConfigMapOptions ( optional : bool = None ) optional Optional \u00b6 optional : bool Type: bool Default: false Specify whether the ConfigMap or its key must be defined. EnvValueFromProcessOptions \u00b6 Options to specify an environment variable value from the process environment. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . EnvValueFromProcessOptions ( required : bool = None ) required Optional \u00b6 required : bool Type: bool Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. EnvValueFromSecretOptions \u00b6 Options to specify an environment variable value from a Secret. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . EnvValueFromSecretOptions ( optional : bool = None ) optional Optional \u00b6 optional : bool Type: bool Default: false Specify whether the Secret or its key must be defined. ExposeDeploymentViaIngressOptions \u00b6 Options for exposing a deployment via an ingress. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ExposeDeploymentViaIngressOptions ( name : str = None , port : typing . Union [ int , float ] = None , protocol : Protocol = None , service_type : ServiceType = None , target_port : typing . Union [ int , float ] = None , ingress : Ingress = None , path_type : HttpIngressPathType = None ) name Optional \u00b6 name : str Type: str Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. service_type Optional \u00b6 service_type : ServiceType Type: cdk8s_plus_22.ServiceType Default: ClusterIP. The type of the exposed service. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ingress Optional \u00b6 ingress : Ingress Type: cdk8s_plus_22.Ingress Default: An ingress will be automatically created. The ingress to add rules to. path_type Optional \u00b6 path_type : HttpIngressPathType Type: cdk8s_plus_22.HttpIngressPathType Default: HttpIngressPathType.PREFIX The type of the path. ExposeDeploymentViaServiceOptions \u00b6 Options for exposing a deployment via a service. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ExposeDeploymentViaServiceOptions ( name : str = None , port : typing . Union [ int , float ] = None , protocol : Protocol = None , service_type : ServiceType = None , target_port : typing . Union [ int , float ] = None ) name Optional \u00b6 name : str Type: str Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. service_type Optional \u00b6 service_type : ServiceType Type: cdk8s_plus_22.ServiceType Default: ClusterIP. The type of the exposed service. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ExposeServiceViaIngressOptions \u00b6 Options for exposing a service using an ingress. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ExposeServiceViaIngressOptions ( ingress : Ingress = None , path_type : HttpIngressPathType = None ) ingress Optional \u00b6 ingress : Ingress Type: cdk8s_plus_22.Ingress Default: An ingress will be automatically created. The ingress to add rules to. path_type Optional \u00b6 path_type : HttpIngressPathType Type: cdk8s_plus_22.HttpIngressPathType Default: HttpIngressPathType.PREFIX The type of the path. HttpGetProbeOptions \u00b6 Options for Probe.fromHttpGet() . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . HttpGetProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None , port : typing . Union [ int , float ] = None ) failure_threshold Optional \u00b6 failure_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 initial_delay_seconds : Duration Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 period_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 success_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 timeout_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to use when sending the GET request. IngressProps \u00b6 Properties for Ingress . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . IngressProps ( metadata : ApiObjectMetadata = None , default_backend : IngressBackend = None , rules : typing . List [ IngressRule ] = None , tls : typing . List [ IngressTls ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. default_backend Optional \u00b6 default_backend : IngressBackend Type: cdk8s_plus_22.IngressBackend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 rules : typing . List [ IngressRule ] Type: typing.List[ cdk8s_plus_22.IngressRule ] Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 tls : typing . List [ IngressTls ] Type: typing.List[ cdk8s_plus_22.IngressTls ] TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. IngressRule \u00b6 Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . IngressRule ( backend : IngressBackend , host : str = None , path : str = None , path_type : HttpIngressPathType = None ) backend Required \u00b6 backend : IngressBackend Type: cdk8s_plus_22.IngressBackend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 host : str Type: str Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 path : str Type: str Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. path_type Optional \u00b6 path_type : HttpIngressPathType Type: cdk8s_plus_22.HttpIngressPathType Specify how the path is matched against request paths. By default, path types will be matched by prefix. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types IngressTls \u00b6 Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . IngressTls ( hosts : typing . List [ str ] = None , secret : ISecret = None ) hosts Optional \u00b6 hosts : typing . List [ str ] Type: typing.List[ str ] Default: If unspecified, it defaults to the wildcard host setting for the loadbalancer controller fulfilling this Ingress. Hosts are a list of hosts included in the TLS certificate. The values in this list must match the name/s used in the TLS Secret. secret Optional \u00b6 secret : ISecret Type: cdk8s_plus_22.ISecret Default: If unspecified, it allows SSL routing based on SNI hostname. Secret is the secret that contains the certificate and key used to terminate SSL traffic on 443. If the SNI host in a listener conflicts with the \u201cHost\u201d header field used by an IngressRule, the SNI host is used for termination and value of the Host header is used for routing. JobProps \u00b6 Properties for initialization of Job . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . JobProps ( metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , active_deadline : Duration = None , backoff_limit : typing . Union [ int , float ] = None , ttl_after_finished : Duration = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata. active_deadline Optional \u00b6 active_deadline : Duration Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoff_limit Optional \u00b6 backoff_limit : typing . Union [ int , float ] Type: typing.Union[int, float] Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttl_after_finished Optional \u00b6 ttl_after_finished : Duration Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. MountOptions \u00b6 Options for mounts. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . MountOptions ( propagation : MountPropagation = None , read_only : bool = None , sub_path : str = None , sub_path_expr : str = None ) propagation Optional \u00b6 propagation : MountPropagation Type: cdk8s_plus_22.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. This field is beta in 1.10. read_only Optional \u00b6 read_only : bool Type: bool Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. sub_path Optional \u00b6 sub_path : str Type: str Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). sub_path_expr Optional \u00b6 sub_path_expr : str Type: str Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). SubPathExpr and SubPath are mutually exclusive. This field is beta in 1.15. subPathExpr and subPath are mutually exclusive. This field is beta in 1.15. PathMapping \u00b6 Maps a string key to a path within a volume. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PathMapping ( path : str , mode : typing . Union [ int , float ] = None ) path Required \u00b6 path : str Type: str The relative path of the file to map the key to. May not be an absolute path. May not contain the path element \u2018..\u2019. May not start with the string \u2018..\u2019. mode Optional \u00b6 mode : typing . Union [ int , float ] Type: typing.Union[int, float] Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. PodProps \u00b6 Properties for initialization of Pod . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PodProps ( metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodSpecProps \u00b6 Properties of a PodSpec . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PodSpecProps ( containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodTemplateProps \u00b6 Properties of a PodTemplate . Adds metadata information on top of the spec. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PodTemplateProps ( containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None ) containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata. ProbeOptions \u00b6 Probe options. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ProbeOptions ( failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None ) failure_threshold Optional \u00b6 failure_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 initial_delay_seconds : Duration Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 period_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 success_threshold : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 timeout_seconds : Duration Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ResourceProps \u00b6 Initialization properties for resources. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ResourceProps ( metadata : ApiObjectMetadata = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. SecretProps \u00b6 Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . SecretProps ( metadata : ApiObjectMetadata = None , string_data : typing . Mapping [ str ] = None , type : str = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. string_data Optional \u00b6 string_data : typing . Mapping [ str ] Type: typing.Mapping[ str ] stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 type : str Type: str Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. SecretValue \u00b6 Represents a specific value in JSON secret. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . SecretValue ( key : str , secret : ISecret ) key Required \u00b6 key : str Type: str The JSON key. secret Required \u00b6 secret : ISecret Type: cdk8s_plus_22.ISecret The secret. ServiceAccountProps \u00b6 Properties for initialization of ServiceAccount . Properties for initialization of ServiceAccount . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ServiceAccountProps ( metadata : ApiObjectMetadata = None , secrets : typing . List [ ISecret ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. secrets Optional \u00b6 secrets : typing . List [ ISecret ] Type: typing.List[ cdk8s_plus_22.ISecret ] List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret ServiceIngressBackendOptions \u00b6 Options for setting up backends for ingress rules. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ServiceIngressBackendOptions ( port : typing . Union [ int , float ] = None ) port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. If the service exposes multiple ports, this option must be specified. If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. ServicePort \u00b6 Definition of a service port. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ServicePort ( name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None , port : typing . Union [ int , float ] ) name Optional \u00b6 name : str Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 node_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. port Required \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] The port number the service will bind to. ServicePortOptions \u00b6 Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ServicePortOptions ( name : str = None , node_port : typing . Union [ int , float ] = None , protocol : Protocol = None , target_port : typing . Union [ int , float ] = None ) name Optional \u00b6 name : str Type: str The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. node_port Optional \u00b6 node_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 protocol : Protocol Type: cdk8s_plus_22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. target_port Optional \u00b6 target_port : typing . Union [ int , float ] Type: typing.Union[int, float] Default: The value of port will be used. The port number the service will redirect to. ServiceProps \u00b6 Properties for initialization of Service . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . ServiceProps ( metadata : ApiObjectMetadata = None , cluster_i_p : str = None , external_i_ps : typing . List [ str ] = None , external_name : str = None , load_balancer_source_ranges : typing . List [ str ] = None , ports : typing . List [ ServicePort ] = None , type : ServiceType = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. cluster_i_p Optional \u00b6 cluster_i_p : str Type: str Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies external_i_ps Optional \u00b6 external_i_ps : typing . List [ str ] Type: typing.List[ str ] Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. external_name Optional \u00b6 external_name : str Type: str Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. load_balancer_source_ranges Optional \u00b6 load_balancer_source_ranges : typing . List [ str ] Type: typing.List[ str ] A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 ports : typing . List [ ServicePort ] Type: typing.List[ cdk8s_plus_22.ServicePort ] The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 type : ServiceType Type: cdk8s_plus_22.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types StatefulSetProps \u00b6 Properties for initialization of StatefulSet . Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . StatefulSetProps ( metadata : ApiObjectMetadata = None , containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None , service : Service , default_selector : bool = None , pod_management_policy : PodManagementPolicy = None , replicas : typing . Union [ int , float ] = None ) metadata Optional \u00b6 metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 containers : typing . List [ ContainerProps ] Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 pod_metadata : ApiObjectMetadata Type: cdk8s.ApiObjectMetadata The pod metadata. service Required \u00b6 service : Service Type: cdk8s_plus_22.Service Service to associate with the statefulset. default_selector Optional \u00b6 default_selector : bool Type: bool Default: true Automatically allocates a pod selector for this statefulset. If this is set to false you must define your selector through statefulset.podMetadata.addLabel() and statefulset.selectByLabel() . pod_management_policy Optional \u00b6 pod_management_policy : PodManagementPolicy Type: cdk8s_plus_22.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 replicas : typing . Union [ int , float ] Type: typing.Union[int, float] Default: 1 Number of desired pods. VolumeMount \u00b6 Mount a volume from the pod to the container. Initializer \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . VolumeMount ( propagation : MountPropagation = None , read_only : bool = None , sub_path : str = None , sub_path_expr : str = None , path : str , volume : Volume ) propagation Optional \u00b6 propagation : MountPropagation Type: cdk8s_plus_22.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. This field is beta in 1.10. read_only Optional \u00b6 read_only : bool Type: bool Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. sub_path Optional \u00b6 sub_path : str Type: str Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). sub_path_expr Optional \u00b6 sub_path_expr : str Type: str Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). SubPathExpr and SubPath are mutually exclusive. This field is beta in 1.15. subPathExpr and subPath are mutually exclusive. This field is beta in 1.15. path Required \u00b6 path : str Type: str Path within the container at which the volume should be mounted. Must not contain \u2018:\u2019. volume Required \u00b6 volume : Volume Type: cdk8s_plus_22.Volume The volume to mount. Classes \u00b6 Container \u00b6 A single application container that you want to run within a pod. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_22.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_22.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_22.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_22.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_22.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_22.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. Methods \u00b6 add_env \u00b6 def add_env ( name : str , value : EnvValue ) name Required \u00b6 Type: str The variable name. value Required \u00b6 Type: cdk8s_plus_22.EnvValue The variable value. mount \u00b6 def mount ( path : str , volume : Volume , propagation : MountPropagation = None , read_only : bool = None , sub_path : str = None , sub_path_expr : str = None ) path Required \u00b6 Type: str The desired path in the container. volume Required \u00b6 Type: cdk8s_plus_22.Volume The volume to mount. propagation Optional \u00b6 Type: cdk8s_plus_22.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. This field is beta in 1.10. read_only Optional \u00b6 Type: bool Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. sub_path Optional \u00b6 Type: str Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). sub_path_expr Optional \u00b6 Type: str Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). SubPathExpr and SubPath are mutually exclusive. This field is beta in 1.15. subPathExpr and subPath are mutually exclusive. This field is beta in 1.15. Properties \u00b6 env Required \u00b6 env : typing . Mapping [ EnvValue ] Type: typing.Mapping[ cdk8s_plus_22.EnvValue ] The environment variables for this container. Returns a copy. To add environment variables use addEnv() . image Required \u00b6 image : str Type: str The container image. image_pull_policy Required \u00b6 image_pull_policy : ImagePullPolicy Type: cdk8s_plus_22.ImagePullPolicy Image pull policy for this container. mounts Required \u00b6 mounts : typing . List [ VolumeMount ] Type: typing.List[ cdk8s_plus_22.VolumeMount ] Volume mounts configured for this container. name Required \u00b6 name : str Type: str The name of the container. args Optional \u00b6 args : typing . List [ str ] Type: typing.List[ str ] Arguments to the entrypoint. command Optional \u00b6 command : typing . List [ str ] Type: typing.List[ str ] Entrypoint array (the command to execute when the container starts). port Optional \u00b6 port : typing . Union [ int , float ] Type: typing.Union[int, float] The port this container exposes. working_dir Optional \u00b6 working_dir : str Type: str The working directory inside the container. EnvValue \u00b6 Utility class for creating reading env values from various sources. Static Functions \u00b6 from_config_map \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . EnvValue . from_config_map ( config_map : IConfigMap , key : str , optional : bool = None ) config_map Required \u00b6 Type: cdk8s_plus_22.IConfigMap The config map. key Required \u00b6 Type: str The key to extract the value from. optional Optional \u00b6 Type: bool Default: false Specify whether the ConfigMap or its key must be defined. from_process \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . EnvValue . from_process ( key : str , required : bool = None ) key Required \u00b6 Type: str The key to read. required Optional \u00b6 Type: bool Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. from_secret_value \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . EnvValue . from_secret_value ( key : str , secret : ISecret , optional : bool = None ) key Required \u00b6 Type: str The JSON key. secret Required \u00b6 Type: cdk8s_plus_22.ISecret The secret. optional Optional \u00b6 Type: bool Default: false Specify whether the Secret or its key must be defined. from_value \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . EnvValue . from_value ( value : str ) value Required \u00b6 Type: str The value. Properties \u00b6 value Optional \u00b6 value : typing . Any Type: typing.Any value_from Optional \u00b6 value_from : typing . Any Type: typing.Any IngressBackend \u00b6 The backend for an ingress path. Static Functions \u00b6 from_service \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . IngressBackend . from_service ( service : Service , port : typing . Union [ int , float ] = None ) service Required \u00b6 Type: cdk8s_plus_22.Service The service object. port Optional \u00b6 Type: typing.Union[int, float] Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. If the service exposes multiple ports, this option must be specified. If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. PodSpec \u00b6 Implements: cdk8s_plus_22.IPodSpec Provides read/write capabilities ontop of a PodSpecProps . Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PodSpec ( containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None ) containers Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_22.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_22.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_22.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_22.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_22.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_22.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( volume : Volume ) volume Required \u00b6 Type: cdk8s_plus_22.Volume Properties \u00b6 containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_22.Container ] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_22.Volume ] The volumes associated with this pod. Use addVolume to add volumes. restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_22.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_22.IServiceAccount The service account used to run this pod. PodTemplate \u00b6 Implements: cdk8s_plus_22.IPodTemplate Provides read/write capabilities ontop of a PodTemplateProps . Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . PodTemplate ( containers : typing . List [ ContainerProps ] = None , restart_policy : RestartPolicy = None , service_account : IServiceAccount = None , volumes : typing . List [ Volume ] = None , pod_metadata : ApiObjectMetadata = None ) containers Optional \u00b6 Type: typing.List[ cdk8s_plus_22.ContainerProps ] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restart_policy Optional \u00b6 Type: cdk8s_plus_22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy service_account Optional \u00b6 Type: cdk8s_plus_22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 Type: typing.List[ cdk8s_plus_22.Volume ] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes pod_metadata Optional \u00b6 Type: cdk8s.ApiObjectMetadata The pod metadata. Properties \u00b6 pod_metadata Required \u00b6 pod_metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. Probe \u00b6 Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic. Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Probe () Static Functions \u00b6 from_command \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Probe . from_command ( command : typing . List [ str ], failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None ) command Required \u00b6 Type: typing.List[ str ] The command to execute. failure_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes from_http_get \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Probe . from_http_get ( path : str , failure_threshold : typing . Union [ int , float ] = None , initial_delay_seconds : Duration = None , period_seconds : Duration = None , success_threshold : typing . Union [ int , float ] = None , timeout_seconds : Duration = None , port : typing . Union [ int , float ] = None ) path Required \u00b6 Type: str The URL path to hit. failure_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initial_delay_seconds Optional \u00b6 Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes period_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. success_threshold Optional \u00b6 Type: typing.Union[int, float] Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeout_seconds Optional \u00b6 Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 Type: typing.Union[int, float] Default: defaults to container.port . The TCP port to use when sending the GET request. Volume \u00b6 Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes Initializers \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Volume ( name : str , config : typing . Any ) name Required \u00b6 Type: str config Required \u00b6 Type: typing.Any Static Functions \u00b6 from_config_map \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Volume . from_config_map ( config_map : IConfigMap , default_mode : typing . Union [ int , float ] = None , items : typing . Mapping [ PathMapping ] = None , name : str = None , optional : bool = None ) config_map Required \u00b6 Type: cdk8s_plus_22.IConfigMap The config map to use to populate the volume. default_mode Optional \u00b6 Type: typing.Union[int, float] Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_22.PathMapping ] Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 Type: str Default: auto-generated The volume name. optional Optional \u00b6 Type: bool Default: undocumented Specify whether the ConfigMap or its keys must be defined. from_empty_dir \u00b6 import cdk8s_plus_22 cdk8s_plus_22 . Volume . from_empty_dir ( name : str , medium : EmptyDirMedium = None , size_limit : Size = None ) name Required \u00b6 Type: str medium Optional \u00b6 Type: cdk8s_plus_22.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. size_limit Optional \u00b6 Type: cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. Properties \u00b6 name Required \u00b6 name : str Type: str Protocols \u00b6 IConfigMap \u00b6 Extends: cdk8s_plus_22.IResource Implemented By: cdk8s_plus_22.ConfigMap , cdk8s_plus_22.IConfigMap Represents a config map. Properties \u00b6 name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IPodSpec \u00b6 Implemented By: cdk8s_plus_22.Deployment , cdk8s_plus_22.Job , cdk8s_plus_22.Pod , cdk8s_plus_22.PodSpec , cdk8s_plus_22.PodTemplate , cdk8s_plus_22.StatefulSet , cdk8s_plus_22.IPodSpec , cdk8s_plus_22.IPodTemplate Represents a resource that can be configured with a kuberenets pod spec. (e.g Deployment , Job , Pod , \u2026). Use the PodSpec class as an implementation helper. Methods \u00b6 add_container \u00b6 def add_container ( image : str , args : typing . List [ str ] = None , command : typing . List [ str ] = None , env : typing . Mapping [ EnvValue ] = None , image_pull_policy : ImagePullPolicy = None , liveness : Probe = None , name : str = None , port : typing . Union [ int , float ] = None , readiness : Probe = None , startup : Probe = None , volume_mounts : typing . List [ VolumeMount ] = None , working_dir : str = None ) image Required \u00b6 Type: str Docker image name. args Optional \u00b6 Type: typing.List[ str ] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 Type: typing.List[ str ] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 Type: typing.Mapping[ cdk8s_plus_22.EnvValue ] Default: No environment variables. List of environment variables to set in the container. Cannot be updated. image_pull_policy Optional \u00b6 Type: cdk8s_plus_22.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 Type: cdk8s_plus_22.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 Type: str Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 Type: typing.Union[int, float] Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 Type: cdk8s_plus_22.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 Type: cdk8s_plus_22.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volume_mounts Optional \u00b6 Type: typing.List[ cdk8s_plus_22.VolumeMount ] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. working_dir Optional \u00b6 Type: str Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. add_volume \u00b6 def add_volume ( volume : Volume ) volume Required \u00b6 Type: cdk8s_plus_22.Volume The volume. Properties \u00b6 containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_22.Container ] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_22.Volume ] The volumes associated with this pod. Use addVolume to add volumes. restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_22.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_22.IServiceAccount The service account used to run this pod. IPodTemplate \u00b6 Extends: cdk8s_plus_22.IPodSpec Implemented By: cdk8s_plus_22.Deployment , cdk8s_plus_22.Job , cdk8s_plus_22.PodTemplate , cdk8s_plus_22.StatefulSet , cdk8s_plus_22.IPodTemplate Represents a resource that can be configured with a kuberenets pod template. (e.g Deployment , Job , \u2026). Use the PodTemplate class as an implementation helper. Properties \u00b6 containers Required \u00b6 containers : typing . List [ Container ] Type: typing.List[ cdk8s_plus_22.Container ] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 volumes : typing . List [ Volume ] Type: typing.List[ cdk8s_plus_22.Volume ] The volumes associated with this pod. Use addVolume to add volumes. restart_policy Optional \u00b6 restart_policy : RestartPolicy Type: cdk8s_plus_22.RestartPolicy Restart policy for all containers within the pod. service_account Optional \u00b6 service_account : IServiceAccount Type: cdk8s_plus_22.IServiceAccount The service account used to run this pod. pod_metadata Required \u00b6 pod_metadata : ApiObjectMetadataDefinition Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. IResource \u00b6 Implemented By: cdk8s_plus_22.ConfigMap , cdk8s_plus_22.Deployment , cdk8s_plus_22.Ingress , cdk8s_plus_22.Job , cdk8s_plus_22.Pod , cdk8s_plus_22.Resource , cdk8s_plus_22.Secret , cdk8s_plus_22.Service , cdk8s_plus_22.ServiceAccount , cdk8s_plus_22.StatefulSet , cdk8s_plus_22.IConfigMap , cdk8s_plus_22.IResource , cdk8s_plus_22.ISecret , cdk8s_plus_22.IServiceAccount Represents a resource. Properties \u00b6 name Required \u00b6 name : str Type: str The Kubernetes name of this resource. ISecret \u00b6 Extends: cdk8s_plus_22.IResource Implemented By: cdk8s_plus_22.Secret , cdk8s_plus_22.ISecret Properties \u00b6 name Required \u00b6 name : str Type: str The Kubernetes name of this resource. IServiceAccount \u00b6 Extends: cdk8s_plus_22.IResource Implemented By: cdk8s_plus_22.ServiceAccount , cdk8s_plus_22.IServiceAccount Properties \u00b6 name Required \u00b6 name : str Type: str The Kubernetes name of this resource. Enums \u00b6 EmptyDirMedium \u00b6 The medium on which to store the volume. DEFAULT \u00b6 The default volume of the backing node. MEMORY \u00b6 Mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. HttpIngressPathType \u00b6 Specify how the path is matched against request paths. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types PREFIX \u00b6 Matches the URL path exactly. EXACT \u00b6 Matches based on a URL path prefix split by \u2018/\u2019. IMPLEMENTATION_SPECIFIC \u00b6 Matching is specified by the underlying IngressClass. ImagePullPolicy \u00b6 ALWAYS \u00b6 Every time the kubelet launches a container, the kubelet queries the container image registry to resolve the name to an image digest. If the kubelet has a container image with that exact digest cached locally, the kubelet uses its cached image; otherwise, the kubelet downloads (pulls) the image with the resolved digest, and uses that image to launch the container. Default is Always if ImagePullPolicy is omitted and either the image tag is :latest or the image tag is omitted. IF_NOT_PRESENT \u00b6 The image is pulled only if it is not already present locally. Default is IfNotPresent if ImagePullPolicy is omitted and the image tag is present but not :latest NEVER \u00b6 The image is assumed to exist locally. No attempt is made to pull the image. MountPropagation \u00b6 NONE \u00b6 This volume mount will not receive any subsequent mounts that are mounted to this volume or any of its subdirectories by the host. In similar fashion, no mounts created by the Container will be visible on the host. This is the default mode. This mode is equal to private mount propagation as described in the Linux kernel documentation HOST_TO_CONTAINER \u00b6 This volume mount will receive all subsequent mounts that are mounted to this volume or any of its subdirectories. In other words, if the host mounts anything inside the volume mount, the Container will see it mounted there. Similarly, if any Pod with Bidirectional mount propagation to the same volume mounts anything there, the Container with HostToContainer mount propagation will see it. This mode is equal to rslave mount propagation as described in the Linux kernel documentation BIDIRECTIONAL \u00b6 This volume mount behaves the same the HostToContainer mount. In addition, all volume mounts created by the Container will be propagated back to the host and to all Containers of all Pods that use the same volume A typical use case for this mode is a Pod with a FlexVolume or CSI driver or a Pod that needs to mount something on the host using a hostPath volume. This mode is equal to rshared mount propagation as described in the Linux kernel documentation Caution: Bidirectional mount propagation can be dangerous. It can damage the host operating system and therefore it is allowed only in privileged Containers. Familiarity with Linux kernel behavior is strongly recommended. In addition, any volume mounts created by Containers in Pods must be destroyed (unmounted) by the Containers on termination. PodManagementPolicy \u00b6 Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once. ORDERED_READY \u00b6 PARALLEL \u00b6 Protocol \u00b6 TCP \u00b6 UDP \u00b6 SCTP \u00b6 RestartPolicy \u00b6 Restart policy for all containers within the pod. ALWAYS \u00b6 Always restart the pod after it exits. ON_FAILURE \u00b6 Only restart if the pod exits with a non-zero exit code. NEVER \u00b6 Never restart the pod. ServiceType \u00b6 For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP. CLUSTER_IP \u00b6 Exposes the Service on a cluster-internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default ServiceType NODE_PORT \u00b6 Exposes the Service on each Node\u2019s IP at a static port (the NodePort). A ClusterIP Service, to which the NodePort Service routes, is automatically created. You\u2019ll be able to contact the NodePort Service, from outside the cluster, by requesting : . LOAD_BALANCER \u00b6 Exposes the Service externally using a cloud provider\u2019s load balancer. NodePort and ClusterIP Services, to which the external load balancer routes, are automatically created. EXTERNAL_NAME \u00b6 Maps the Service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value. No proxying of any kind is set up. Note: You need either kube-dns version 1.7 or CoreDNS version 0.0.8 or higher to use the ExternalName type.","title":"Python"},{"location":"reference/cdk8s-plus-22/python/#cdk8s-plus-22-python","text":"","title":"cdk8s-plus-22 (Python) "},{"location":"reference/cdk8s-plus-22/python/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s-plus-22/python/#configmap","text":"Implements: cdk8s_plus_22.IConfigMap ConfigMap holds configuration data for pods to consume.","title":"ConfigMap "},{"location":"reference/cdk8s-plus-22/python/#deployment","text":"Implements: cdk8s_plus_22.IPodTemplate A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below.","title":"Deployment "},{"location":"reference/cdk8s-plus-22/python/#use-case","text":"The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore.","title":"Use Case"},{"location":"reference/cdk8s-plus-22/python/#ingress","text":"Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.","title":"Ingress "},{"location":"reference/cdk8s-plus-22/python/#job","text":"Implements: cdk8s_plus_22.IPodTemplate A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel.","title":"Job "},{"location":"reference/cdk8s-plus-22/python/#pod","text":"Implements: cdk8s_plus_22.IPodSpec Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.","title":"Pod "},{"location":"reference/cdk8s-plus-22/python/#resource","text":"Implements: cdk8s_plus_22.IResource Base class for all Kubernetes objects in stdk8s. Represents a single resource.","title":"Resource "},{"location":"reference/cdk8s-plus-22/python/#secret","text":"Implements: cdk8s_plus_22.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret","title":"Secret "},{"location":"reference/cdk8s-plus-22/python/#service","text":"An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods.","title":"Service "},{"location":"reference/cdk8s-plus-22/python/#serviceaccount","text":"Implements: cdk8s_plus_22.IServiceAccount A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account","title":"ServiceAccount "},{"location":"reference/cdk8s-plus-22/python/#statefulset","text":"Implements: cdk8s_plus_22.IPodTemplate StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed.","title":"StatefulSet "},{"location":"reference/cdk8s-plus-22/python/#using-statefulsets","text":"StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates.","title":"Using StatefulSets"},{"location":"reference/cdk8s-plus-22/python/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s-plus-22/python/#adddeploymentoptions","text":"Options to add a deployment to a service.","title":"AddDeploymentOptions "},{"location":"reference/cdk8s-plus-22/python/#adddirectoryoptions","text":"Options for configmap.addDirectory() .","title":"AddDirectoryOptions "},{"location":"reference/cdk8s-plus-22/python/#commandprobeoptions","text":"Options for Probe.fromCommand() .","title":"CommandProbeOptions "},{"location":"reference/cdk8s-plus-22/python/#configmapprops","text":"Properties for initialization of ConfigMap .","title":"ConfigMapProps "},{"location":"reference/cdk8s-plus-22/python/#configmapvolumeoptions","text":"Options for the ConfigMap-based volume.","title":"ConfigMapVolumeOptions "},{"location":"reference/cdk8s-plus-22/python/#containerprops","text":"Properties for creating a container.","title":"ContainerProps "},{"location":"reference/cdk8s-plus-22/python/#deploymentprops","text":"Properties for initialization of Deployment .","title":"DeploymentProps "},{"location":"reference/cdk8s-plus-22/python/#emptydirvolumeoptions","text":"Options for volumes populated with an empty directory.","title":"EmptyDirVolumeOptions "},{"location":"reference/cdk8s-plus-22/python/#envvaluefromconfigmapoptions","text":"Options to specify an envionment variable value from a ConfigMap key.","title":"EnvValueFromConfigMapOptions "},{"location":"reference/cdk8s-plus-22/python/#envvaluefromprocessoptions","text":"Options to specify an environment variable value from the process environment.","title":"EnvValueFromProcessOptions "},{"location":"reference/cdk8s-plus-22/python/#envvaluefromsecretoptions","text":"Options to specify an environment variable value from a Secret.","title":"EnvValueFromSecretOptions "},{"location":"reference/cdk8s-plus-22/python/#exposedeploymentviaingressoptions","text":"Options for exposing a deployment via an ingress.","title":"ExposeDeploymentViaIngressOptions "},{"location":"reference/cdk8s-plus-22/python/#exposedeploymentviaserviceoptions","text":"Options for exposing a deployment via a service.","title":"ExposeDeploymentViaServiceOptions "},{"location":"reference/cdk8s-plus-22/python/#exposeserviceviaingressoptions","text":"Options for exposing a service using an ingress.","title":"ExposeServiceViaIngressOptions "},{"location":"reference/cdk8s-plus-22/python/#httpgetprobeoptions","text":"Options for Probe.fromHttpGet() .","title":"HttpGetProbeOptions "},{"location":"reference/cdk8s-plus-22/python/#ingressprops","text":"Properties for Ingress .","title":"IngressProps "},{"location":"reference/cdk8s-plus-22/python/#ingressrule","text":"Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path.","title":"IngressRule "},{"location":"reference/cdk8s-plus-22/python/#ingresstls","text":"Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination.","title":"IngressTls "},{"location":"reference/cdk8s-plus-22/python/#jobprops","text":"Properties for initialization of Job .","title":"JobProps "},{"location":"reference/cdk8s-plus-22/python/#mountoptions","text":"Options for mounts.","title":"MountOptions "},{"location":"reference/cdk8s-plus-22/python/#pathmapping","text":"Maps a string key to a path within a volume.","title":"PathMapping "},{"location":"reference/cdk8s-plus-22/python/#podprops","text":"Properties for initialization of Pod .","title":"PodProps "},{"location":"reference/cdk8s-plus-22/python/#podspecprops","text":"Properties of a PodSpec .","title":"PodSpecProps "},{"location":"reference/cdk8s-plus-22/python/#podtemplateprops","text":"Properties of a PodTemplate . Adds metadata information on top of the spec.","title":"PodTemplateProps "},{"location":"reference/cdk8s-plus-22/python/#probeoptions","text":"Probe options.","title":"ProbeOptions "},{"location":"reference/cdk8s-plus-22/python/#resourceprops","text":"Initialization properties for resources.","title":"ResourceProps "},{"location":"reference/cdk8s-plus-22/python/#secretprops","text":"","title":"SecretProps "},{"location":"reference/cdk8s-plus-22/python/#secretvalue","text":"Represents a specific value in JSON secret.","title":"SecretValue "},{"location":"reference/cdk8s-plus-22/python/#serviceaccountprops","text":"Properties for initialization of ServiceAccount . Properties for initialization of ServiceAccount .","title":"ServiceAccountProps "},{"location":"reference/cdk8s-plus-22/python/#serviceingressbackendoptions","text":"Options for setting up backends for ingress rules.","title":"ServiceIngressBackendOptions "},{"location":"reference/cdk8s-plus-22/python/#serviceport","text":"Definition of a service port.","title":"ServicePort "},{"location":"reference/cdk8s-plus-22/python/#serviceportoptions","text":"","title":"ServicePortOptions "},{"location":"reference/cdk8s-plus-22/python/#serviceprops","text":"Properties for initialization of Service .","title":"ServiceProps "},{"location":"reference/cdk8s-plus-22/python/#statefulsetprops","text":"Properties for initialization of StatefulSet .","title":"StatefulSetProps "},{"location":"reference/cdk8s-plus-22/python/#volumemount","text":"Mount a volume from the pod to the container.","title":"VolumeMount "},{"location":"reference/cdk8s-plus-22/python/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s-plus-22/python/#container","text":"A single application container that you want to run within a pod.","title":"Container "},{"location":"reference/cdk8s-plus-22/python/#envvalue","text":"Utility class for creating reading env values from various sources.","title":"EnvValue "},{"location":"reference/cdk8s-plus-22/python/#ingressbackend","text":"The backend for an ingress path.","title":"IngressBackend "},{"location":"reference/cdk8s-plus-22/python/#podspec","text":"Implements: cdk8s_plus_22.IPodSpec Provides read/write capabilities ontop of a PodSpecProps .","title":"PodSpec "},{"location":"reference/cdk8s-plus-22/python/#podtemplate","text":"Implements: cdk8s_plus_22.IPodTemplate Provides read/write capabilities ontop of a PodTemplateProps .","title":"PodTemplate "},{"location":"reference/cdk8s-plus-22/python/#probe","text":"Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.","title":"Probe "},{"location":"reference/cdk8s-plus-22/python/#volume","text":"Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes","title":"Volume "},{"location":"reference/cdk8s-plus-22/python/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s-plus-22/python/#iconfigmap","text":"Extends: cdk8s_plus_22.IResource Implemented By: cdk8s_plus_22.ConfigMap , cdk8s_plus_22.IConfigMap Represents a config map.","title":"IConfigMap "},{"location":"reference/cdk8s-plus-22/python/#ipodspec","text":"Implemented By: cdk8s_plus_22.Deployment , cdk8s_plus_22.Job , cdk8s_plus_22.Pod , cdk8s_plus_22.PodSpec , cdk8s_plus_22.PodTemplate , cdk8s_plus_22.StatefulSet , cdk8s_plus_22.IPodSpec , cdk8s_plus_22.IPodTemplate Represents a resource that can be configured with a kuberenets pod spec. (e.g Deployment , Job , Pod , \u2026). Use the PodSpec class as an implementation helper.","title":"IPodSpec "},{"location":"reference/cdk8s-plus-22/python/#ipodtemplate","text":"Extends: cdk8s_plus_22.IPodSpec Implemented By: cdk8s_plus_22.Deployment , cdk8s_plus_22.Job , cdk8s_plus_22.PodTemplate , cdk8s_plus_22.StatefulSet , cdk8s_plus_22.IPodTemplate Represents a resource that can be configured with a kuberenets pod template. (e.g Deployment , Job , \u2026). Use the PodTemplate class as an implementation helper.","title":"IPodTemplate "},{"location":"reference/cdk8s-plus-22/python/#iresource","text":"Implemented By: cdk8s_plus_22.ConfigMap , cdk8s_plus_22.Deployment , cdk8s_plus_22.Ingress , cdk8s_plus_22.Job , cdk8s_plus_22.Pod , cdk8s_plus_22.Resource , cdk8s_plus_22.Secret , cdk8s_plus_22.Service , cdk8s_plus_22.ServiceAccount , cdk8s_plus_22.StatefulSet , cdk8s_plus_22.IConfigMap , cdk8s_plus_22.IResource , cdk8s_plus_22.ISecret , cdk8s_plus_22.IServiceAccount Represents a resource.","title":"IResource "},{"location":"reference/cdk8s-plus-22/python/#isecret","text":"Extends: cdk8s_plus_22.IResource Implemented By: cdk8s_plus_22.Secret , cdk8s_plus_22.ISecret","title":"ISecret "},{"location":"reference/cdk8s-plus-22/python/#iserviceaccount","text":"Extends: cdk8s_plus_22.IResource Implemented By: cdk8s_plus_22.ServiceAccount , cdk8s_plus_22.IServiceAccount","title":"IServiceAccount "},{"location":"reference/cdk8s-plus-22/python/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s-plus-22/python/#emptydirmedium","text":"The medium on which to store the volume.","title":"EmptyDirMedium "},{"location":"reference/cdk8s-plus-22/python/#httpingresspathtype","text":"Specify how the path is matched against request paths. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types","title":"HttpIngressPathType "},{"location":"reference/cdk8s-plus-22/python/#imagepullpolicy","text":"","title":"ImagePullPolicy "},{"location":"reference/cdk8s-plus-22/python/#mountpropagation","text":"","title":"MountPropagation "},{"location":"reference/cdk8s-plus-22/python/#podmanagementpolicy","text":"Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.","title":"PodManagementPolicy "},{"location":"reference/cdk8s-plus-22/python/#protocol","text":"","title":"Protocol "},{"location":"reference/cdk8s-plus-22/python/#restartpolicy","text":"Restart policy for all containers within the pod.","title":"RestartPolicy "},{"location":"reference/cdk8s-plus-22/python/#servicetype","text":"For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP.","title":"ServiceType "},{"location":"reference/cdk8s-plus-22/typescript/","text":"cdk8s-plus-22 (TypeScript) \u00b6 Constructs \u00b6 ConfigMap \u00b6 Implements: cdk8s-plus-22.IConfigMap ConfigMap holds configuration data for pods to consume. Initializers \u00b6 import { ConfigMap } from 'cdk8s-plus-22' new ConfigMap ( scope : Construct , id : string , props? : ConfigMapProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-22.ConfigMapProps Methods \u00b6 addBinaryData \u00b6 public addBinaryData ( key : string , value : string ) key Required \u00b6 Type: string The key. value Required \u00b6 Type: string The value. addData \u00b6 public addData ( key : string , value : string ) key Required \u00b6 Type: string The key. value Required \u00b6 Type: string The value. addDirectory \u00b6 public addDirectory ( localDir : string , options? : AddDirectoryOptions ) localDir Required \u00b6 Type: string A path to a local directory. options Optional \u00b6 Type: cdk8s-plus-22.AddDirectoryOptions Options. addFile \u00b6 public addFile ( localFile : string , key? : string ) localFile Required \u00b6 Type: string The path to the local file. key Optional \u00b6 Type: string The ConfigMap key (default to the file name). Static Functions \u00b6 fromConfigMapName \u00b6 import { ConfigMap } from 'cdk8s-plus-22' ConfigMap . fromConfigMapName ( name : string ) name Required \u00b6 Type: string The name of the config map to import. Properties \u00b6 binaryData Required \u00b6 public readonly binaryData : {[ key : string ] : string }; Type: {[ key: string ]: string } The binary data associated with this config map. Returns a copy. To add data records, use addBinaryData() or addData() . data Required \u00b6 public readonly data : {[ key : string ] : string }; Type: {[ key: string ]: string } The data associated with this config map. Returns an copy. To add data records, use addData() or addBinaryData() . Deployment \u00b6 Implements: cdk8s-plus-22.IPodTemplate A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below. Use Case \u00b6 The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore. Initializers \u00b6 import { Deployment } from 'cdk8s-plus-22' new Deployment ( scope : Construct , id : string , props? : DeploymentProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-22.DeploymentProps Methods \u00b6 addContainer \u00b6 public addContainer ( container : ContainerProps ) container Required \u00b6 Type: cdk8s-plus-22.ContainerProps addVolume \u00b6 public addVolume ( volume : Volume ) volume Required \u00b6 Type: cdk8s-plus-22.Volume exposeViaIngress \u00b6 public exposeViaIngress ( path : string , options? : ExposeDeploymentViaIngressOptions ) path Required \u00b6 Type: string The ingress path to register under. options Optional \u00b6 Type: cdk8s-plus-22.ExposeDeploymentViaIngressOptions Additional options. exposeViaService \u00b6 public exposeViaService ( options? : ExposeDeploymentViaServiceOptions ) options Optional \u00b6 Type: cdk8s-plus-22.ExposeDeploymentViaServiceOptions Options to determine details of the service and port exposed. selectByLabel \u00b6 public selectByLabel ( key : string , value : string ) key Required \u00b6 Type: string The label key. value Required \u00b6 Type: string The label value. Properties \u00b6 containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-22.Container [] The containers belonging to the pod. Use addContainer to add containers. labelSelector Required \u00b6 public readonly labelSelector : {[ key : string ] : string }; Type: {[ key: string ]: string } The labels this deployment will match against in order to select pods. Returns a a copy. Use selectByLabel() to add labels. podMetadata Required \u00b6 public readonly podMetadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. replicas Required \u00b6 public readonly replicas : number ; Type: number Number of desired pods. volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-22.Volume [] The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-22.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-22.IServiceAccount The service account used to run this pod. Ingress \u00b6 Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc. Initializers \u00b6 import { Ingress } from 'cdk8s-plus-22' new Ingress ( scope : Construct , id : string , props? : IngressProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-22.IngressProps Methods \u00b6 addDefaultBackend \u00b6 public addDefaultBackend ( backend : IngressBackend ) backend Required \u00b6 Type: cdk8s-plus-22.IngressBackend The backend to use for requests that do not match any rule. addHostDefaultBackend \u00b6 public addHostDefaultBackend ( host : string , backend : IngressBackend ) host Required \u00b6 Type: string The host name to match. backend Required \u00b6 Type: cdk8s-plus-22.IngressBackend The backend to route to. addHostRule \u00b6 public addHostRule ( host : string , path : string , backend : IngressBackend , pathType? : HttpIngressPathType ) host Required \u00b6 Type: string The host name. path Required \u00b6 Type: string The HTTP path. backend Required \u00b6 Type: cdk8s-plus-22.IngressBackend The backend to route requests to. pathType Optional \u00b6 Type: cdk8s-plus-22.HttpIngressPathType How the path is matched against request paths. addRule \u00b6 public addRule ( path : string , backend : IngressBackend , pathType? : HttpIngressPathType ) path Required \u00b6 Type: string The HTTP path. backend Required \u00b6 Type: cdk8s-plus-22.IngressBackend The backend to route requests to. pathType Optional \u00b6 Type: cdk8s-plus-22.HttpIngressPathType How the path is matched against request paths. addRules \u00b6 public addRules ( rules : IngressRule ) rules Required \u00b6 Type: cdk8s-plus-22.IngressRule The rules to add. addTls \u00b6 public addTls ( tls : IngressTls []) tls Required \u00b6 Type: cdk8s-plus-22.IngressTls [] Job \u00b6 Implements: cdk8s-plus-22.IPodTemplate A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel. Initializers \u00b6 import { Job } from 'cdk8s-plus-22' new Job ( scope : Construct , id : string , props? : JobProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-22.JobProps Methods \u00b6 addContainer \u00b6 public addContainer ( container : ContainerProps ) container Required \u00b6 Type: cdk8s-plus-22.ContainerProps addVolume \u00b6 public addVolume ( volume : Volume ) volume Required \u00b6 Type: cdk8s-plus-22.Volume Properties \u00b6 containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-22.Container [] The containers belonging to the pod. Use addContainer to add containers. podMetadata Required \u00b6 public readonly podMetadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-22.Volume [] The volumes associated with this pod. Use addVolume to add volumes. activeDeadline Optional \u00b6 public readonly activeDeadline : Duration ; Type: cdk8s.Duration Duration before job is terminated. If undefined, there is no deadline. backoffLimit Optional \u00b6 public readonly backoffLimit : number ; Type: number Number of retries before marking failed. restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-22.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-22.IServiceAccount The service account used to run this pod. ttlAfterFinished Optional \u00b6 public readonly ttlAfterFinished : Duration ; Type: cdk8s.Duration TTL before the job is deleted after it is finished. Pod \u00b6 Implements: cdk8s-plus-22.IPodSpec Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts. Initializers \u00b6 import { Pod } from 'cdk8s-plus-22' new Pod ( scope : Construct , id : string , props? : PodProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-22.PodProps Methods \u00b6 addContainer \u00b6 public addContainer ( container : ContainerProps ) container Required \u00b6 Type: cdk8s-plus-22.ContainerProps addVolume \u00b6 public addVolume ( volume : Volume ) volume Required \u00b6 Type: cdk8s-plus-22.Volume Properties \u00b6 containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-22.Container [] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-22.Volume [] The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-22.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-22.IServiceAccount The service account used to run this pod. Resource \u00b6 Implements: cdk8s-plus-22.IResource Base class for all Kubernetes objects in stdk8s. Represents a single resource. Initializers \u00b6 import { Resource } from 'cdk8s-plus-22' new Resource ( scope : Construct , id : string , options? : ConstructOptions ) scope Required \u00b6 Type: constructs.Construct The scope in which to define this construct. id Required \u00b6 Type: string The scoped construct ID. Must be unique amongst siblings. If the ID includes a path separator ( / ), then it will be replaced by double dash -- . options Optional \u00b6 Type: constructs.ConstructOptions Options. Properties \u00b6 metadata Required \u00b6 public readonly metadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition name Required \u00b6 public readonly name : string ; Type: string The name of this API object. Secret \u00b6 Implements: cdk8s-plus-22.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret Initializers \u00b6 import { Secret } from 'cdk8s-plus-22' new Secret ( scope : Construct , id : string , props? : SecretProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-22.SecretProps Methods \u00b6 addStringData \u00b6 public addStringData ( key : string , value : string ) key Required \u00b6 Type: string Key. value Required \u00b6 Type: string Value. getStringData \u00b6 public getStringData ( key : string ) key Required \u00b6 Type: string Key. Static Functions \u00b6 fromSecretName \u00b6 import { Secret } from 'cdk8s-plus-22' Secret . fromSecretName ( name : string ) name Required \u00b6 Type: string The name of the secret to reference. Service \u00b6 An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods. Initializers \u00b6 import { Service } from 'cdk8s-plus-22' new Service ( scope : Construct , id : string , props? : ServiceProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-22.ServiceProps Methods \u00b6 addDeployment \u00b6 public addDeployment ( deployment : Deployment , options? : AddDeploymentOptions ) deployment Required \u00b6 Type: cdk8s-plus-22.Deployment The deployment to expose. options Optional \u00b6 Type: cdk8s-plus-22.AddDeploymentOptions Optional settings for the port. addSelector \u00b6 public addSelector ( label : string , value : string ) label Required \u00b6 Type: string The label key. value Required \u00b6 Type: string The label value. exposeViaIngress \u00b6 public exposeViaIngress ( path : string , options? : ExposeServiceViaIngressOptions ) path Required \u00b6 Type: string The path to expose the service under. options Optional \u00b6 Type: cdk8s-plus-22.ExposeServiceViaIngressOptions Additional options. serve \u00b6 public serve ( port : number , options? : ServicePortOptions ) port Required \u00b6 Type: number The port definition. options Optional \u00b6 Type: cdk8s-plus-22.ServicePortOptions Properties \u00b6 ports Required \u00b6 public readonly ports : ServicePort []; Type: cdk8s-plus-22.ServicePort [] Ports for this service. Use serve() to expose additional service ports. selector Required \u00b6 public readonly selector : {[ key : string ] : string }; Type: {[ key: string ]: string } Returns the labels which are used to select pods for this service. type Required \u00b6 public readonly type : ServiceType ; Type: cdk8s-plus-22.ServiceType Determines how the Service is exposed. clusterIP Optional \u00b6 public readonly clusterIP : string ; Type: string The IP address of the service and is usually assigned randomly by the master. externalName Optional \u00b6 public readonly externalName : string ; Type: string The externalName to be used for EXTERNAL_NAME types. ServiceAccount \u00b6 Implements: cdk8s-plus-22.IServiceAccount A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account Initializers \u00b6 import { ServiceAccount } from 'cdk8s-plus-22' new ServiceAccount ( scope : Construct , id : string , props? : ServiceAccountProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Optional \u00b6 Type: cdk8s-plus-22.ServiceAccountProps Methods \u00b6 addSecret \u00b6 public addSecret ( secret : ISecret ) secret Required \u00b6 Type: cdk8s-plus-22.ISecret The secret. Static Functions \u00b6 fromServiceAccountName \u00b6 import { ServiceAccount } from 'cdk8s-plus-22' ServiceAccount . fromServiceAccountName ( name : string ) name Required \u00b6 Type: string The name of the service account resource. Properties \u00b6 secrets Required \u00b6 public readonly secrets : ISecret []; Type: cdk8s-plus-22.ISecret [] List of secrets allowed to be used by pods running using this service account. Returns a copy. To add a secret, use addSecret() . StatefulSet \u00b6 Implements: cdk8s-plus-22.IPodTemplate StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed. Using StatefulSets \u00b6 StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates. Initializers \u00b6 import { StatefulSet } from 'cdk8s-plus-22' new StatefulSet ( scope : Construct , id : string , props : StatefulSetProps ) scope Required \u00b6 Type: constructs.Construct id Required \u00b6 Type: string props Required \u00b6 Type: cdk8s-plus-22.StatefulSetProps Methods \u00b6 addContainer \u00b6 public addContainer ( container : ContainerProps ) container Required \u00b6 Type: cdk8s-plus-22.ContainerProps addVolume \u00b6 public addVolume ( volume : Volume ) volume Required \u00b6 Type: cdk8s-plus-22.Volume selectByLabel \u00b6 public selectByLabel ( key : string , value : string ) key Required \u00b6 Type: string The label key. value Required \u00b6 Type: string The label value. Properties \u00b6 containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-22.Container [] The containers belonging to the pod. Use addContainer to add containers. labelSelector Required \u00b6 public readonly labelSelector : {[ key : string ] : string }; Type: {[ key: string ]: string } The labels this statefulset will match against in order to select pods. Returns a a copy. Use selectByLabel() to add labels. podManagementPolicy Required \u00b6 public readonly podManagementPolicy : PodManagementPolicy ; Type: cdk8s-plus-22.PodManagementPolicy Management policy to use for the set. podMetadata Required \u00b6 public readonly podMetadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. replicas Required \u00b6 public readonly replicas : number ; Type: number Number of desired pods. volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-22.Volume [] The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-22.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-22.IServiceAccount The service account used to run this pod. Structs \u00b6 AddDeploymentOptions \u00b6 Options to add a deployment to a service. Initializer \u00b6 import { AddDeploymentOptions } from 'cdk8s-plus-22' const addDeploymentOptions : AddDeploymentOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public readonly nodePort : number ; Type: number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The value of port will be used. The port number the service will redirect to. port Optional \u00b6 public readonly port : number ; Type: number Default: Copied from the first container of the deployment. The port number the service will bind to. AddDirectoryOptions \u00b6 Options for configmap.addDirectory() . Initializer \u00b6 import { AddDirectoryOptions } from 'cdk8s-plus-22' const addDirectoryOptions : AddDirectoryOptions = { ... } exclude Optional \u00b6 public readonly exclude : string []; Type: string [] Default: include all files Glob patterns to exclude when adding files. keyPrefix Optional \u00b6 public readonly keyPrefix : string ; Type: string Default: \u201c\u201d A prefix to add to all keys in the config map. CommandProbeOptions \u00b6 Options for Probe.fromCommand() . Initializer \u00b6 import { CommandProbeOptions } from 'cdk8s-plus-22' const commandProbeOptions : CommandProbeOptions = { ... } failureThreshold Optional \u00b6 public readonly failureThreshold : number ; Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public readonly initialDelaySeconds : Duration ; Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public readonly periodSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public readonly successThreshold : number ; Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public readonly timeoutSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ConfigMapProps \u00b6 Properties for initialization of ConfigMap . Initializer \u00b6 import { ConfigMapProps } from 'cdk8s-plus-22' const configMapProps : ConfigMapProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. binaryData Optional \u00b6 public readonly binaryData : {[ key : string ] : string }; Type: {[ key: string ]: string } BinaryData contains the binary data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. BinaryData can contain byte sequences that are not in the UTF-8 range. The keys stored in BinaryData must not overlap with the ones in the Data field, this is enforced during validation process. Using this field will require 1.10+ apiserver and kubelet. You can also add binary data using configMap.addBinaryData() . data Optional \u00b6 public readonly data : {[ key : string ] : string }; Type: {[ key: string ]: string } Data contains the configuration data. Each key must consist of alphanumeric characters, \u2018-\u2018, \u2018_\u2019 or \u2018.\u2019. Values with non-UTF-8 byte sequences must use the BinaryData field. The keys stored in Data must not overlap with the keys in the BinaryData field, this is enforced during validation process. You can also add data using configMap.addData() . ConfigMapVolumeOptions \u00b6 Options for the ConfigMap-based volume. Initializer \u00b6 import { ConfigMapVolumeOptions } from 'cdk8s-plus-22' const configMapVolumeOptions : ConfigMapVolumeOptions = { ... } defaultMode Optional \u00b6 public readonly defaultMode : number ; Type: number Default: 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. Mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. items Optional \u00b6 public readonly items : {[ key : string ] : PathMapping }; Type: {[ key: string ]: cdk8s-plus-22.PathMapping } Default: no mapping If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the \u2018..\u2019 path or start with \u2018..\u2019. name Optional \u00b6 public readonly name : string ; Type: string Default: auto-generated The volume name. optional Optional \u00b6 public readonly optional : boolean ; Type: boolean Default: undocumented Specify whether the ConfigMap or its keys must be defined. ContainerProps \u00b6 Properties for creating a container. Initializer \u00b6 import { ContainerProps } from 'cdk8s-plus-22' const containerProps : ContainerProps = { ... } image Required \u00b6 public readonly image : string ; Type: string Docker image name. args Optional \u00b6 public readonly args : string []; Type: string [] Default: [] Arguments to the entrypoint. The docker image\u2019s CMD is used if command is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell command Optional \u00b6 public readonly command : string []; Type: string [] Default: The docker image\u2019s ENTRYPOINT. Entrypoint array. Not executed within a shell. The docker image\u2019s ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container\u2019s environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell env Optional \u00b6 public readonly env : {[ key : string ] : EnvValue }; Type: {[ key: string ]: cdk8s-plus-22.EnvValue } Default: No environment variables. List of environment variables to set in the container. Cannot be updated. imagePullPolicy Optional \u00b6 public readonly imagePullPolicy : ImagePullPolicy ; Type: cdk8s-plus-22.ImagePullPolicy Default: ImagePullPolicy.ALWAYS Image pull policy for this container. liveness Optional \u00b6 public readonly liveness : Probe ; Type: cdk8s-plus-22.Probe Default: no liveness probe is defined Periodic probe of container liveness. Container will be restarted if the probe fails. name Optional \u00b6 public readonly name : string ; Type: string Default: \u2018main\u2019 Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated. port Optional \u00b6 public readonly port : number ; Type: number Default: No port is exposed. Number of port to expose on the pod\u2019s IP address. This must be a valid port number, 0 < x < 65536. readiness Optional \u00b6 public readonly readiness : Probe ; Type: cdk8s-plus-22.Probe Default: no readiness probe is defined Determines when the container is ready to serve traffic. startup Optional \u00b6 public readonly startup : Probe ; Type: cdk8s-plus-22.Probe Default: no startup probe is defined. StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully volumeMounts Optional \u00b6 public readonly volumeMounts : VolumeMount []; Type: cdk8s-plus-22.VolumeMount [] Pod volumes to mount into the container\u2019s filesystem. Cannot be updated. workingDir Optional \u00b6 public readonly workingDir : string ; Type: string Default: The container runtime\u2019s default. Container\u2019s working directory. If not specified, the container runtime\u2019s default will be used, which might be configured in the container image. Cannot be updated. DeploymentProps \u00b6 Properties for initialization of Deployment . Initializer \u00b6 import { DeploymentProps } from 'cdk8s-plus-22' const deploymentProps : DeploymentProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-22.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-22.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata. defaultSelector Optional \u00b6 public readonly defaultSelector : boolean ; Type: boolean Default: true Automatically allocates a pod selector for this deployment. If this is set to false you must define your selector through deployment.podMetadata.addLabel() and deployment.selectByLabel() . replicas Optional \u00b6 public readonly replicas : number ; Type: number Default: 1 Number of desired pods. EmptyDirVolumeOptions \u00b6 Options for volumes populated with an empty directory. Initializer \u00b6 import { EmptyDirVolumeOptions } from 'cdk8s-plus-22' const emptyDirVolumeOptions : EmptyDirVolumeOptions = { ... } medium Optional \u00b6 public readonly medium : EmptyDirMedium ; Type: cdk8s-plus-22.EmptyDirMedium Default: EmptyDirMedium.DEFAULT By default, emptyDir volumes are stored on whatever medium is backing the node - that might be disk or SSD or network storage, depending on your environment. However, you can set the emptyDir.medium field to EmptyDirMedium.MEMORY to tell Kubernetes to mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. sizeLimit Optional \u00b6 public readonly sizeLimit : Size ; Type: cdk8s.Size Default: limit is undefined Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. EnvValueFromConfigMapOptions \u00b6 Options to specify an envionment variable value from a ConfigMap key. Initializer \u00b6 import { EnvValueFromConfigMapOptions } from 'cdk8s-plus-22' const envValueFromConfigMapOptions : EnvValueFromConfigMapOptions = { ... } optional Optional \u00b6 public readonly optional : boolean ; Type: boolean Default: false Specify whether the ConfigMap or its key must be defined. EnvValueFromProcessOptions \u00b6 Options to specify an environment variable value from the process environment. Initializer \u00b6 import { EnvValueFromProcessOptions } from 'cdk8s-plus-22' const envValueFromProcessOptions : EnvValueFromProcessOptions = { ... } required Optional \u00b6 public readonly required : boolean ; Type: boolean Default: false Specify whether the key must exist in the environment. If this is set to true, and the key does not exist, an error will thrown. EnvValueFromSecretOptions \u00b6 Options to specify an environment variable value from a Secret. Initializer \u00b6 import { EnvValueFromSecretOptions } from 'cdk8s-plus-22' const envValueFromSecretOptions : EnvValueFromSecretOptions = { ... } optional Optional \u00b6 public readonly optional : boolean ; Type: boolean Default: false Specify whether the Secret or its key must be defined. ExposeDeploymentViaIngressOptions \u00b6 Options for exposing a deployment via an ingress. Initializer \u00b6 import { ExposeDeploymentViaIngressOptions } from 'cdk8s-plus-22' const exposeDeploymentViaIngressOptions : ExposeDeploymentViaIngressOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 public readonly port : number ; Type: number Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. serviceType Optional \u00b6 public readonly serviceType : ServiceType ; Type: cdk8s-plus-22.ServiceType Default: ClusterIP. The type of the exposed service. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ingress Optional \u00b6 public readonly ingress : Ingress ; Type: cdk8s-plus-22.Ingress Default: An ingress will be automatically created. The ingress to add rules to. pathType Optional \u00b6 public readonly pathType : HttpIngressPathType ; Type: cdk8s-plus-22.HttpIngressPathType Default: HttpIngressPathType.PREFIX The type of the path. ExposeDeploymentViaServiceOptions \u00b6 Options for exposing a deployment via a service. Initializer \u00b6 import { ExposeDeploymentViaServiceOptions } from 'cdk8s-plus-22' const exposeDeploymentViaServiceOptions : ExposeDeploymentViaServiceOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string Default: undefined Uses the system generated name. The name of the service to expose. This will be set on the Service.metadata and must be a DNS_LABEL port Optional \u00b6 public readonly port : number ; Type: number Default: Copied from the container of the deployment. If a port could not be determined, throws an error. The port that the service should serve on. protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. serviceType Optional \u00b6 public readonly serviceType : ServiceType ; Type: cdk8s-plus-22.ServiceType Default: ClusterIP. The type of the exposed service. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The port of the first container in the deployment (ie. containers[0].port) The port number the service will redirect to. ExposeServiceViaIngressOptions \u00b6 Options for exposing a service using an ingress. Initializer \u00b6 import { ExposeServiceViaIngressOptions } from 'cdk8s-plus-22' const exposeServiceViaIngressOptions : ExposeServiceViaIngressOptions = { ... } ingress Optional \u00b6 public readonly ingress : Ingress ; Type: cdk8s-plus-22.Ingress Default: An ingress will be automatically created. The ingress to add rules to. pathType Optional \u00b6 public readonly pathType : HttpIngressPathType ; Type: cdk8s-plus-22.HttpIngressPathType Default: HttpIngressPathType.PREFIX The type of the path. HttpGetProbeOptions \u00b6 Options for Probe.fromHttpGet() . Initializer \u00b6 import { HttpGetProbeOptions } from 'cdk8s-plus-22' const httpGetProbeOptions : HttpGetProbeOptions = { ... } failureThreshold Optional \u00b6 public readonly failureThreshold : number ; Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public readonly initialDelaySeconds : Duration ; Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public readonly periodSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public readonly successThreshold : number ; Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public readonly timeoutSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes port Optional \u00b6 public readonly port : number ; Type: number Default: defaults to container.port . The TCP port to use when sending the GET request. IngressProps \u00b6 Properties for Ingress . Initializer \u00b6 import { IngressProps } from 'cdk8s-plus-22' const ingressProps : IngressProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. defaultBackend Optional \u00b6 public readonly defaultBackend : IngressBackend ; Type: cdk8s-plus-22.IngressBackend The default backend services requests that do not match any rule. Using this option or the addDefaultBackend() method is equivalent to adding a rule with both path and host undefined. rules Optional \u00b6 public readonly rules : IngressRule []; Type: cdk8s-plus-22.IngressRule [] Routing rules for this ingress. Each rule must define an IngressBackend that will receive the requests that match this rule. If both host and path are not specifiec, this backend will be used as the default backend of the ingress. You can also add rules later using addRule() , addHostRule() , addDefaultBackend() and addHostDefaultBackend() . tls Optional \u00b6 public readonly tls : IngressTls []; Type: cdk8s-plus-22.IngressTls [] TLS settings for this ingress. Using this option tells the ingress controller to expose a TLS endpoint. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI. IngressRule \u00b6 Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path. Initializer \u00b6 import { IngressRule } from 'cdk8s-plus-22' const ingressRule : IngressRule = { ... } backend Required \u00b6 public readonly backend : IngressBackend ; Type: cdk8s-plus-22.IngressBackend Backend defines the referenced service endpoint to which the traffic will be forwarded to. host Optional \u00b6 public readonly host : string ; Type: string Default: If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \u201chost\u201d part of the URI as defined in the RFC: 1. IPs are not allowed. Currently an IngressRuleValue can only apply to the IP in the Spec of the parent Ingress. 2. The : delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. Incoming requests are matched against the host before the IngressRuleValue. path Optional \u00b6 public readonly path : string ; Type: string Default: If unspecified, the path defaults to a catch all sending traffic to the backend. Path is an extended POSIX regex as defined by IEEE Std 1003.1, (i.e this follows the egrep/unix syntax, not the perl syntax) matched against the path of an incoming request. Currently it can contain characters disallowed from the conventional \u201cpath\u201d part of a URL as defined by RFC 3986. Paths must begin with a \u2018/\u2019. pathType Optional \u00b6 public readonly pathType : HttpIngressPathType ; Type: cdk8s-plus-22.HttpIngressPathType Specify how the path is matched against request paths. By default, path types will be matched by prefix. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types IngressTls \u00b6 Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination. Initializer \u00b6 import { IngressTls } from 'cdk8s-plus-22' const ingressTls : IngressTls = { ... } hosts Optional \u00b6 public readonly hosts : string []; Type: string [] Default: If unspecified, it defaults to the wildcard host setting for the loadbalancer controller fulfilling this Ingress. Hosts are a list of hosts included in the TLS certificate. The values in this list must match the name/s used in the TLS Secret. secret Optional \u00b6 public readonly secret : ISecret ; Type: cdk8s-plus-22.ISecret Default: If unspecified, it allows SSL routing based on SNI hostname. Secret is the secret that contains the certificate and key used to terminate SSL traffic on 443. If the SNI host in a listener conflicts with the \u201cHost\u201d header field used by an IngressRule, the SNI host is used for termination and value of the Host header is used for routing. JobProps \u00b6 Properties for initialization of Job . Initializer \u00b6 import { JobProps } from 'cdk8s-plus-22' const jobProps : JobProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-22.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-22.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata. activeDeadline Optional \u00b6 public readonly activeDeadline : Duration ; Type: cdk8s.Duration Default: If unset, then there is no deadline. Specifies the duration the job may be active before the system tries to terminate it. backoffLimit Optional \u00b6 public readonly backoffLimit : number ; Type: number Default: If not set, system defaults to 6. Specifies the number of retries before marking this job failed. ttlAfterFinished Optional \u00b6 public readonly ttlAfterFinished : Duration ; Type: cdk8s.Duration Default: If this field is unset, the Job won\u2019t be automatically deleted. Limits the lifetime of a Job that has finished execution (either Complete or Failed). If this field is set, after the Job finishes, it is eligible to be automatically deleted. When the Job is being deleted, its lifecycle guarantees (e.g. finalizers) will be honored. If this field is set to zero, the Job becomes eligible to be deleted immediately after it finishes. This field is alpha-level and is only honored by servers that enable the TTLAfterFinished feature. MountOptions \u00b6 Options for mounts. Initializer \u00b6 import { MountOptions } from 'cdk8s-plus-22' const mountOptions : MountOptions = { ... } propagation Optional \u00b6 public readonly propagation : MountPropagation ; Type: cdk8s-plus-22.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. This field is beta in 1.10. readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public readonly subPath : string ; Type: string Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public readonly subPathExpr : string ; Type: string Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). SubPathExpr and SubPath are mutually exclusive. This field is beta in 1.15. subPathExpr and subPath are mutually exclusive. This field is beta in 1.15. PathMapping \u00b6 Maps a string key to a path within a volume. Initializer \u00b6 import { PathMapping } from 'cdk8s-plus-22' const pathMapping : PathMapping = { ... } path Required \u00b6 public readonly path : string ; Type: string The relative path of the file to map the key to. May not be an absolute path. May not contain the path element \u2018..\u2019. May not start with the string \u2018..\u2019. mode Optional \u00b6 public readonly mode : number ; Type: number Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set. PodProps \u00b6 Properties for initialization of Pod . Initializer \u00b6 import { PodProps } from 'cdk8s-plus-22' const podProps : PodProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-22.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-22.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodSpecProps \u00b6 Properties of a PodSpec . Initializer \u00b6 import { PodSpecProps } from 'cdk8s-plus-22' const podSpecProps : PodSpecProps = { ... } containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-22.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-22.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes PodTemplateProps \u00b6 Properties of a PodTemplate . Adds metadata information on top of the spec. Initializer \u00b6 import { PodTemplateProps } from 'cdk8s-plus-22' const podTemplateProps : PodTemplateProps = { ... } containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-22.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-22.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata. ProbeOptions \u00b6 Probe options. Initializer \u00b6 import { ProbeOptions } from 'cdk8s-plus-22' const probeOptions : ProbeOptions = { ... } failureThreshold Optional \u00b6 public readonly failureThreshold : number ; Type: number Default: 3 Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. initialDelaySeconds Optional \u00b6 public readonly initialDelaySeconds : Duration ; Type: cdk8s.Duration Default: immediate Number of seconds after the container has started before liveness probes are initiated. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes periodSeconds Optional \u00b6 public readonly periodSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(10) Minimum value is 1. How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. successThreshold Optional \u00b6 public readonly successThreshold : number ; Type: number Default: 1 Must be 1 for liveness and startup. Minimum value is 1. Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. timeoutSeconds Optional \u00b6 public readonly timeoutSeconds : Duration ; Type: cdk8s.Duration Default: Duration.seconds(1) Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes ResourceProps \u00b6 Initialization properties for resources. Initializer \u00b6 import { ResourceProps } from 'cdk8s-plus-22' const resourceProps : ResourceProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. SecretProps \u00b6 Initializer \u00b6 import { SecretProps } from 'cdk8s-plus-22' const secretProps : SecretProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. stringData Optional \u00b6 public readonly stringData : {[ key : string ] : string }; Type: {[ key: string ]: string } stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API. type Optional \u00b6 public readonly type : string ; Type: string Default: undefined - Don\u2019t set a type. Optional type associated with the secret. Used to facilitate programmatic handling of secret data by various controllers. SecretValue \u00b6 Represents a specific value in JSON secret. Initializer \u00b6 import { SecretValue } from 'cdk8s-plus-22' const secretValue : SecretValue = { ... } key Required \u00b6 public readonly key : string ; Type: string The JSON key. secret Required \u00b6 public readonly secret : ISecret ; Type: cdk8s-plus-22.ISecret The secret. ServiceAccountProps \u00b6 Properties for initialization of ServiceAccount . Properties for initialization of ServiceAccount . Initializer \u00b6 import { ServiceAccountProps } from 'cdk8s-plus-22' const serviceAccountProps : ServiceAccountProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. secrets Optional \u00b6 public readonly secrets : ISecret []; Type: cdk8s-plus-22.ISecret [] List of secrets allowed to be used by pods running using this ServiceAccount. https://kubernetes.io/docs/concepts/configuration/secret ServiceIngressBackendOptions \u00b6 Options for setting up backends for ingress rules. Initializer \u00b6 import { ServiceIngressBackendOptions } from 'cdk8s-plus-22' const serviceIngressBackendOptions : ServiceIngressBackendOptions = { ... } port Optional \u00b6 public readonly port : number ; Type: number Default: if the service exposes a single port, this port will be used. The port to use to access the service. This option will fail if the service does not expose any ports. - If the service exposes multiple ports, this option must be specified. - If the service exposes a single port, this option is optional and if specified, it must be the same port exposed by the service. ServicePort \u00b6 Definition of a service port. Initializer \u00b6 import { ServicePort } from 'cdk8s-plus-22' const servicePort : ServicePort = { ... } name Optional \u00b6 public readonly name : string ; Type: string The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public readonly nodePort : number ; Type: number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The value of port will be used. The port number the service will redirect to. port Required \u00b6 public readonly port : number ; Type: number The port number the service will bind to. ServicePortOptions \u00b6 Initializer \u00b6 import { ServicePortOptions } from 'cdk8s-plus-22' const servicePortOptions : ServicePortOptions = { ... } name Optional \u00b6 public readonly name : string ; Type: string The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the \u2018Name\u2019 field in EndpointPort objects. Optional if only one ServicePort is defined on this service. nodePort Optional \u00b6 public readonly nodePort : number ; Type: number Default: auto-allocate a port if the ServiceType of this Service requires one. The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport protocol Optional \u00b6 public readonly protocol : Protocol ; Type: cdk8s-plus-22.Protocol Default: Protocol.TCP The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP. targetPort Optional \u00b6 public readonly targetPort : number ; Type: number Default: The value of port will be used. The port number the service will redirect to. ServiceProps \u00b6 Properties for initialization of Service . Initializer \u00b6 import { ServiceProps } from 'cdk8s-plus-22' const serviceProps : ServiceProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. clusterIP Optional \u00b6 public readonly clusterIP : string ; Type: string Default: Automatically assigned. The IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \u201cNone\u201d, empty string (\u201c\u201d), or a valid IP address. \u201cNone\u201d can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies externalIPs Optional \u00b6 public readonly externalIPs : string []; Type: string [] Default: No external IPs. A list of IP addresses for which nodes in the cluster will also accept traffic for this service. These IPs are not managed by Kubernetes. The user is responsible for ensuring that traffic arrives at a node with this IP. A common example is external load-balancers that are not part of the Kubernetes system. externalName Optional \u00b6 public readonly externalName : string ; Type: string Default: No external name. The externalName to be used when ServiceType.EXTERNAL_NAME is set. loadBalancerSourceRanges Optional \u00b6 public readonly loadBalancerSourceRanges : string []; Type: string [] A list of CIDR IP addresses, if specified and supported by the platform, will restrict traffic through the cloud-provider load-balancer to the specified client IPs. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ ports Optional \u00b6 public readonly ports : ServicePort []; Type: cdk8s-plus-22.ServicePort [] The port exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies type Optional \u00b6 public readonly type : ServiceType ; Type: cdk8s-plus-22.ServiceType Default: ServiceType.ClusterIP Determines how the Service is exposed. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types StatefulSetProps \u00b6 Properties for initialization of StatefulSet . Initializer \u00b6 import { StatefulSetProps } from 'cdk8s-plus-22' const statefulSetProps : StatefulSetProps = { ... } metadata Optional \u00b6 public readonly metadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata Metadata that all persisted resources must have, which includes all objects users must create. containers Optional \u00b6 public readonly containers : ContainerProps []; Type: cdk8s-plus-22.ContainerProps [] Default: No containers. Note that a pod spec must include at least one container. List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. You can add additionnal containers using podSpec.addContainer() restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-22.RestartPolicy Default: RestartPolicy.ALWAYS Restart policy for all containers within the pod. https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-22.IServiceAccount Default: No service account. A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/ volumes Optional \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-22.Volume [] Default: No volumes. List of volumes that can be mounted by containers belonging to the pod. You can also add volumes later using podSpec.addVolume() https://kubernetes.io/docs/concepts/storage/volumes podMetadata Optional \u00b6 public readonly podMetadata : ApiObjectMetadata ; Type: cdk8s.ApiObjectMetadata The pod metadata. service Required \u00b6 public readonly service : Service ; Type: cdk8s-plus-22.Service Service to associate with the statefulset. defaultSelector Optional \u00b6 public readonly defaultSelector : boolean ; Type: boolean Default: true Automatically allocates a pod selector for this statefulset. If this is set to false you must define your selector through statefulset.podMetadata.addLabel() and statefulset.selectByLabel() . podManagementPolicy Optional \u00b6 public readonly podManagementPolicy : PodManagementPolicy ; Type: cdk8s-plus-22.PodManagementPolicy Default: PodManagementPolicy.ORDERED_READY Pod management policy to use for this statefulset. replicas Optional \u00b6 public readonly replicas : number ; Type: number Default: 1 Number of desired pods. VolumeMount \u00b6 Mount a volume from the pod to the container. Initializer \u00b6 import { VolumeMount } from 'cdk8s-plus-22' const volumeMount : VolumeMount = { ... } propagation Optional \u00b6 public readonly propagation : MountPropagation ; Type: cdk8s-plus-22.MountPropagation Default: MountPropagation.NONE Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. Mount propagation allows for sharing volumes mounted by a Container to other Containers in the same Pod, or even to other Pods on the same node. This field is beta in 1.10. readOnly Optional \u00b6 public readonly readOnly : boolean ; Type: boolean Default: false Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false. subPath Optional \u00b6 public readonly subPath : string ; Type: string Default: \u201c\u201d the volume\u2019s root Path within the volume from which the container\u2019s volume should be mounted.). subPathExpr Optional \u00b6 public readonly subPathExpr : string ; Type: string Default: \u201c\u201d volume\u2019s root. Expanded path within the volume from which the container\u2019s volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container\u2019s environment. Defaults to \u201c\u201d (volume\u2019s root). SubPathExpr and SubPath are mutually exclusive. This field is beta in 1.15. subPathExpr and subPath are mutually exclusive. This field is beta in 1.15. path Required \u00b6 public readonly path : string ; Type: string Path within the container at which the volume should be mounted. Must not contain \u2018:\u2019. volume Required \u00b6 public readonly volume : Volume ; Type: cdk8s-plus-22.Volume The volume to mount. Classes \u00b6 Container \u00b6 A single application container that you want to run within a pod. Initializers \u00b6 import { Container } from 'cdk8s-plus-22' new Container ( props : ContainerProps ) props Required \u00b6 Type: cdk8s-plus-22.ContainerProps Methods \u00b6 addEnv \u00b6 public addEnv ( name : string , value : EnvValue ) name Required \u00b6 Type: string The variable name. value Required \u00b6 Type: cdk8s-plus-22.EnvValue The variable value. mount \u00b6 public mount ( path : string , volume : Volume , options? : MountOptions ) path Required \u00b6 Type: string The desired path in the container. volume Required \u00b6 Type: cdk8s-plus-22.Volume The volume to mount. options Optional \u00b6 Type: cdk8s-plus-22.MountOptions Properties \u00b6 env Required \u00b6 public readonly env : {[ key : string ] : EnvValue }; Type: {[ key: string ]: cdk8s-plus-22.EnvValue } The environment variables for this container. Returns a copy. To add environment variables use addEnv() . image Required \u00b6 public readonly image : string ; Type: string The container image. imagePullPolicy Required \u00b6 public readonly imagePullPolicy : ImagePullPolicy ; Type: cdk8s-plus-22.ImagePullPolicy Image pull policy for this container. mounts Required \u00b6 public readonly mounts : VolumeMount []; Type: cdk8s-plus-22.VolumeMount [] Volume mounts configured for this container. name Required \u00b6 public readonly name : string ; Type: string The name of the container. args Optional \u00b6 public readonly args : string []; Type: string [] Arguments to the entrypoint. command Optional \u00b6 public readonly command : string []; Type: string [] Entrypoint array (the command to execute when the container starts). port Optional \u00b6 public readonly port : number ; Type: number The port this container exposes. workingDir Optional \u00b6 public readonly workingDir : string ; Type: string The working directory inside the container. EnvValue \u00b6 Utility class for creating reading env values from various sources. Static Functions \u00b6 fromConfigMap \u00b6 import { EnvValue } from 'cdk8s-plus-22' EnvValue . fromConfigMap ( configMap : IConfigMap , key : string , options? : EnvValueFromConfigMapOptions ) configMap Required \u00b6 Type: cdk8s-plus-22.IConfigMap The config map. key Required \u00b6 Type: string The key to extract the value from. options Optional \u00b6 Type: cdk8s-plus-22.EnvValueFromConfigMapOptions Additional options. fromProcess \u00b6 import { EnvValue } from 'cdk8s-plus-22' EnvValue . fromProcess ( key : string , options? : EnvValueFromProcessOptions ) key Required \u00b6 Type: string The key to read. options Optional \u00b6 Type: cdk8s-plus-22.EnvValueFromProcessOptions Additional options. fromSecretValue \u00b6 import { EnvValue } from 'cdk8s-plus-22' EnvValue . fromSecretValue ( secretValue : SecretValue , options? : EnvValueFromSecretOptions ) secretValue Required \u00b6 Type: cdk8s-plus-22.SecretValue The secret value (secrent + key). options Optional \u00b6 Type: cdk8s-plus-22.EnvValueFromSecretOptions Additional options. fromValue \u00b6 import { EnvValue } from 'cdk8s-plus-22' EnvValue . fromValue ( value : string ) value Required \u00b6 Type: string The value. Properties \u00b6 value Optional \u00b6 public readonly value : any ; Type: any valueFrom Optional \u00b6 public readonly valueFrom : any ; Type: any IngressBackend \u00b6 The backend for an ingress path. Static Functions \u00b6 fromService \u00b6 import { IngressBackend } from 'cdk8s-plus-22' IngressBackend . fromService ( service : Service , options? : ServiceIngressBackendOptions ) service Required \u00b6 Type: cdk8s-plus-22.Service The service object. options Optional \u00b6 Type: cdk8s-plus-22.ServiceIngressBackendOptions PodSpec \u00b6 Implements: cdk8s-plus-22.IPodSpec Provides read/write capabilities ontop of a PodSpecProps . Initializers \u00b6 import { PodSpec } from 'cdk8s-plus-22' new PodSpec ( props? : PodSpecProps ) props Optional \u00b6 Type: cdk8s-plus-22.PodSpecProps Methods \u00b6 addContainer \u00b6 public addContainer ( container : ContainerProps ) container Required \u00b6 Type: cdk8s-plus-22.ContainerProps addVolume \u00b6 public addVolume ( volume : Volume ) volume Required \u00b6 Type: cdk8s-plus-22.Volume Properties \u00b6 containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-22.Container [] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-22.Volume [] The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-22.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-22.IServiceAccount The service account used to run this pod. PodTemplate \u00b6 Implements: cdk8s-plus-22.IPodTemplate Provides read/write capabilities ontop of a PodTemplateProps . Initializers \u00b6 import { PodTemplate } from 'cdk8s-plus-22' new PodTemplate ( props? : PodTemplateProps ) props Optional \u00b6 Type: cdk8s-plus-22.PodTemplateProps Properties \u00b6 podMetadata Required \u00b6 public readonly podMetadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. Probe \u00b6 Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic. Initializers \u00b6 import { Probe } from 'cdk8s-plus-22' new Probe () Static Functions \u00b6 fromCommand \u00b6 import { Probe } from 'cdk8s-plus-22' Probe . fromCommand ( command : string [], options? : CommandProbeOptions ) command Required \u00b6 Type: string [] The command to execute. options Optional \u00b6 Type: cdk8s-plus-22.CommandProbeOptions Options. fromHttpGet \u00b6 import { Probe } from 'cdk8s-plus-22' Probe . fromHttpGet ( path : string , options? : HttpGetProbeOptions ) path Required \u00b6 Type: string The URL path to hit. options Optional \u00b6 Type: cdk8s-plus-22.HttpGetProbeOptions Options. Volume \u00b6 Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes Initializers \u00b6 import { Volume } from 'cdk8s-plus-22' new Volume ( name : string , config : any ) name Required \u00b6 Type: string config Required \u00b6 Type: any Static Functions \u00b6 fromConfigMap \u00b6 import { Volume } from 'cdk8s-plus-22' Volume . fromConfigMap ( configMap : IConfigMap , options? : ConfigMapVolumeOptions ) configMap Required \u00b6 Type: cdk8s-plus-22.IConfigMap The config map to use to populate the volume. options Optional \u00b6 Type: cdk8s-plus-22.ConfigMapVolumeOptions Options. fromEmptyDir \u00b6 import { Volume } from 'cdk8s-plus-22' Volume . fromEmptyDir ( name : string , options? : EmptyDirVolumeOptions ) name Required \u00b6 Type: string options Optional \u00b6 Type: cdk8s-plus-22.EmptyDirVolumeOptions Additional options. Properties \u00b6 name Required \u00b6 public readonly name : string ; Type: string Protocols \u00b6 IConfigMap \u00b6 Extends: cdk8s-plus-22.IResource Implemented By: cdk8s-plus-22.ConfigMap , cdk8s-plus-22.IConfigMap Represents a config map. Properties \u00b6 name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IPodSpec \u00b6 Implemented By: cdk8s-plus-22.Deployment , cdk8s-plus-22.Job , cdk8s-plus-22.Pod , cdk8s-plus-22.PodSpec , cdk8s-plus-22.PodTemplate , cdk8s-plus-22.StatefulSet , cdk8s-plus-22.IPodSpec , cdk8s-plus-22.IPodTemplate Represents a resource that can be configured with a kuberenets pod spec. (e.g Deployment , Job , Pod , \u2026). Use the PodSpec class as an implementation helper. Methods \u00b6 addContainer \u00b6 public addContainer ( container : ContainerProps ) container Required \u00b6 Type: cdk8s-plus-22.ContainerProps The container. addVolume \u00b6 public addVolume ( volume : Volume ) volume Required \u00b6 Type: cdk8s-plus-22.Volume The volume. Properties \u00b6 containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-22.Container [] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-22.Volume [] The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-22.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-22.IServiceAccount The service account used to run this pod. IPodTemplate \u00b6 Extends: cdk8s-plus-22.IPodSpec Implemented By: cdk8s-plus-22.Deployment , cdk8s-plus-22.Job , cdk8s-plus-22.PodTemplate , cdk8s-plus-22.StatefulSet , cdk8s-plus-22.IPodTemplate Represents a resource that can be configured with a kuberenets pod template. (e.g Deployment , Job , \u2026). Use the PodTemplate class as an implementation helper. Properties \u00b6 containers Required \u00b6 public readonly containers : Container []; Type: cdk8s-plus-22.Container [] The containers belonging to the pod. Use addContainer to add containers. volumes Required \u00b6 public readonly volumes : Volume []; Type: cdk8s-plus-22.Volume [] The volumes associated with this pod. Use addVolume to add volumes. restartPolicy Optional \u00b6 public readonly restartPolicy : RestartPolicy ; Type: cdk8s-plus-22.RestartPolicy Restart policy for all containers within the pod. serviceAccount Optional \u00b6 public readonly serviceAccount : IServiceAccount ; Type: cdk8s-plus-22.IServiceAccount The service account used to run this pod. podMetadata Required \u00b6 public readonly podMetadata : ApiObjectMetadataDefinition ; Type: cdk8s.ApiObjectMetadataDefinition Provides read/write access to the underlying pod metadata of the resource. IResource \u00b6 Implemented By: cdk8s-plus-22.ConfigMap , cdk8s-plus-22.Deployment , cdk8s-plus-22.Ingress , cdk8s-plus-22.Job , cdk8s-plus-22.Pod , cdk8s-plus-22.Resource , cdk8s-plus-22.Secret , cdk8s-plus-22.Service , cdk8s-plus-22.ServiceAccount , cdk8s-plus-22.StatefulSet , cdk8s-plus-22.IConfigMap , cdk8s-plus-22.IResource , cdk8s-plus-22.ISecret , cdk8s-plus-22.IServiceAccount Represents a resource. Properties \u00b6 name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. ISecret \u00b6 Extends: cdk8s-plus-22.IResource Implemented By: cdk8s-plus-22.Secret , cdk8s-plus-22.ISecret Properties \u00b6 name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. IServiceAccount \u00b6 Extends: cdk8s-plus-22.IResource Implemented By: cdk8s-plus-22.ServiceAccount , cdk8s-plus-22.IServiceAccount Properties \u00b6 name Required \u00b6 public readonly name : string ; Type: string The Kubernetes name of this resource. Enums \u00b6 EmptyDirMedium \u00b6 The medium on which to store the volume. DEFAULT \u00b6 The default volume of the backing node. MEMORY \u00b6 Mount a tmpfs (RAM-backed filesystem) for you instead. While tmpfs is very fast, be aware that unlike disks, tmpfs is cleared on node reboot and any files you write will count against your Container\u2019s memory limit. HttpIngressPathType \u00b6 Specify how the path is matched against request paths. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types PREFIX \u00b6 Matches the URL path exactly. EXACT \u00b6 Matches based on a URL path prefix split by \u2018/\u2019. IMPLEMENTATION_SPECIFIC \u00b6 Matching is specified by the underlying IngressClass. ImagePullPolicy \u00b6 ALWAYS \u00b6 Every time the kubelet launches a container, the kubelet queries the container image registry to resolve the name to an image digest. If the kubelet has a container image with that exact digest cached locally, the kubelet uses its cached image; otherwise, the kubelet downloads (pulls) the image with the resolved digest, and uses that image to launch the container. Default is Always if ImagePullPolicy is omitted and either the image tag is :latest or the image tag is omitted. IF_NOT_PRESENT \u00b6 The image is pulled only if it is not already present locally. Default is IfNotPresent if ImagePullPolicy is omitted and the image tag is present but not :latest NEVER \u00b6 The image is assumed to exist locally. No attempt is made to pull the image. MountPropagation \u00b6 NONE \u00b6 This volume mount will not receive any subsequent mounts that are mounted to this volume or any of its subdirectories by the host. In similar fashion, no mounts created by the Container will be visible on the host. This is the default mode. This mode is equal to private mount propagation as described in the Linux kernel documentation HOST_TO_CONTAINER \u00b6 This volume mount will receive all subsequent mounts that are mounted to this volume or any of its subdirectories. In other words, if the host mounts anything inside the volume mount, the Container will see it mounted there. Similarly, if any Pod with Bidirectional mount propagation to the same volume mounts anything there, the Container with HostToContainer mount propagation will see it. This mode is equal to rslave mount propagation as described in the Linux kernel documentation BIDIRECTIONAL \u00b6 This volume mount behaves the same the HostToContainer mount. In addition, all volume mounts created by the Container will be propagated back to the host and to all Containers of all Pods that use the same volume A typical use case for this mode is a Pod with a FlexVolume or CSI driver or a Pod that needs to mount something on the host using a hostPath volume. This mode is equal to rshared mount propagation as described in the Linux kernel documentation Caution: Bidirectional mount propagation can be dangerous. It can damage the host operating system and therefore it is allowed only in privileged Containers. Familiarity with Linux kernel behavior is strongly recommended. In addition, any volume mounts created by Containers in Pods must be destroyed (unmounted) by the Containers on termination. PodManagementPolicy \u00b6 Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once. ORDERED_READY \u00b6 PARALLEL \u00b6 Protocol \u00b6 TCP \u00b6 UDP \u00b6 SCTP \u00b6 RestartPolicy \u00b6 Restart policy for all containers within the pod. ALWAYS \u00b6 Always restart the pod after it exits. ON_FAILURE \u00b6 Only restart if the pod exits with a non-zero exit code. NEVER \u00b6 Never restart the pod. ServiceType \u00b6 For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP. CLUSTER_IP \u00b6 Exposes the Service on a cluster-internal IP. Choosing this value makes the Service only reachable from within the cluster. This is the default ServiceType NODE_PORT \u00b6 Exposes the Service on each Node\u2019s IP at a static port (the NodePort). A ClusterIP Service, to which the NodePort Service routes, is automatically created. You\u2019ll be able to contact the NodePort Service, from outside the cluster, by requesting : . LOAD_BALANCER \u00b6 Exposes the Service externally using a cloud provider\u2019s load balancer. NodePort and ClusterIP Services, to which the external load balancer routes, are automatically created. EXTERNAL_NAME \u00b6 Maps the Service to the contents of the externalName field (e.g. foo.bar.example.com), by returning a CNAME record with its value. No proxying of any kind is set up. Note: You need either kube-dns version 1.7 or CoreDNS version 0.0.8 or higher to use the ExternalName type.","title":"TypeScript"},{"location":"reference/cdk8s-plus-22/typescript/#cdk8s-plus-22-typescript","text":"","title":"cdk8s-plus-22 (TypeScript) "},{"location":"reference/cdk8s-plus-22/typescript/#constructs","text":"","title":"Constructs "},{"location":"reference/cdk8s-plus-22/typescript/#configmap","text":"Implements: cdk8s-plus-22.IConfigMap ConfigMap holds configuration data for pods to consume.","title":"ConfigMap "},{"location":"reference/cdk8s-plus-22/typescript/#deployment","text":"Implements: cdk8s-plus-22.IPodTemplate A Deployment provides declarative updates for Pods and ReplicaSets. You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments. Note: Do not manage ReplicaSets owned by a Deployment. Consider opening an issue in the main Kubernetes repository if your use case is not covered below.","title":"Deployment "},{"location":"reference/cdk8s-plus-22/typescript/#use-case","text":"The following are typical use cases for Deployments: Create a Deployment to rollout a ReplicaSet. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not. Declare the new state of the Pods by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment. Rollback to an earlier Deployment revision if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment. Scale up the Deployment to facilitate more load. Pause the Deployment to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout. Use the status of the Deployment as an indicator that a rollout has stuck. Clean up older ReplicaSets that you don\u2019t need anymore.","title":"Use Case"},{"location":"reference/cdk8s-plus-22/typescript/#ingress","text":"Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.","title":"Ingress "},{"location":"reference/cdk8s-plus-22/typescript/#job","text":"Implements: cdk8s-plus-22.IPodTemplate A Job creates one or more Pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. A simple case is to create one Job object in order to reliably run one Pod to completion. The Job object will start a new Pod if the first Pod fails or is deleted (for example due to a node hardware failure or a node reboot). You can also use a Job to run multiple Pods in parallel.","title":"Job "},{"location":"reference/cdk8s-plus-22/typescript/#pod","text":"Implements: cdk8s-plus-22.IPodSpec Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.","title":"Pod "},{"location":"reference/cdk8s-plus-22/typescript/#resource","text":"Implements: cdk8s-plus-22.IResource Base class for all Kubernetes objects in stdk8s. Represents a single resource.","title":"Resource "},{"location":"reference/cdk8s-plus-22/typescript/#secret","text":"Implements: cdk8s-plus-22.ISecret Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. https://kubernetes.io/docs/concepts/configuration/secret","title":"Secret "},{"location":"reference/cdk8s-plus-22/typescript/#service","text":"An abstract way to expose an application running on a set of Pods as a network service. With Kubernetes you don\u2019t need to modify your application to use an unfamiliar service discovery mechanism. Kubernetes gives Pods their own IP addresses and a single DNS name for a set of Pods, and can load-balance across them. For example, consider a stateless image-processing backend which is running with 3 replicas. Those replicas are fungible\u2014frontends do not care which backend they use. While the actual Pods that compose the backend set may change, the frontend clients should not need to be aware of that, nor should they need to keep track of the set of backends themselves. The Service abstraction enables this decoupling. If you\u2019re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes. For non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods.","title":"Service "},{"location":"reference/cdk8s-plus-22/typescript/#serviceaccount","text":"Implements: cdk8s-plus-22.IServiceAccount A service account provides an identity for processes that run in a Pod. When you (a human) access the cluster (for example, using kubectl), you are authenticated by the apiserver as a particular User Account (currently this is usually admin, unless your cluster administrator has customized your cluster). Processes in containers inside pods can also contact the apiserver. When they do, they are authenticated as a particular Service Account (for example, default). https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account","title":"ServiceAccount "},{"location":"reference/cdk8s-plus-22/typescript/#statefulset","text":"Implements: cdk8s-plus-22.IPodTemplate StatefulSet is the workload API object used to manage stateful applications. Manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. Like a Deployment, a StatefulSet manages Pods that are based on an identical container spec. Unlike a Deployment, a StatefulSet maintains a sticky identity for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling. If you want to use storage volumes to provide persistence for your workload, you can use a StatefulSet as part of the solution. Although individual Pods in a StatefulSet are susceptible to failure, the persistent Pod identifiers make it easier to match existing volumes to the new Pods that replace any that have failed.","title":"StatefulSet "},{"location":"reference/cdk8s-plus-22/typescript/#using-statefulsets","text":"StatefulSets are valuable for applications that require one or more of the following. Stable, unique network identifiers. Stable, persistent storage. Ordered, graceful deployment and scaling. Ordered, automated rolling updates.","title":"Using StatefulSets"},{"location":"reference/cdk8s-plus-22/typescript/#structs","text":"","title":"Structs "},{"location":"reference/cdk8s-plus-22/typescript/#adddeploymentoptions","text":"Options to add a deployment to a service.","title":"AddDeploymentOptions "},{"location":"reference/cdk8s-plus-22/typescript/#adddirectoryoptions","text":"Options for configmap.addDirectory() .","title":"AddDirectoryOptions "},{"location":"reference/cdk8s-plus-22/typescript/#commandprobeoptions","text":"Options for Probe.fromCommand() .","title":"CommandProbeOptions "},{"location":"reference/cdk8s-plus-22/typescript/#configmapprops","text":"Properties for initialization of ConfigMap .","title":"ConfigMapProps "},{"location":"reference/cdk8s-plus-22/typescript/#configmapvolumeoptions","text":"Options for the ConfigMap-based volume.","title":"ConfigMapVolumeOptions "},{"location":"reference/cdk8s-plus-22/typescript/#containerprops","text":"Properties for creating a container.","title":"ContainerProps "},{"location":"reference/cdk8s-plus-22/typescript/#deploymentprops","text":"Properties for initialization of Deployment .","title":"DeploymentProps "},{"location":"reference/cdk8s-plus-22/typescript/#emptydirvolumeoptions","text":"Options for volumes populated with an empty directory.","title":"EmptyDirVolumeOptions "},{"location":"reference/cdk8s-plus-22/typescript/#envvaluefromconfigmapoptions","text":"Options to specify an envionment variable value from a ConfigMap key.","title":"EnvValueFromConfigMapOptions "},{"location":"reference/cdk8s-plus-22/typescript/#envvaluefromprocessoptions","text":"Options to specify an environment variable value from the process environment.","title":"EnvValueFromProcessOptions "},{"location":"reference/cdk8s-plus-22/typescript/#envvaluefromsecretoptions","text":"Options to specify an environment variable value from a Secret.","title":"EnvValueFromSecretOptions "},{"location":"reference/cdk8s-plus-22/typescript/#exposedeploymentviaingressoptions","text":"Options for exposing a deployment via an ingress.","title":"ExposeDeploymentViaIngressOptions "},{"location":"reference/cdk8s-plus-22/typescript/#exposedeploymentviaserviceoptions","text":"Options for exposing a deployment via a service.","title":"ExposeDeploymentViaServiceOptions "},{"location":"reference/cdk8s-plus-22/typescript/#exposeserviceviaingressoptions","text":"Options for exposing a service using an ingress.","title":"ExposeServiceViaIngressOptions "},{"location":"reference/cdk8s-plus-22/typescript/#httpgetprobeoptions","text":"Options for Probe.fromHttpGet() .","title":"HttpGetProbeOptions "},{"location":"reference/cdk8s-plus-22/typescript/#ingressprops","text":"Properties for Ingress .","title":"IngressProps "},{"location":"reference/cdk8s-plus-22/typescript/#ingressrule","text":"Represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching path.","title":"IngressRule "},{"location":"reference/cdk8s-plus-22/typescript/#ingresstls","text":"Represents the TLS configuration mapping that is passed to the ingress controller for SSL termination.","title":"IngressTls "},{"location":"reference/cdk8s-plus-22/typescript/#jobprops","text":"Properties for initialization of Job .","title":"JobProps "},{"location":"reference/cdk8s-plus-22/typescript/#mountoptions","text":"Options for mounts.","title":"MountOptions "},{"location":"reference/cdk8s-plus-22/typescript/#pathmapping","text":"Maps a string key to a path within a volume.","title":"PathMapping "},{"location":"reference/cdk8s-plus-22/typescript/#podprops","text":"Properties for initialization of Pod .","title":"PodProps "},{"location":"reference/cdk8s-plus-22/typescript/#podspecprops","text":"Properties of a PodSpec .","title":"PodSpecProps "},{"location":"reference/cdk8s-plus-22/typescript/#podtemplateprops","text":"Properties of a PodTemplate . Adds metadata information on top of the spec.","title":"PodTemplateProps "},{"location":"reference/cdk8s-plus-22/typescript/#probeoptions","text":"Probe options.","title":"ProbeOptions "},{"location":"reference/cdk8s-plus-22/typescript/#resourceprops","text":"Initialization properties for resources.","title":"ResourceProps "},{"location":"reference/cdk8s-plus-22/typescript/#secretprops","text":"","title":"SecretProps "},{"location":"reference/cdk8s-plus-22/typescript/#secretvalue","text":"Represents a specific value in JSON secret.","title":"SecretValue "},{"location":"reference/cdk8s-plus-22/typescript/#serviceaccountprops","text":"Properties for initialization of ServiceAccount . Properties for initialization of ServiceAccount .","title":"ServiceAccountProps "},{"location":"reference/cdk8s-plus-22/typescript/#serviceingressbackendoptions","text":"Options for setting up backends for ingress rules.","title":"ServiceIngressBackendOptions "},{"location":"reference/cdk8s-plus-22/typescript/#serviceport","text":"Definition of a service port.","title":"ServicePort "},{"location":"reference/cdk8s-plus-22/typescript/#serviceportoptions","text":"","title":"ServicePortOptions "},{"location":"reference/cdk8s-plus-22/typescript/#serviceprops","text":"Properties for initialization of Service .","title":"ServiceProps "},{"location":"reference/cdk8s-plus-22/typescript/#statefulsetprops","text":"Properties for initialization of StatefulSet .","title":"StatefulSetProps "},{"location":"reference/cdk8s-plus-22/typescript/#volumemount","text":"Mount a volume from the pod to the container.","title":"VolumeMount "},{"location":"reference/cdk8s-plus-22/typescript/#classes","text":"","title":"Classes "},{"location":"reference/cdk8s-plus-22/typescript/#container","text":"A single application container that you want to run within a pod.","title":"Container "},{"location":"reference/cdk8s-plus-22/typescript/#envvalue","text":"Utility class for creating reading env values from various sources.","title":"EnvValue "},{"location":"reference/cdk8s-plus-22/typescript/#ingressbackend","text":"The backend for an ingress path.","title":"IngressBackend "},{"location":"reference/cdk8s-plus-22/typescript/#podspec","text":"Implements: cdk8s-plus-22.IPodSpec Provides read/write capabilities ontop of a PodSpecProps .","title":"PodSpec "},{"location":"reference/cdk8s-plus-22/typescript/#podtemplate","text":"Implements: cdk8s-plus-22.IPodTemplate Provides read/write capabilities ontop of a PodTemplateProps .","title":"PodTemplate "},{"location":"reference/cdk8s-plus-22/typescript/#probe","text":"Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.","title":"Probe "},{"location":"reference/cdk8s-plus-22/typescript/#volume","text":"Volume represents a named volume in a pod that may be accessed by any container in the pod. Docker also has a concept of volumes, though it is somewhat looser and less managed. In Docker, a volume is simply a directory on disk or in another Container. Lifetimes are not managed and until very recently there were only local-disk-backed volumes. Docker now provides volume drivers, but the functionality is very limited for now (e.g. as of Docker 1.7 only one volume driver is allowed per Container and there is no way to pass parameters to volumes). A Kubernetes volume, on the other hand, has an explicit lifetime - the same as the Pod that encloses it. Consequently, a volume outlives any Containers that run within the Pod, and data is preserved across Container restarts. Of course, when a Pod ceases to exist, the volume will cease to exist, too. Perhaps more importantly than this, Kubernetes supports many types of volumes, and a Pod can use any number of them simultaneously. At its core, a volume is just a directory, possibly with some data in it, which is accessible to the Containers in a Pod. How that directory comes to be, the medium that backs it, and the contents of it are determined by the particular volume type used. To use a volume, a Pod specifies what volumes to provide for the Pod (the .spec.volumes field) and where to mount those into Containers (the .spec.containers[*].volumeMounts field). A process in a container sees a filesystem view composed from their Docker image and volumes. The Docker image is at the root of the filesystem hierarchy, and any volumes are mounted at the specified paths within the image. Volumes can not mount onto other volumes","title":"Volume "},{"location":"reference/cdk8s-plus-22/typescript/#protocols","text":"","title":"Protocols "},{"location":"reference/cdk8s-plus-22/typescript/#iconfigmap","text":"Extends: cdk8s-plus-22.IResource Implemented By: cdk8s-plus-22.ConfigMap , cdk8s-plus-22.IConfigMap Represents a config map.","title":"IConfigMap "},{"location":"reference/cdk8s-plus-22/typescript/#ipodspec","text":"Implemented By: cdk8s-plus-22.Deployment , cdk8s-plus-22.Job , cdk8s-plus-22.Pod , cdk8s-plus-22.PodSpec , cdk8s-plus-22.PodTemplate , cdk8s-plus-22.StatefulSet , cdk8s-plus-22.IPodSpec , cdk8s-plus-22.IPodTemplate Represents a resource that can be configured with a kuberenets pod spec. (e.g Deployment , Job , Pod , \u2026). Use the PodSpec class as an implementation helper.","title":"IPodSpec "},{"location":"reference/cdk8s-plus-22/typescript/#ipodtemplate","text":"Extends: cdk8s-plus-22.IPodSpec Implemented By: cdk8s-plus-22.Deployment , cdk8s-plus-22.Job , cdk8s-plus-22.PodTemplate , cdk8s-plus-22.StatefulSet , cdk8s-plus-22.IPodTemplate Represents a resource that can be configured with a kuberenets pod template. (e.g Deployment , Job , \u2026). Use the PodTemplate class as an implementation helper.","title":"IPodTemplate "},{"location":"reference/cdk8s-plus-22/typescript/#iresource","text":"Implemented By: cdk8s-plus-22.ConfigMap , cdk8s-plus-22.Deployment , cdk8s-plus-22.Ingress , cdk8s-plus-22.Job , cdk8s-plus-22.Pod , cdk8s-plus-22.Resource , cdk8s-plus-22.Secret , cdk8s-plus-22.Service , cdk8s-plus-22.ServiceAccount , cdk8s-plus-22.StatefulSet , cdk8s-plus-22.IConfigMap , cdk8s-plus-22.IResource , cdk8s-plus-22.ISecret , cdk8s-plus-22.IServiceAccount Represents a resource.","title":"IResource "},{"location":"reference/cdk8s-plus-22/typescript/#isecret","text":"Extends: cdk8s-plus-22.IResource Implemented By: cdk8s-plus-22.Secret , cdk8s-plus-22.ISecret","title":"ISecret "},{"location":"reference/cdk8s-plus-22/typescript/#iserviceaccount","text":"Extends: cdk8s-plus-22.IResource Implemented By: cdk8s-plus-22.ServiceAccount , cdk8s-plus-22.IServiceAccount","title":"IServiceAccount "},{"location":"reference/cdk8s-plus-22/typescript/#enums","text":"","title":"Enums "},{"location":"reference/cdk8s-plus-22/typescript/#emptydirmedium","text":"The medium on which to store the volume.","title":"EmptyDirMedium "},{"location":"reference/cdk8s-plus-22/typescript/#httpingresspathtype","text":"Specify how the path is matched against request paths. https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types","title":"HttpIngressPathType "},{"location":"reference/cdk8s-plus-22/typescript/#imagepullpolicy","text":"","title":"ImagePullPolicy "},{"location":"reference/cdk8s-plus-22/typescript/#mountpropagation","text":"","title":"MountPropagation "},{"location":"reference/cdk8s-plus-22/typescript/#podmanagementpolicy","text":"Controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is OrderedReady , where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is Parallel which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.","title":"PodManagementPolicy "},{"location":"reference/cdk8s-plus-22/typescript/#protocol","text":"","title":"Protocol "},{"location":"reference/cdk8s-plus-22/typescript/#restartpolicy","text":"Restart policy for all containers within the pod.","title":"RestartPolicy "},{"location":"reference/cdk8s-plus-22/typescript/#servicetype","text":"For some parts of your application (for example, frontends) you may want to expose a Service onto an external IP address, that\u2019s outside of your cluster. Kubernetes ServiceTypes allow you to specify what kind of Service you want. The default is ClusterIP.","title":"ServiceType "}]}